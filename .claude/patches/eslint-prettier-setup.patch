diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index e4ad1d0..e12cf50 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -105,10 +105,8 @@ jobs:
       - name: Install dependencies
         run: npm ci
 
-      - name: Check code style (if eslint configured)
-        run: |
-          if [ -f ".eslintrc.js" ] || [ -f ".eslintrc.json" ] || [ -f ".eslintrc" ]; then
-            npm run lint 2>/dev/null || echo "Lint script not configured"
-          else
-            echo "ESLint not configured - skipping"
-          fi
+      - name: Run ESLint
+        run: npm run lint
+
+      - name: Check formatting with Prettier
+        run: npx prettier --check src/ tests/
diff --git a/package-lock.json b/package-lock.json
index c8871cb..6dfbf5e 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -26,7 +26,12 @@
         "uuid": "^10.0.0"
       },
       "devDependencies": {
+        "@eslint/js": "^9.39.2",
+        "eslint": "^9.39.2",
+        "eslint-config-prettier": "^10.1.8",
+        "eslint-plugin-prettier": "^5.5.4",
         "jest": "^29.7.0",
+        "prettier": "^3.7.4",
         "puppeteer": "^24.34.0",
         "supertest": "^6.3.3"
       }
@@ -674,6 +679,220 @@
         "@solana/web3.js": "^1.68.0"
       }
     },
+    "node_modules/@eslint-community/eslint-utils": {
+      "version": "4.9.1",
+      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.9.1.tgz",
+      "integrity": "sha512-phrYmNiYppR7znFEdqgfWHXR6NCkZEK7hwWDHZUjit/2/U0r6XvkDl0SYnoM51Hq7FhCGdLDT6zxCCOY1hexsQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "eslint-visitor-keys": "^3.4.3"
+      },
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/eslint"
+      },
+      "peerDependencies": {
+        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
+      }
+    },
+    "node_modules/@eslint-community/eslint-utils/node_modules/eslint-visitor-keys": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
+      "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "engines": {
+        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/eslint"
+      }
+    },
+    "node_modules/@eslint-community/regexpp": {
+      "version": "4.12.2",
+      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.2.tgz",
+      "integrity": "sha512-EriSTlt5OC9/7SXkRSCAhfSxxoSUgBm33OH+IkwbdpgoqsSsUg7y3uh+IICI/Qg4BBWr3U2i39RpmycbxMq4ew==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
+      }
+    },
+    "node_modules/@eslint/config-array": {
+      "version": "0.21.1",
+      "resolved": "https://registry.npmjs.org/@eslint/config-array/-/config-array-0.21.1.tgz",
+      "integrity": "sha512-aw1gNayWpdI/jSYVgzN5pL0cfzU02GT3NBpeT/DXbx1/1x7ZKxFPd9bwrzygx/qiwIQiJ1sw/zD8qY/kRvlGHA==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@eslint/object-schema": "^2.1.7",
+        "debug": "^4.3.1",
+        "minimatch": "^3.1.2"
+      },
+      "engines": {
+        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
+      }
+    },
+    "node_modules/@eslint/config-array/node_modules/debug": {
+      "version": "4.4.3",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
+      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ms": "^2.1.3"
+      },
+      "engines": {
+        "node": ">=6.0"
+      },
+      "peerDependenciesMeta": {
+        "supports-color": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/@eslint/config-array/node_modules/ms": {
+      "version": "2.1.3",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
+      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@eslint/config-helpers": {
+      "version": "0.4.2",
+      "resolved": "https://registry.npmjs.org/@eslint/config-helpers/-/config-helpers-0.4.2.tgz",
+      "integrity": "sha512-gBrxN88gOIf3R7ja5K9slwNayVcZgK6SOUORm2uBzTeIEfeVaIhOpCtTox3P6R7o2jLFwLFTLnC7kU/RGcYEgw==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@eslint/core": "^0.17.0"
+      },
+      "engines": {
+        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
+      }
+    },
+    "node_modules/@eslint/core": {
+      "version": "0.17.0",
+      "resolved": "https://registry.npmjs.org/@eslint/core/-/core-0.17.0.tgz",
+      "integrity": "sha512-yL/sLrpmtDaFEiUj1osRP4TI2MDz1AddJL+jZ7KSqvBuliN4xqYY54IfdN8qD8Toa6g1iloph1fxQNkjOxrrpQ==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@types/json-schema": "^7.0.15"
+      },
+      "engines": {
+        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
+      }
+    },
+    "node_modules/@eslint/eslintrc": {
+      "version": "3.3.3",
+      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-3.3.3.tgz",
+      "integrity": "sha512-Kr+LPIUVKz2qkx1HAMH8q1q6azbqBAsXJUxBl/ODDuVPX45Z9DfwB8tPjTi6nNZ8BuM3nbJxC5zCAg5elnBUTQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ajv": "^6.12.4",
+        "debug": "^4.3.2",
+        "espree": "^10.0.1",
+        "globals": "^14.0.0",
+        "ignore": "^5.2.0",
+        "import-fresh": "^3.2.1",
+        "js-yaml": "^4.1.1",
+        "minimatch": "^3.1.2",
+        "strip-json-comments": "^3.1.1"
+      },
+      "engines": {
+        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/eslint"
+      }
+    },
+    "node_modules/@eslint/eslintrc/node_modules/argparse": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
+      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
+      "dev": true,
+      "license": "Python-2.0"
+    },
+    "node_modules/@eslint/eslintrc/node_modules/debug": {
+      "version": "4.4.3",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
+      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ms": "^2.1.3"
+      },
+      "engines": {
+        "node": ">=6.0"
+      },
+      "peerDependenciesMeta": {
+        "supports-color": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/@eslint/eslintrc/node_modules/js-yaml": {
+      "version": "4.1.1",
+      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
+      "integrity": "sha512-qQKT4zQxXl8lLwBtHMWwaTcGfFOZviOJet3Oy/xmGk2gZH677CJM9EvtfdSkgWcATZhj/55JZ0rmy3myCT5lsA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "argparse": "^2.0.1"
+      },
+      "bin": {
+        "js-yaml": "bin/js-yaml.js"
+      }
+    },
+    "node_modules/@eslint/eslintrc/node_modules/ms": {
+      "version": "2.1.3",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
+      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/@eslint/js": {
+      "version": "9.39.2",
+      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-9.39.2.tgz",
+      "integrity": "sha512-q1mjIoW1VX4IvSocvM/vbTiveKC4k9eLrajNEuSsmjymSDEbpGddtpfOoN7YGAqBK3NG+uqo8ia4PDTt8buCYA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
+      },
+      "funding": {
+        "url": "https://eslint.org/donate"
+      }
+    },
+    "node_modules/@eslint/object-schema": {
+      "version": "2.1.7",
+      "resolved": "https://registry.npmjs.org/@eslint/object-schema/-/object-schema-2.1.7.tgz",
+      "integrity": "sha512-VtAOaymWVfZcmZbp6E2mympDIHvyjXs/12LqWYjVw6qjrfF+VK+fyG33kChz3nnK+SU5/NeHOqrTEHS8sXO3OA==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "engines": {
+        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
+      }
+    },
+    "node_modules/@eslint/plugin-kit": {
+      "version": "0.4.1",
+      "resolved": "https://registry.npmjs.org/@eslint/plugin-kit/-/plugin-kit-0.4.1.tgz",
+      "integrity": "sha512-43/qtrDUokr7LJqoF2c3+RInu/t4zfrpYdoSDfYyhg52rwLV6TnOvdG4fXm7IkSB3wErkcmJS9iEhjVtOSEjjA==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@eslint/core": "^0.17.0",
+        "levn": "^0.4.1"
+      },
+      "engines": {
+        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
+      }
+    },
     "node_modules/@grpc/grpc-js": {
       "version": "1.14.3",
       "resolved": "https://registry.npmjs.org/@grpc/grpc-js/-/grpc-js-1.14.3.tgz",
@@ -705,6 +924,58 @@
         "node": ">=6"
       }
     },
+    "node_modules/@humanfs/core": {
+      "version": "0.19.1",
+      "resolved": "https://registry.npmjs.org/@humanfs/core/-/core-0.19.1.tgz",
+      "integrity": "sha512-5DyQ4+1JEUzejeK1JGICcideyfUbGixgS9jNgex5nqkW+cY7WZhxBigmieN5Qnw9ZosSNVC9KQKyb+GUaGyKUA==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "engines": {
+        "node": ">=18.18.0"
+      }
+    },
+    "node_modules/@humanfs/node": {
+      "version": "0.16.7",
+      "resolved": "https://registry.npmjs.org/@humanfs/node/-/node-0.16.7.tgz",
+      "integrity": "sha512-/zUx+yOsIrG4Y43Eh2peDeKCxlRt/gET6aHfaKpuq267qXdYDFViVHfMaLyygZOnl0kGWxFIgsBy8QFuTLUXEQ==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "@humanfs/core": "^0.19.1",
+        "@humanwhocodes/retry": "^0.4.0"
+      },
+      "engines": {
+        "node": ">=18.18.0"
+      }
+    },
+    "node_modules/@humanwhocodes/module-importer": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
+      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "engines": {
+        "node": ">=12.22"
+      },
+      "funding": {
+        "type": "github",
+        "url": "https://github.com/sponsors/nzakas"
+      }
+    },
+    "node_modules/@humanwhocodes/retry": {
+      "version": "0.4.3",
+      "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.4.3.tgz",
+      "integrity": "sha512-bV0Tgo9K4hfPCek+aMAn81RppFKv2ySDQeMoSZuvTASywNTnVJCArCZE2FWqpvIatKu7VMRLWlR1EazvVhDyhQ==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "engines": {
+        "node": ">=18.18"
+      },
+      "funding": {
+        "type": "github",
+        "url": "https://github.com/sponsors/nzakas"
+      }
+    },
     "node_modules/@istanbuljs/load-nyc-config": {
       "version": "1.1.0",
       "resolved": "https://registry.npmjs.org/@istanbuljs/load-nyc-config/-/load-nyc-config-1.1.0.tgz",
@@ -1308,6 +1579,19 @@
         "@noble/hashes": "^1.1.5"
       }
     },
+    "node_modules/@pkgr/core": {
+      "version": "0.2.9",
+      "resolved": "https://registry.npmjs.org/@pkgr/core/-/core-0.2.9.tgz",
+      "integrity": "sha512-QNqXyfVS2wm9hweSYD2O7F0G06uurj9kZ96TRQE5Y9hU7+tgdZwIkbAKc5Ocy1HxEY2kuDQa6cQ1WRs/O5LFKA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": "^12.20.0 || ^14.18.0 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/pkgr"
+      }
+    },
     "node_modules/@protobufjs/aspromise": {
       "version": "1.1.2",
       "resolved": "https://registry.npmjs.org/@protobufjs/aspromise/-/aspromise-1.1.2.tgz",
@@ -1941,6 +2225,13 @@
         "@types/node": "*"
       }
     },
+    "node_modules/@types/estree": {
+      "version": "1.0.8",
+      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
+      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@types/graceful-fs": {
       "version": "4.1.9",
       "resolved": "https://registry.npmjs.org/@types/graceful-fs/-/graceful-fs-4.1.9.tgz",
@@ -1978,6 +2269,13 @@
         "@types/istanbul-lib-report": "*"
       }
     },
+    "node_modules/@types/json-schema": {
+      "version": "7.0.15",
+      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
+      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@types/node": {
       "version": "12.20.55",
       "resolved": "https://registry.npmjs.org/@types/node/-/node-12.20.55.tgz",
@@ -2047,6 +2345,30 @@
         "node": ">= 0.6"
       }
     },
+    "node_modules/acorn": {
+      "version": "8.15.0",
+      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
+      "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
+      "dev": true,
+      "license": "MIT",
+      "peer": true,
+      "bin": {
+        "acorn": "bin/acorn"
+      },
+      "engines": {
+        "node": ">=0.4.0"
+      }
+    },
+    "node_modules/acorn-jsx": {
+      "version": "5.3.2",
+      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
+      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
+      "dev": true,
+      "license": "MIT",
+      "peerDependencies": {
+        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
+      }
+    },
     "node_modules/agent-base": {
       "version": "7.1.4",
       "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-7.1.4.tgz",
@@ -2069,6 +2391,23 @@
         "node": ">= 8.0.0"
       }
     },
+    "node_modules/ajv": {
+      "version": "6.12.6",
+      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
+      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "fast-deep-equal": "^3.1.1",
+        "fast-json-stable-stringify": "^2.0.0",
+        "json-schema-traverse": "^0.4.1",
+        "uri-js": "^4.2.2"
+      },
+      "funding": {
+        "type": "github",
+        "url": "https://github.com/sponsors/epoberezkin"
+      }
+    },
     "node_modules/ansi-escapes": {
       "version": "4.3.2",
       "resolved": "https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-4.3.2.tgz",
@@ -3169,6 +3508,13 @@
         }
       }
     },
+    "node_modules/deep-is": {
+      "version": "0.1.4",
+      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
+      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/deepmerge": {
       "version": "4.3.1",
       "resolved": "https://registry.npmjs.org/deepmerge/-/deepmerge-4.3.1.tgz",
@@ -3423,70 +3769,347 @@
         "has-tostringtag": "^1.0.2",
         "hasown": "^2.0.2"
       },
-      "engines": {
-        "node": ">= 0.4"
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/es6-promise": {
+      "version": "4.2.8",
+      "resolved": "https://registry.npmjs.org/es6-promise/-/es6-promise-4.2.8.tgz",
+      "integrity": "sha512-HJDGx5daxeIvxdBxvG2cb9g4tEvwIk3i8+nhX0yGrYmZUzbkdg8QbDevheDB8gd0//uPj4c1EQua8Q+MViT0/w==",
+      "license": "MIT"
+    },
+    "node_modules/es6-promisify": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/es6-promisify/-/es6-promisify-5.0.0.tgz",
+      "integrity": "sha512-C+d6UdsYDk0lMebHNR4S2NybQMMngAOnOwYBQjTOiv0MkoJMP0Myw2mgpDLBcpfCmRLxyFqYhS/CfOENq4SJhQ==",
+      "license": "MIT",
+      "dependencies": {
+        "es6-promise": "^4.0.3"
+      }
+    },
+    "node_modules/escalade": {
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
+      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=6"
+      }
+    },
+    "node_modules/escape-html": {
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
+      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
+      "license": "MIT"
+    },
+    "node_modules/escape-string-regexp": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-2.0.0.tgz",
+      "integrity": "sha512-UpzcLCXolUWcNu5HtVMHYdXJjArjsF9C0aNnquZYY4uW/Vu0miy5YoWvbV345HauVvcAUnpRuhMMcqTcGOY2+w==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "node_modules/escodegen": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/escodegen/-/escodegen-2.1.0.tgz",
+      "integrity": "sha512-2NlIDTwUWJN0mRPQOdtQBzbUHvdGY2P1VXSyU83Q3xKxM7WHX2Ql8dKq782Q9TgQUNOLEzEYu9bzLNj1q88I5w==",
+      "dev": true,
+      "license": "BSD-2-Clause",
+      "dependencies": {
+        "esprima": "^4.0.1",
+        "estraverse": "^5.2.0",
+        "esutils": "^2.0.2"
+      },
+      "bin": {
+        "escodegen": "bin/escodegen.js",
+        "esgenerate": "bin/esgenerate.js"
+      },
+      "engines": {
+        "node": ">=6.0"
+      },
+      "optionalDependencies": {
+        "source-map": "~0.6.1"
+      }
+    },
+    "node_modules/eslint": {
+      "version": "9.39.2",
+      "resolved": "https://registry.npmjs.org/eslint/-/eslint-9.39.2.tgz",
+      "integrity": "sha512-LEyamqS7W5HB3ujJyvi0HQK/dtVINZvd5mAAp9eT5S/ujByGjiZLCzPcHVzuXbpJDJF/cxwHlfceVUDZ2lnSTw==",
+      "dev": true,
+      "license": "MIT",
+      "peer": true,
+      "dependencies": {
+        "@eslint-community/eslint-utils": "^4.8.0",
+        "@eslint-community/regexpp": "^4.12.1",
+        "@eslint/config-array": "^0.21.1",
+        "@eslint/config-helpers": "^0.4.2",
+        "@eslint/core": "^0.17.0",
+        "@eslint/eslintrc": "^3.3.1",
+        "@eslint/js": "9.39.2",
+        "@eslint/plugin-kit": "^0.4.1",
+        "@humanfs/node": "^0.16.6",
+        "@humanwhocodes/module-importer": "^1.0.1",
+        "@humanwhocodes/retry": "^0.4.2",
+        "@types/estree": "^1.0.6",
+        "ajv": "^6.12.4",
+        "chalk": "^4.0.0",
+        "cross-spawn": "^7.0.6",
+        "debug": "^4.3.2",
+        "escape-string-regexp": "^4.0.0",
+        "eslint-scope": "^8.4.0",
+        "eslint-visitor-keys": "^4.2.1",
+        "espree": "^10.4.0",
+        "esquery": "^1.5.0",
+        "esutils": "^2.0.2",
+        "fast-deep-equal": "^3.1.3",
+        "file-entry-cache": "^8.0.0",
+        "find-up": "^5.0.0",
+        "glob-parent": "^6.0.2",
+        "ignore": "^5.2.0",
+        "imurmurhash": "^0.1.4",
+        "is-glob": "^4.0.0",
+        "json-stable-stringify-without-jsonify": "^1.0.1",
+        "lodash.merge": "^4.6.2",
+        "minimatch": "^3.1.2",
+        "natural-compare": "^1.4.0",
+        "optionator": "^0.9.3"
+      },
+      "bin": {
+        "eslint": "bin/eslint.js"
+      },
+      "engines": {
+        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
+      },
+      "funding": {
+        "url": "https://eslint.org/donate"
+      },
+      "peerDependencies": {
+        "jiti": "*"
+      },
+      "peerDependenciesMeta": {
+        "jiti": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/eslint-config-prettier": {
+      "version": "10.1.8",
+      "resolved": "https://registry.npmjs.org/eslint-config-prettier/-/eslint-config-prettier-10.1.8.tgz",
+      "integrity": "sha512-82GZUjRS0p/jganf6q1rEO25VSoHH0hKPCTrgillPjdI/3bgBhAE1QzHrHTizjpRvy6pGAvKjDJtk2pF9NDq8w==",
+      "dev": true,
+      "license": "MIT",
+      "peer": true,
+      "bin": {
+        "eslint-config-prettier": "bin/cli.js"
+      },
+      "funding": {
+        "url": "https://opencollective.com/eslint-config-prettier"
+      },
+      "peerDependencies": {
+        "eslint": ">=7.0.0"
+      }
+    },
+    "node_modules/eslint-plugin-prettier": {
+      "version": "5.5.4",
+      "resolved": "https://registry.npmjs.org/eslint-plugin-prettier/-/eslint-plugin-prettier-5.5.4.tgz",
+      "integrity": "sha512-swNtI95SToIz05YINMA6Ox5R057IMAmWZ26GqPxusAp1TZzj+IdY9tXNWWD3vkF/wEqydCONcwjTFpxybBqZsg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "prettier-linter-helpers": "^1.0.0",
+        "synckit": "^0.11.7"
+      },
+      "engines": {
+        "node": "^14.18.0 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/eslint-plugin-prettier"
+      },
+      "peerDependencies": {
+        "@types/eslint": ">=8.0.0",
+        "eslint": ">=8.0.0",
+        "eslint-config-prettier": ">= 7.0.0 <10.0.0 || >=10.1.0",
+        "prettier": ">=3.0.0"
+      },
+      "peerDependenciesMeta": {
+        "@types/eslint": {
+          "optional": true
+        },
+        "eslint-config-prettier": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/eslint-scope": {
+      "version": "8.4.0",
+      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-8.4.0.tgz",
+      "integrity": "sha512-sNXOfKCn74rt8RICKMvJS7XKV/Xk9kA7DyJr8mJik3S7Cwgy3qlkkmyS2uQB3jiJg6VNdZd/pDBJu0nvG2NlTg==",
+      "dev": true,
+      "license": "BSD-2-Clause",
+      "dependencies": {
+        "esrecurse": "^4.3.0",
+        "estraverse": "^5.2.0"
+      },
+      "engines": {
+        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/eslint"
+      }
+    },
+    "node_modules/eslint-visitor-keys": {
+      "version": "4.2.1",
+      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.1.tgz",
+      "integrity": "sha512-Uhdk5sfqcee/9H/rCOJikYz67o0a2Tw2hGRPOG2Y1R2dg7brRe1uG0yaNQDHu+TO/uQPF/5eCapvYSmHUjt7JQ==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "engines": {
+        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/eslint"
+      }
+    },
+    "node_modules/eslint/node_modules/ansi-styles": {
+      "version": "4.3.0",
+      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
+      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "color-convert": "^2.0.1"
+      },
+      "engines": {
+        "node": ">=8"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
+      }
+    },
+    "node_modules/eslint/node_modules/chalk": {
+      "version": "4.1.2",
+      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
+      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ansi-styles": "^4.1.0",
+        "supports-color": "^7.1.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/chalk/chalk?sponsor=1"
+      }
+    },
+    "node_modules/eslint/node_modules/debug": {
+      "version": "4.4.3",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
+      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ms": "^2.1.3"
+      },
+      "engines": {
+        "node": ">=6.0"
+      },
+      "peerDependenciesMeta": {
+        "supports-color": {
+          "optional": true
+        }
+      }
+    },
+    "node_modules/eslint/node_modules/escape-string-regexp": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
+      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
       }
     },
-    "node_modules/es6-promise": {
-      "version": "4.2.8",
-      "resolved": "https://registry.npmjs.org/es6-promise/-/es6-promise-4.2.8.tgz",
-      "integrity": "sha512-HJDGx5daxeIvxdBxvG2cb9g4tEvwIk3i8+nhX0yGrYmZUzbkdg8QbDevheDB8gd0//uPj4c1EQua8Q+MViT0/w==",
-      "license": "MIT"
-    },
-    "node_modules/es6-promisify": {
+    "node_modules/eslint/node_modules/find-up": {
       "version": "5.0.0",
-      "resolved": "https://registry.npmjs.org/es6-promisify/-/es6-promisify-5.0.0.tgz",
-      "integrity": "sha512-C+d6UdsYDk0lMebHNR4S2NybQMMngAOnOwYBQjTOiv0MkoJMP0Myw2mgpDLBcpfCmRLxyFqYhS/CfOENq4SJhQ==",
+      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
+      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
+      "dev": true,
       "license": "MIT",
       "dependencies": {
-        "es6-promise": "^4.0.3"
+        "locate-path": "^6.0.0",
+        "path-exists": "^4.0.0"
+      },
+      "engines": {
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
       }
     },
-    "node_modules/escalade": {
-      "version": "3.2.0",
-      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
-      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
+    "node_modules/eslint/node_modules/locate-path": {
+      "version": "6.0.0",
+      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
+      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
+      "dev": true,
       "license": "MIT",
+      "dependencies": {
+        "p-locate": "^5.0.0"
+      },
       "engines": {
-        "node": ">=6"
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
       }
     },
-    "node_modules/escape-html": {
-      "version": "1.0.3",
-      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
-      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
+    "node_modules/eslint/node_modules/ms": {
+      "version": "2.1.3",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
+      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
+      "dev": true,
       "license": "MIT"
     },
-    "node_modules/escape-string-regexp": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-2.0.0.tgz",
-      "integrity": "sha512-UpzcLCXolUWcNu5HtVMHYdXJjArjsF9C0aNnquZYY4uW/Vu0miy5YoWvbV345HauVvcAUnpRuhMMcqTcGOY2+w==",
+    "node_modules/eslint/node_modules/p-locate": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
+      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
       "dev": true,
       "license": "MIT",
+      "dependencies": {
+        "p-limit": "^3.0.2"
+      },
       "engines": {
-        "node": ">=8"
+        "node": ">=10"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
       }
     },
-    "node_modules/escodegen": {
-      "version": "2.1.0",
-      "resolved": "https://registry.npmjs.org/escodegen/-/escodegen-2.1.0.tgz",
-      "integrity": "sha512-2NlIDTwUWJN0mRPQOdtQBzbUHvdGY2P1VXSyU83Q3xKxM7WHX2Ql8dKq782Q9TgQUNOLEzEYu9bzLNj1q88I5w==",
+    "node_modules/espree": {
+      "version": "10.4.0",
+      "resolved": "https://registry.npmjs.org/espree/-/espree-10.4.0.tgz",
+      "integrity": "sha512-j6PAQ2uUr79PZhBjP5C5fhl8e39FmRnOjsD5lGnWrFU8i2G776tBK7+nP8KuQUTTyAZUwfQqXAgrVH5MbH9CYQ==",
       "dev": true,
       "license": "BSD-2-Clause",
       "dependencies": {
-        "esprima": "^4.0.1",
-        "estraverse": "^5.2.0",
-        "esutils": "^2.0.2"
-      },
-      "bin": {
-        "escodegen": "bin/escodegen.js",
-        "esgenerate": "bin/esgenerate.js"
+        "acorn": "^8.15.0",
+        "acorn-jsx": "^5.3.2",
+        "eslint-visitor-keys": "^4.2.1"
       },
       "engines": {
-        "node": ">=6.0"
+        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
       },
-      "optionalDependencies": {
-        "source-map": "~0.6.1"
+      "funding": {
+        "url": "https://opencollective.com/eslint"
       }
     },
     "node_modules/esprima": {
@@ -3503,6 +4126,32 @@
         "node": ">=4"
       }
     },
+    "node_modules/esquery": {
+      "version": "1.7.0",
+      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.7.0.tgz",
+      "integrity": "sha512-Ap6G0WQwcU/LHsvLwON1fAQX9Zp0A2Y6Y/cJBl9r/JbW90Zyg4/zbG6zzKa2OTALELarYHmKu0GhpM5EO+7T0g==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "estraverse": "^5.1.0"
+      },
+      "engines": {
+        "node": ">=0.10"
+      }
+    },
+    "node_modules/esrecurse": {
+      "version": "4.3.0",
+      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
+      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
+      "dev": true,
+      "license": "BSD-2-Clause",
+      "dependencies": {
+        "estraverse": "^5.2.0"
+      },
+      "engines": {
+        "node": ">=4.0"
+      }
+    },
     "node_modules/estraverse": {
       "version": "5.3.0",
       "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
@@ -3733,6 +4382,20 @@
         "node": "> 0.1.90"
       }
     },
+    "node_modules/fast-deep-equal": {
+      "version": "3.1.3",
+      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
+      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/fast-diff": {
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/fast-diff/-/fast-diff-1.3.0.tgz",
+      "integrity": "sha512-VxPP4NqbUjj6MaAOafWeUn2cXWLcCtljklUtZf0Ind4XQ+QPtmA0b18zZy0jIQx+ExRVCR/ZQpBmik5lXshNsw==",
+      "dev": true,
+      "license": "Apache-2.0"
+    },
     "node_modules/fast-fifo": {
       "version": "1.3.2",
       "resolved": "https://registry.npmjs.org/fast-fifo/-/fast-fifo-1.3.2.tgz",
@@ -3747,6 +4410,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/fast-levenshtein": {
+      "version": "2.0.6",
+      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
+      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/fast-safe-stringify": {
       "version": "2.1.1",
       "resolved": "https://registry.npmjs.org/fast-safe-stringify/-/fast-safe-stringify-2.1.1.tgz",
@@ -3787,6 +4457,19 @@
         "pend": "~1.2.0"
       }
     },
+    "node_modules/file-entry-cache": {
+      "version": "8.0.0",
+      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-8.0.0.tgz",
+      "integrity": "sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "flat-cache": "^4.0.0"
+      },
+      "engines": {
+        "node": ">=16.0.0"
+      }
+    },
     "node_modules/file-uri-to-path": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/file-uri-to-path/-/file-uri-to-path-1.0.0.tgz",
@@ -3838,6 +4521,27 @@
         "node": ">=8"
       }
     },
+    "node_modules/flat-cache": {
+      "version": "4.0.1",
+      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-4.0.1.tgz",
+      "integrity": "sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "flatted": "^3.2.9",
+        "keyv": "^4.5.4"
+      },
+      "engines": {
+        "node": ">=16"
+      }
+    },
+    "node_modules/flatted": {
+      "version": "3.3.3",
+      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.3.tgz",
+      "integrity": "sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==",
+      "dev": true,
+      "license": "ISC"
+    },
     "node_modules/form-data": {
       "version": "4.0.5",
       "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.5.tgz",
@@ -4089,6 +4793,32 @@
         "url": "https://github.com/sponsors/isaacs"
       }
     },
+    "node_modules/glob-parent": {
+      "version": "6.0.2",
+      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
+      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "is-glob": "^4.0.3"
+      },
+      "engines": {
+        "node": ">=10.13.0"
+      }
+    },
+    "node_modules/globals": {
+      "version": "14.0.0",
+      "resolved": "https://registry.npmjs.org/globals/-/globals-14.0.0.tgz",
+      "integrity": "sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/gopd": {
       "version": "1.2.0",
       "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
@@ -4323,6 +5053,16 @@
       ],
       "license": "BSD-3-Clause"
     },
+    "node_modules/ignore": {
+      "version": "5.3.2",
+      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
+      "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">= 4"
+      }
+    },
     "node_modules/import-fresh": {
       "version": "3.3.1",
       "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
@@ -4439,6 +5179,16 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/is-extglob": {
+      "version": "2.1.1",
+      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
+      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
     "node_modules/is-fullwidth-code-point": {
       "version": "3.0.0",
       "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
@@ -4458,6 +5208,19 @@
         "node": ">=6"
       }
     },
+    "node_modules/is-glob": {
+      "version": "4.0.3",
+      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
+      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "is-extglob": "^2.1.1"
+      },
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
     "node_modules/is-number": {
       "version": "7.0.0",
       "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
@@ -5853,6 +6616,13 @@
         "node": ">=6"
       }
     },
+    "node_modules/json-buffer": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz",
+      "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/json-parse-even-better-errors": {
       "version": "2.3.1",
       "resolved": "https://registry.npmjs.org/json-parse-even-better-errors/-/json-parse-even-better-errors-2.3.1.tgz",
@@ -5860,6 +6630,20 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/json-schema-traverse": {
+      "version": "0.4.1",
+      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
+      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/json-stable-stringify-without-jsonify": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
+      "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/json-stringify-safe": {
       "version": "5.0.1",
       "resolved": "https://registry.npmjs.org/json-stringify-safe/-/json-stringify-safe-5.0.1.tgz",
@@ -5879,6 +6663,16 @@
         "node": ">=6"
       }
     },
+    "node_modules/keyv": {
+      "version": "4.5.4",
+      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
+      "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "json-buffer": "3.0.1"
+      }
+    },
     "node_modules/kleur": {
       "version": "3.0.3",
       "resolved": "https://registry.npmjs.org/kleur/-/kleur-3.0.3.tgz",
@@ -5899,6 +6693,20 @@
         "node": ">=6"
       }
     },
+    "node_modules/levn": {
+      "version": "0.4.1",
+      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
+      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "prelude-ls": "^1.2.1",
+        "type-check": "~0.4.0"
+      },
+      "engines": {
+        "node": ">= 0.8.0"
+      }
+    },
     "node_modules/lines-and-columns": {
       "version": "1.2.4",
       "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
@@ -5925,6 +6733,13 @@
       "integrity": "sha512-TwuEnCnxbc3rAvhf/LbG7tJUDzhqXyFnv3dtzLOPgCG/hODL7WFnsbwktkD7yUV0RrreP/l1PALq/YSg6VvjlA==",
       "license": "MIT"
     },
+    "node_modules/lodash.merge": {
+      "version": "4.6.2",
+      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
+      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/long": {
       "version": "5.3.2",
       "resolved": "https://registry.npmjs.org/long/-/long-5.3.2.tgz",
@@ -6286,6 +7101,24 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/optionator": {
+      "version": "0.9.4",
+      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz",
+      "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "deep-is": "^0.1.3",
+        "fast-levenshtein": "^2.0.6",
+        "levn": "^0.4.1",
+        "prelude-ls": "^1.2.1",
+        "type-check": "^0.4.0",
+        "word-wrap": "^1.2.5"
+      },
+      "engines": {
+        "node": ">= 0.8.0"
+      }
+    },
     "node_modules/p-limit": {
       "version": "3.1.0",
       "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
@@ -6669,6 +7502,46 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/prelude-ls": {
+      "version": "1.2.1",
+      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
+      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.8.0"
+      }
+    },
+    "node_modules/prettier": {
+      "version": "3.7.4",
+      "resolved": "https://registry.npmjs.org/prettier/-/prettier-3.7.4.tgz",
+      "integrity": "sha512-v6UNi1+3hSlVvv8fSaoUbggEM5VErKmmpGA7Pl3HF8V6uKY7rvClBOJlH6yNwQtfTueNkGVpOv/mtWL9L4bgRA==",
+      "dev": true,
+      "license": "MIT",
+      "peer": true,
+      "bin": {
+        "prettier": "bin/prettier.cjs"
+      },
+      "engines": {
+        "node": ">=14"
+      },
+      "funding": {
+        "url": "https://github.com/prettier/prettier?sponsor=1"
+      }
+    },
+    "node_modules/prettier-linter-helpers": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/prettier-linter-helpers/-/prettier-linter-helpers-1.0.1.tgz",
+      "integrity": "sha512-SxToR7P8Y2lWmv/kTzVLC1t/GDI2WGjMwNhLLE9qtH8Q13C+aEmuRlzDst4Up4s0Wc8sF2M+J57iB3cMLqftfg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "fast-diff": "^1.1.2"
+      },
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/pretty-format": {
       "version": "29.7.0",
       "resolved": "https://registry.npmjs.org/pretty-format/-/pretty-format-29.7.0.tgz",
@@ -6827,6 +7700,16 @@
         "once": "^1.3.1"
       }
     },
+    "node_modules/punycode": {
+      "version": "2.3.1",
+      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
+      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=6"
+      }
+    },
     "node_modules/puppeteer": {
       "version": "24.34.0",
       "resolved": "https://registry.npmjs.org/puppeteer/-/puppeteer-24.34.0.tgz",
@@ -7685,6 +8568,22 @@
         "url": "https://github.com/sponsors/ljharb"
       }
     },
+    "node_modules/synckit": {
+      "version": "0.11.11",
+      "resolved": "https://registry.npmjs.org/synckit/-/synckit-0.11.11.tgz",
+      "integrity": "sha512-MeQTA1r0litLUf0Rp/iisCaL8761lKAZHaimlbGK4j0HysC4PLfqygQj9srcs0m2RdtDYnF8UuYyKpbjHYp7Jw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@pkgr/core": "^0.2.9"
+      },
+      "engines": {
+        "node": "^14.18.0 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://opencollective.com/synckit"
+      }
+    },
     "node_modules/tar-fs": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/tar-fs/-/tar-fs-3.1.1.tgz",
@@ -7801,6 +8700,19 @@
       "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw==",
       "license": "Unlicense"
     },
+    "node_modules/type-check": {
+      "version": "0.4.0",
+      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
+      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "prelude-ls": "^1.2.1"
+      },
+      "engines": {
+        "node": ">= 0.8.0"
+      }
+    },
     "node_modules/type-detect": {
       "version": "4.0.8",
       "resolved": "https://registry.npmjs.org/type-detect/-/type-detect-4.0.8.tgz",
@@ -7904,6 +8816,16 @@
         "browserslist": ">= 4.21.0"
       }
     },
+    "node_modules/uri-js": {
+      "version": "4.4.1",
+      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
+      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
+      "dev": true,
+      "license": "BSD-2-Clause",
+      "dependencies": {
+        "punycode": "^2.1.0"
+      }
+    },
     "node_modules/utils-merge": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
@@ -7999,6 +8921,16 @@
         "node": ">= 8"
       }
     },
+    "node_modules/word-wrap": {
+      "version": "1.2.5",
+      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
+      "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
     "node_modules/wrap-ansi": {
       "version": "7.0.0",
       "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
diff --git a/package.json b/package.json
index ea2d576..0646dc3 100644
--- a/package.json
+++ b/package.json
@@ -9,6 +9,9 @@
     "test": "NODE_ENV=test jest",
     "test:watch": "NODE_ENV=test jest --watch",
     "test:coverage": "NODE_ENV=test jest --coverage",
+    "lint": "eslint src/ tests/",
+    "lint:fix": "eslint src/ tests/ --fix",
+    "format": "prettier --write src/ tests/",
     "setup:wallet": "node scripts/setup-wallet.js"
   },
   "keywords": [
@@ -35,7 +38,12 @@
     "uuid": "^10.0.0"
   },
   "devDependencies": {
+    "@eslint/js": "^9.39.2",
+    "eslint": "^9.39.2",
+    "eslint-config-prettier": "^10.1.8",
+    "eslint-plugin-prettier": "^5.5.4",
     "jest": "^29.7.0",
+    "prettier": "^3.7.4",
     "puppeteer": "^24.34.0",
     "supertest": "^6.3.3"
   }
diff --git a/src/index.js b/src/index.js
index 6bcf8e6..82f0c7a 100644
--- a/src/index.js
+++ b/src/index.js
@@ -8,7 +8,11 @@ const db = require('./utils/db');
 const { securityHeaders, globalLimiter } = require('./middleware/security');
 const { startBurnWorker } = require('./services/burn');
 const { collect: collectMetrics, metricsMiddleware } = require('./utils/metrics');
-const { startMonitoring: startAlertMonitoring, stopMonitoring: stopAlertMonitoring, alertingService } = require('./services/alerting');
+const {
+  startMonitoring: startAlertMonitoring,
+  stopMonitoring: stopAlertMonitoring,
+  alertingService,
+} = require('./services/alerting');
 
 // Routes
 const quoteRouter = require('./routes/quote');
@@ -25,12 +29,14 @@ app.set('trust proxy', 1);
 
 // Security middleware
 app.use(securityHeaders);
-app.use(cors({
-  // SECURITY: In production, require explicit ALLOWED_ORIGINS - never default to '*'
-  origin: config.IS_DEV ? '*' : (process.env.ALLOWED_ORIGINS?.split(',') || []),
-  methods: ['GET', 'POST'],
-  allowedHeaders: ['Content-Type', 'x-request-id'],
-}));
+app.use(
+  cors({
+    // SECURITY: In production, require explicit ALLOWED_ORIGINS - never default to '*'
+    origin: config.IS_DEV ? '*' : process.env.ALLOWED_ORIGINS?.split(',') || [],
+    methods: ['GET', 'POST'],
+    allowedHeaders: ['Content-Type', 'x-request-id'],
+  })
+);
 
 // Request parsing
 app.use(express.json({ limit: '100kb' }));
@@ -154,7 +160,7 @@ app.get('/status', async (req, res) => {
       oracle: oracleHealth,
     };
 
-    const statuses = Object.values(components).map(c => c.status);
+    const statuses = Object.values(components).map((c) => c.status);
     let overall = 'operational';
     if (statuses.includes('outage')) overall = 'major_outage';
     else if (statuses.includes('degraded')) overall = 'degraded';
@@ -282,7 +288,11 @@ async function start() {
       console.log('');
 
       // Start burn worker only if properly configured
-      if (config.FEE_PAYER_PRIVATE_KEY && config.ASDF_MINT && !config.ASDF_MINT.includes('DEVNET')) {
+      if (
+        config.FEE_PAYER_PRIVATE_KEY &&
+        config.ASDF_MINT &&
+        !config.ASDF_MINT.includes('DEVNET')
+      ) {
         startBurnWorker(60000);
       } else if (config.IS_DEV) {
         logger.info('BOOT', 'Burn worker disabled (dev mode or missing ASDF_MINT)');
diff --git a/src/middleware/security.js b/src/middleware/security.js
index b233df2..6b4d6bd 100644
--- a/src/middleware/security.js
+++ b/src/middleware/security.js
@@ -6,24 +6,26 @@ const logger = require('../utils/logger');
 
 // Security headers
 const securityHeaders = helmet({
-  contentSecurityPolicy: config.IS_DEV ? false : {
-    directives: {
-      defaultSrc: ["'self'"],
-      scriptSrc: ["'self'", "'unsafe-inline'"],
-      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
-      fontSrc: ["'self'", "https://fonts.gstatic.com"],
-      imgSrc: ["'self'", "data:", "https:"],
-      // Allow dashboard to fetch from external APIs
-      connectSrc: [
-        "'self'",
-        "https://asdev-backend.onrender.com",  // HolDex API
-        "https://api.coingecko.com",           // SOL price
-        "https://price.jup.ag",                // Jupiter fallback
-      ],
-      frameSrc: ["'none'"],
-      objectSrc: ["'none'"],
-    },
-  },
+  contentSecurityPolicy: config.IS_DEV
+    ? false
+    : {
+        directives: {
+          defaultSrc: ["'self'"],
+          scriptSrc: ["'self'", "'unsafe-inline'"],
+          styleSrc: ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'],
+          fontSrc: ["'self'", 'https://fonts.gstatic.com'],
+          imgSrc: ["'self'", 'data:', 'https:'],
+          // Allow dashboard to fetch from external APIs
+          connectSrc: [
+            "'self'",
+            'https://asdev-backend.onrender.com', // HolDex API
+            'https://api.coingecko.com', // SOL price
+            'https://price.jup.ag', // Jupiter fallback
+          ],
+          frameSrc: ["'none'"],
+          objectSrc: ["'none'"],
+        },
+      },
   crossOriginEmbedderPolicy: false,
 });
 
diff --git a/src/routes/admin.js b/src/routes/admin.js
index cc0b3e2..035c6c6 100644
--- a/src/routes/admin.js
+++ b/src/routes/admin.js
@@ -122,7 +122,7 @@ router.post('/burn', async (req, res) => {
         success: false,
         message: 'Burn not executed (already in progress or below threshold)',
         treasury: {
-          tokens: balances.map(b => ({
+          tokens: balances.map((b) => ({
             mint: b.mint,
             symbol: b.symbol,
             balance: b.uiAmount,
@@ -168,12 +168,12 @@ router.get('/treasury', async (req, res) => {
     const balances = await getTreasuryTokenBalances();
 
     res.json({
-      tokens: balances.map(b => ({
+      tokens: balances.map((b) => ({
         mint: b.mint,
         symbol: b.symbol,
         balance: b.uiAmount,
         valueUsd: b.valueUsd,
-        eligible: b.valueUsd >= 0.50, // MIN_VALUE_USD
+        eligible: b.valueUsd >= 0.5, // MIN_VALUE_USD
       })),
       totalTokens: balances.length,
       totalValueUsd: balances.reduce((sum, b) => sum + (b.valueUsd || 0), 0),
diff --git a/src/routes/health.js b/src/routes/health.js
index 5de2e77..5568299 100644
--- a/src/routes/health.js
+++ b/src/routes/health.js
@@ -42,12 +42,22 @@ router.get('/', async (req, res) => {
     withTimeout(checkVelocity(), HEALTH_CHECK_TIMEOUT, 'Velocity metrics'),
   ]);
 
-  health.checks.redis = checks[0].status === 'fulfilled' ? checks[0].value : { status: 'error', error: checks[0].reason?.message };
-  health.checks.rpc = checks[1].status === 'fulfilled' ? checks[1].value : { status: 'error', error: checks[1].reason?.message };
-  health.checks.feePayer = checks[2].status === 'fulfilled' ? checks[2].value : { status: 'error', error: checks[2].reason?.message };
+  health.checks.redis =
+    checks[0].status === 'fulfilled'
+      ? checks[0].value
+      : { status: 'error', error: checks[0].reason?.message };
+  health.checks.rpc =
+    checks[1].status === 'fulfilled'
+      ? checks[1].value
+      : { status: 'error', error: checks[1].reason?.message };
+  health.checks.feePayer =
+    checks[2].status === 'fulfilled'
+      ? checks[2].value
+      : { status: 'error', error: checks[2].reason?.message };
 
   // Velocity metrics (behavioral proof for treasury refill)
-  health.velocity = checks[3].status === 'fulfilled' ? checks[3].value : { error: checks[3].reason?.message };
+  health.velocity =
+    checks[3].status === 'fulfilled' ? checks[3].value : { error: checks[3].reason?.message };
 
   // Add circuit breaker status (includes PostgreSQL circuit)
   health.circuitBreakers = {
@@ -78,13 +88,14 @@ router.get('/', async (req, res) => {
 
   // Determine overall status
   // In staging/production, Redis is CRITICAL - treat it as error
-  const hasError = Object.values(health.checks).some(c => c.status === 'error');
-  const hasCriticalWarning = (config.IS_STAGING || config.IS_PROD) && health.checks.redis?.status === 'warning';
-  const hasWarning = Object.values(health.checks).some(c => c.status === 'warning');
+  const hasError = Object.values(health.checks).some((c) => c.status === 'error');
+  const hasCriticalWarning =
+    (config.IS_STAGING || config.IS_PROD) && health.checks.redis?.status === 'warning';
+  const hasWarning = Object.values(health.checks).some((c) => c.status === 'warning');
 
   // Check if any circuit breaker is open
   const hasOpenCircuitBreaker = Object.values(health.circuitBreakers).some(
-    cb => cb.state === 'open' || (cb.state === undefined && cb.isConnected === false)
+    (cb) => cb.state === 'open' || (cb.state === undefined && cb.isConnected === false)
   );
 
   if (hasError || hasCriticalWarning) {
@@ -106,15 +117,22 @@ router.get('/ready', async (req, res) => {
   try {
     // Check critical dependencies with timeout protection
     const [redisCheck, rpcCheck, feePayerCheck] = await Promise.all([
-      withTimeout(checkRedis(), HEALTH_CHECK_TIMEOUT, 'Redis').catch(() => ({ status: 'error', message: 'timeout' })),
-      withTimeout(checkRpc(), HEALTH_CHECK_TIMEOUT, 'RPC').catch(() => ({ status: 'error', message: 'timeout' })),
-      withTimeout(checkFeePayer(), HEALTH_CHECK_TIMEOUT, 'FeePayer').catch(() => ({ status: 'error', message: 'timeout' })),
+      withTimeout(checkRedis(), HEALTH_CHECK_TIMEOUT, 'Redis').catch(() => ({
+        status: 'error',
+        message: 'timeout',
+      })),
+      withTimeout(checkRpc(), HEALTH_CHECK_TIMEOUT, 'RPC').catch(() => ({
+        status: 'error',
+        message: 'timeout',
+      })),
+      withTimeout(checkFeePayer(), HEALTH_CHECK_TIMEOUT, 'FeePayer').catch(() => ({
+        status: 'error',
+        message: 'timeout',
+      })),
     ]);
 
     // In staging/production, Redis is required
-    const redisOk = config.IS_DEV
-      ? redisCheck.status !== 'error'
-      : redisCheck.status === 'ok'; // Staging and production require actual Redis
+    const redisOk = config.IS_DEV ? redisCheck.status !== 'error' : redisCheck.status === 'ok'; // Staging and production require actual Redis
 
     const rpcOk = rpcCheck.status === 'ok';
     const feePayerOk = feePayerCheck.status !== 'error';
@@ -258,13 +276,18 @@ async function checkFeePayer() {
   }
 
   try {
-    const { getPayerBalances, getHealthSummary, MIN_HEALTHY_BALANCE, WARNING_BALANCE } = require('../services/signer');
+    const {
+      getPayerBalances,
+      getHealthSummary,
+      MIN_HEALTHY_BALANCE,
+      WARNING_BALANCE,
+    } = require('../services/signer');
 
     const balances = await getPayerBalances();
     const summary = getHealthSummary();
 
     // Format payer details
-    const payers = balances.map(p => ({
+    const payers = balances.map((p) => ({
       pubkey: `${p.pubkey.slice(0, 8)}...${p.pubkey.slice(-4)}`,
       balance: p.balanceSol.toFixed(4),
       status: p.status,
diff --git a/src/routes/quote.js b/src/routes/quote.js
index 4d68a4f..d837ccb 100644
--- a/src/routes/quote.js
+++ b/src/routes/quote.js
@@ -238,13 +238,15 @@ router.post('/', validate('quote'), walletQuoteLimiter, async (req, res) => {
         kRank: tokenCheck.kRank,
         creditRating: tokenCheck.creditRating,
         // Dual-burn flywheel (Pure Golden -based economics)
-        dualBurn: tokenCheck.ecosystemBurn ? {
-          burnedPercent: tokenCheck.supply?.burnedPercent || 0,
-          ecosystemBurnPct: tokenCheck.ecosystemBurn.ecosystemBurnPct,
-          asdfBurnPct: tokenCheck.ecosystemBurn.asdfBurnPct,
-          treasuryPct: tokenCheck.ecosystemBurn.treasuryPct,
-          explanation: tokenCheck.ecosystemBurn.explanation,
-        } : null,
+        dualBurn: tokenCheck.ecosystemBurn
+          ? {
+              burnedPercent: tokenCheck.supply?.burnedPercent || 0,
+              ecosystemBurnPct: tokenCheck.ecosystemBurn.ecosystemBurnPct,
+              asdfBurnPct: tokenCheck.ecosystemBurn.asdfBurnPct,
+              treasuryPct: tokenCheck.ecosystemBurn.treasuryPct,
+              explanation: tokenCheck.ecosystemBurn.explanation,
+            }
+          : null,
       },
       holderTier: {
         tier: tierInfo.tier,
diff --git a/src/routes/stats.js b/src/routes/stats.js
index 0c5c69c..0c7f5c8 100644
--- a/src/routes/stats.js
+++ b/src/routes/stats.js
@@ -103,9 +103,8 @@ router.get('/wallet/:address', async (req, res) => {
     ]);
 
     // Calculate contribution percentage
-    const contributionPercent = globalStats.burnTotal > 0
-      ? (walletStats.totalBurned / globalStats.burnTotal) * 100
-      : 0;
+    const contributionPercent =
+      globalStats.burnTotal > 0 ? (walletStats.totalBurned / globalStats.burnTotal) * 100 : 0;
 
     res.json({
       wallet: address,
@@ -117,9 +116,10 @@ router.get('/wallet/:address', async (req, res) => {
       contributionPercent: contributionPercent.toFixed(4),
       // CCM-aligned messaging
       impact: {
-        message: walletStats.totalBurned > 0
-          ? `You've contributed ${formatAsdf(walletStats.totalBurned)} to the burn`
-          : 'Start transacting to contribute to the burn',
+        message:
+          walletStats.totalBurned > 0
+            ? `You've contributed ${formatAsdf(walletStats.totalBurned)} to the burn`
+            : 'Start transacting to contribute to the burn',
         rankMessage: walletStats.rank
           ? `Rank #${walletStats.rank} of ${burnerCount} contributors`
           : 'Not yet ranked',
@@ -146,13 +146,14 @@ router.get('/leaderboard', async (req, res) => {
     ]);
 
     res.json({
-      leaderboard: leaderboard.map(entry => ({
+      leaderboard: leaderboard.map((entry) => ({
         ...entry,
         burnedFormatted: formatAsdf(entry.totalBurned),
         walletShort: `${entry.wallet.slice(0, 4)}...${entry.wallet.slice(-4)}`,
-        contributionPercent: globalStats.burnTotal > 0
-          ? ((entry.totalBurned / globalStats.burnTotal) * 100).toFixed(2)
-          : '0.00',
+        contributionPercent:
+          globalStats.burnTotal > 0
+            ? ((entry.totalBurned / globalStats.burnTotal) * 100).toFixed(2)
+            : '0.00',
       })),
       totalBurners: burnerCount,
       totalBurned: globalStats.burnTotal,
@@ -202,7 +203,7 @@ router.get('/burns', async (req, res) => {
     const { proofs, totalCount } = await redis.getBurnProofs(limit);
 
     res.json({
-      burns: proofs.map(proof => ({
+      burns: proofs.map((proof) => ({
         ...proof,
         amountFormatted: formatAsdf(proof.amountBurned),
         solFormatted: formatSol(proof.solAmount),
diff --git a/src/routes/submit.js b/src/routes/submit.js
index d829ab0..6778e92 100644
--- a/src/routes/submit.js
+++ b/src/routes/submit.js
@@ -18,7 +18,12 @@ const { submitLimiter, walletSubmitLimiter } = require('../middleware/security')
 const { validate } = require('../middleware/validation');
 const txQueue = require('../services/tx-queue');
 const { submitsTotal, submitDuration, activeQuotes } = require('../utils/metrics');
-const { logSubmitSuccess, logSubmitRejected, logSecurityEvent, AUDIT_EVENTS } = require('../services/audit');
+const {
+  logSubmitSuccess,
+  logSubmitRejected,
+  logSecurityEvent,
+  AUDIT_EVENTS,
+} = require('../services/audit');
 const { anomalyDetector } = require('../services/anomaly-detector');
 
 const router = express.Router();
@@ -313,23 +318,30 @@ router.post('/', validate('submit'), walletSubmitLimiter, async (req, res) => {
     if (!simulation.success) {
       const isCpiAttack = simulation.securityViolation === 'CPI_DRAIN_DETECTED';
 
-      logger.warn('SUBMIT', isCpiAttack ? 'CPI drain attack detected' : 'Transaction simulation failed', {
-        requestId: req.requestId,
-        quoteId,
-        error: simulation.error,
-        securityViolation: simulation.securityViolation,
-        balanceChanges: simulation.balanceChanges,
-        logs: simulation.logs?.slice(-5),
-      });
-
-      logSecurityEvent(isCpiAttack ? AUDIT_EVENTS.CPI_ATTACK_DETECTED : AUDIT_EVENTS.SIMULATION_FAILED, {
-        quoteId,
-        error: simulation.error,
-        securityViolation: simulation.securityViolation,
-        balanceChanges: simulation.balanceChanges,
-        userPubkey,
-        ip: clientIp,
-      });
+      logger.warn(
+        'SUBMIT',
+        isCpiAttack ? 'CPI drain attack detected' : 'Transaction simulation failed',
+        {
+          requestId: req.requestId,
+          quoteId,
+          error: simulation.error,
+          securityViolation: simulation.securityViolation,
+          balanceChanges: simulation.balanceChanges,
+          logs: simulation.logs?.slice(-5),
+        }
+      );
+
+      logSecurityEvent(
+        isCpiAttack ? AUDIT_EVENTS.CPI_ATTACK_DETECTED : AUDIT_EVENTS.SIMULATION_FAILED,
+        {
+          quoteId,
+          error: simulation.error,
+          securityViolation: simulation.securityViolation,
+          balanceChanges: simulation.balanceChanges,
+          userPubkey,
+          ip: clientIp,
+        }
+      );
 
       anomalyDetector.trackWallet(userPubkey, 'failure', clientIp).catch(() => {});
 
@@ -337,7 +349,9 @@ router.post('/', validate('submit'), walletSubmitLimiter, async (req, res) => {
       releaseReservation(quoteId);
 
       return res.status(400).json({
-        error: isCpiAttack ? 'Transaction rejected: suspicious balance change detected' : 'Transaction simulation failed',
+        error: isCpiAttack
+          ? 'Transaction rejected: suspicious balance change detected'
+          : 'Transaction simulation failed',
         code: isCpiAttack ? 'CPI_ATTACK_DETECTED' : 'SIMULATION_FAILED',
         details: simulation.error,
         logs: simulation.logs?.slice(-3),
@@ -431,59 +445,62 @@ router.post('/', validate('submit'), walletSubmitLimiter, async (req, res) => {
       feeSolEquivalent: quote.feeAmountLamports,
       status: 'submitted',
       ipAddress: clientIp,
-    }).catch(err => {
+    }).catch((err) => {
       // Non-blocking: don't fail the request if DB recording fails
       logger.warn('SUBMIT', 'Failed to record transaction in PostgreSQL', { error: err.message });
     });
 
     // Verify transaction landed in background (don't block response)
     // Uses getSignatureStatus which doesn't require blockhash (avoids "block height exceeded")
-    rpc.checkSignatureStatus(result.signature, 3, 2000).then((status) => {
-      if (status.confirmed) {
-        logger.info('SUBMIT', 'Transaction confirmed', {
+    rpc
+      .checkSignatureStatus(result.signature, 3, 2000)
+      .then((status) => {
+        if (status.confirmed) {
+          logger.info('SUBMIT', 'Transaction confirmed', {
+            signature: result.signature,
+            slot: status.slot,
+            confirmationStatus: status.confirmationStatus,
+          });
+          // Update PostgreSQL status to confirmed
+          db.recordTransaction({
+            quoteId,
+            signature: result.signature,
+            userWallet: userPubkey,
+            paymentToken: quote.paymentToken || 'SOL',
+            feeAmount: quote.feeAmountLamports,
+            feeSolEquivalent: quote.feeAmountLamports,
+            status: 'confirmed',
+            ipAddress: clientIp,
+          }).catch(() => {}); // Silent fail for background update
+        } else if (status.err) {
+          logger.warn('SUBMIT', 'Transaction failed on-chain', {
+            signature: result.signature,
+            error: status.err,
+          });
+          // Update PostgreSQL status to failed
+          db.recordTransaction({
+            quoteId,
+            signature: result.signature,
+            userWallet: userPubkey,
+            paymentToken: quote.paymentToken || 'SOL',
+            feeAmount: quote.feeAmountLamports,
+            feeSolEquivalent: quote.feeAmountLamports,
+            status: 'failed',
+            ipAddress: clientIp,
+          }).catch(() => {}); // Silent fail for background update
+        } else {
+          logger.debug('SUBMIT', 'Transaction status unknown (may still be processing)', {
+            signature: result.signature,
+          });
+        }
+      })
+      .catch((err) => {
+        // Non-critical: tx was already sent successfully
+        logger.debug('SUBMIT', 'Background confirmation check failed', {
           signature: result.signature,
-          slot: status.slot,
-          confirmationStatus: status.confirmationStatus,
+          error: err.message,
         });
-        // Update PostgreSQL status to confirmed
-        db.recordTransaction({
-          quoteId,
-          signature: result.signature,
-          userWallet: userPubkey,
-          paymentToken: quote.paymentToken || 'SOL',
-          feeAmount: quote.feeAmountLamports,
-          feeSolEquivalent: quote.feeAmountLamports,
-          status: 'confirmed',
-          ipAddress: clientIp,
-        }).catch(() => {}); // Silent fail for background update
-      } else if (status.err) {
-        logger.warn('SUBMIT', 'Transaction failed on-chain', {
-          signature: result.signature,
-          error: status.err,
-        });
-        // Update PostgreSQL status to failed
-        db.recordTransaction({
-          quoteId,
-          signature: result.signature,
-          userWallet: userPubkey,
-          paymentToken: quote.paymentToken || 'SOL',
-          feeAmount: quote.feeAmountLamports,
-          feeSolEquivalent: quote.feeAmountLamports,
-          status: 'failed',
-          ipAddress: clientIp,
-        }).catch(() => {}); // Silent fail for background update
-      } else {
-        logger.debug('SUBMIT', 'Transaction status unknown (may still be processing)', {
-          signature: result.signature,
-        });
-      }
-    }).catch((err) => {
-      // Non-critical: tx was already sent successfully
-      logger.debug('SUBMIT', 'Background confirmation check failed', {
-        signature: result.signature,
-        error: err.message,
       });
-    });
 
     res.json({
       signature: result.signature,
@@ -585,7 +602,7 @@ function shouldMarkPayerUnhealthy(error) {
 }
 
 function sleep(ms) {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  return new Promise((resolve) => setTimeout(resolve, ms));
 }
 
 /**
diff --git a/src/routes/tokens.js b/src/routes/tokens.js
index ca98b5d..ab61344 100644
--- a/src/routes/tokens.js
+++ b/src/routes/tokens.js
@@ -80,7 +80,10 @@ router.get('/tiers/:wallet', async (req, res) => {
       discountPercent: tierInfo.discountPercent,
     });
   } catch (error) {
-    logger.error('TOKENS', 'Tier lookup failed', { wallet: req.params.wallet, error: error.message });
+    logger.error('TOKENS', 'Tier lookup failed', {
+      wallet: req.params.wallet,
+      error: error.message,
+    });
     res.status(500).json({ error: 'Failed to get tier info' });
   }
 });
diff --git a/src/services/alerting.js b/src/services/alerting.js
index a8919b3..9bfc3ae 100644
--- a/src/services/alerting.js
+++ b/src/services/alerting.js
@@ -4,8 +4,8 @@ const { fetchWithTimeout, WEBHOOK_TIMEOUT } = require('../utils/fetch-timeout');
 
 // Webhook retry configuration
 const WEBHOOK_MAX_RETRIES = 3;
-const WEBHOOK_INITIAL_DELAY_MS = 1000;  // 1 second
-const WEBHOOK_MAX_DELAY_MS = 10000;     // 10 seconds
+const WEBHOOK_INITIAL_DELAY_MS = 1000; // 1 second
+const WEBHOOK_MAX_DELAY_MS = 10000; // 10 seconds
 
 // =============================================================================
 // Alert Definitions
@@ -172,8 +172,12 @@ class AlertingService {
     }
 
     // Log the alert
-    const logMethod = alertDef.severity === SEVERITY.CRITICAL ? 'error' :
-                      alertDef.severity === SEVERITY.WARNING ? 'warn' : 'info';
+    const logMethod =
+      alertDef.severity === SEVERITY.CRITICAL
+        ? 'error'
+        : alertDef.severity === SEVERITY.WARNING
+          ? 'warn'
+          : 'info';
     logger[logMethod]('ALERT', alert.message, {
       alertId,
       severity: alert.severity,
@@ -268,7 +272,7 @@ class AlertingService {
           nextRetryMs: delay,
           error: lastError?.message,
         });
-        await new Promise(resolve => setTimeout(resolve, delay));
+        await new Promise((resolve) => setTimeout(resolve, delay));
       }
     }
 
@@ -302,40 +306,52 @@ class AlertingService {
   }
 
   formatSlack(alert) {
-    const color = alert.severity === SEVERITY.CRITICAL ? '#dc3545' :
-                  alert.severity === SEVERITY.WARNING ? '#ffc107' : '#28a745';
+    const color =
+      alert.severity === SEVERITY.CRITICAL
+        ? '#dc3545'
+        : alert.severity === SEVERITY.WARNING
+          ? '#ffc107'
+          : '#28a745';
 
     return {
-      attachments: [{
-        color,
-        title: `[${alert.severity.toUpperCase()}] ${alert.title}`,
-        text: alert.message,
-        fields: [
-          { title: 'Environment', value: alert.environment, short: true },
-          { title: 'Network', value: alert.network, short: true },
-        ],
-        footer: 'GASdf Alerting',
-        ts: Math.floor(alert.timestamp / 1000),
-      }],
+      attachments: [
+        {
+          color,
+          title: `[${alert.severity.toUpperCase()}] ${alert.title}`,
+          text: alert.message,
+          fields: [
+            { title: 'Environment', value: alert.environment, short: true },
+            { title: 'Network', value: alert.network, short: true },
+          ],
+          footer: 'GASdf Alerting',
+          ts: Math.floor(alert.timestamp / 1000),
+        },
+      ],
     };
   }
 
   formatDiscord(alert) {
-    const color = alert.severity === SEVERITY.CRITICAL ? 0xdc3545 :
-                  alert.severity === SEVERITY.WARNING ? 0xffc107 : 0x28a745;
+    const color =
+      alert.severity === SEVERITY.CRITICAL
+        ? 0xdc3545
+        : alert.severity === SEVERITY.WARNING
+          ? 0xffc107
+          : 0x28a745;
 
     return {
-      embeds: [{
-        title: `[${alert.severity.toUpperCase()}] ${alert.title}`,
-        description: alert.message,
-        color,
-        fields: [
-          { name: 'Environment', value: alert.environment, inline: true },
-          { name: 'Network', value: alert.network, inline: true },
-        ],
-        footer: { text: 'GASdf Alerting' },
-        timestamp: new Date(alert.timestamp).toISOString(),
-      }],
+      embeds: [
+        {
+          title: `[${alert.severity.toUpperCase()}] ${alert.title}`,
+          description: alert.message,
+          color,
+          fields: [
+            { name: 'Environment', value: alert.environment, inline: true },
+            { name: 'Network', value: alert.network, inline: true },
+          ],
+          footer: { text: 'GASdf Alerting' },
+          timestamp: new Date(alert.timestamp).toISOString(),
+        },
+      ],
     };
   }
 
@@ -484,7 +500,9 @@ function checkFeePayerPoolCircuitBreaker() {
       alertingService.recover('CIRCUIT_BREAKER_OPEN', { name: 'fee_payer_pool' });
     }
   } catch (error) {
-    logger.error('ALERTING', 'Failed to check fee payer pool circuit breaker', { error: error.message });
+    logger.error('ALERTING', 'Failed to check fee payer pool circuit breaker', {
+      error: error.message,
+    });
   }
 }
 
diff --git a/src/services/anomaly-detector.js b/src/services/anomaly-detector.js
index e934761..a69e52b 100644
--- a/src/services/anomaly-detector.js
+++ b/src/services/anomaly-detector.js
@@ -94,7 +94,7 @@ class AnomalyDetector {
   _stddev(arr) {
     if (arr.length < 2) return 0;
     const mean = this._mean(arr);
-    const squaredDiffs = arr.map(x => Math.pow(x - mean, 2));
+    const squaredDiffs = arr.map((x) => Math.pow(x - mean, 2));
     return Math.sqrt(this._mean(squaredDiffs));
   }
 
@@ -109,7 +109,7 @@ class AnomalyDetector {
 
     const mean = this._mean(samples);
     const stddev = this._stddev(samples);
-    let threshold = mean + (stddev * BASELINE_CONFIG.STDDEV_MULTIPLIER);
+    let threshold = mean + stddev * BASELINE_CONFIG.STDDEV_MULTIPLIER;
 
     // Apply minimum floor if specified (prevents threshold from being too low)
     if (minFloor !== null) {
@@ -208,9 +208,7 @@ class AnomalyDetector {
     this.baseline.lastUpdateAt = Date.now();
 
     logger.info('ANOMALY', 'Thresholds updated from baseline', {
-      sampleCounts: Object.fromEntries(
-        Object.entries(s).map(([k, v]) => [k, v.length])
-      ),
+      sampleCounts: Object.fromEntries(Object.entries(s).map(([k, v]) => [k, v.length])),
       newThresholds: this.baseline.thresholds,
     });
   }
@@ -250,7 +248,9 @@ class AnomalyDetector {
       isLearning: this.baseline.isLearning,
       isReady: this.baseline.isReady,
       startedAt: this.baseline.startedAt ? new Date(this.baseline.startedAt).toISOString() : null,
-      lastUpdateAt: this.baseline.lastUpdateAt ? new Date(this.baseline.lastUpdateAt).toISOString() : null,
+      lastUpdateAt: this.baseline.lastUpdateAt
+        ? new Date(this.baseline.lastUpdateAt).toISOString()
+        : null,
       sampleCounts: Object.fromEntries(
         Object.entries(this.baseline.samples).map(([k, v]) => [k, v.length])
       ),
@@ -269,7 +269,7 @@ class AnomalyDetector {
     this.startBaselineLearning();
 
     this.checkInterval = setInterval(() => {
-      this.runChecks().catch(err => {
+      this.runChecks().catch((err) => {
         logger.error('ANOMALY', 'Check failed', { error: err.message });
       });
     }, intervalMs);
@@ -335,11 +335,12 @@ class AnomalyDetector {
     // Check error rate
     const allCounts = auditService.getAllEventCounts(5);
     const successCount = allCounts[AUDIT_EVENTS.SUBMIT_SUCCESS] || 0;
-    const failureCount = (allCounts[AUDIT_EVENTS.SUBMIT_FAILED] || 0) +
-                         (allCounts[AUDIT_EVENTS.SUBMIT_REJECTED] || 0);
+    const failureCount =
+      (allCounts[AUDIT_EVENTS.SUBMIT_FAILED] || 0) + (allCounts[AUDIT_EVENTS.SUBMIT_REJECTED] || 0);
     const totalSubmits = successCount + failureCount;
 
-    if (totalSubmits > 10) { // Need minimum sample size
+    if (totalSubmits > 10) {
+      // Need minimum sample size
       const errorRate = (failureCount / totalSubmits) * 100;
 
       // Record sample for baseline learning
@@ -375,7 +376,7 @@ class AnomalyDetector {
 
         // Keep only last 5 minutes of history
         const cutoff = now - 5 * 60 * 1000;
-        const recentHistory = history.filter(h => h.timestamp >= cutoff);
+        const recentHistory = history.filter((h) => h.timestamp >= cutoff);
         this.payerBalanceHistory.set(payer.pubkey, recentHistory);
 
         // Check drain rate if we have enough history
diff --git a/src/services/audit.js b/src/services/audit.js
index 0aeb063..1235a20 100644
--- a/src/services/audit.js
+++ b/src/services/audit.js
@@ -21,11 +21,7 @@ const PII_SALT = process.env.AUDIT_PII_SALT || 'gasdf-audit-salt-v1';
 function hashPII(data, prefix = '') {
   if (!data) return null;
 
-  const hash = crypto
-    .createHmac('sha256', PII_SALT)
-    .update(data)
-    .digest('hex')
-    .slice(0, 16);
+  const hash = crypto.createHmac('sha256', PII_SALT).update(data).digest('hex').slice(0, 16);
 
   return prefix ? `${prefix}${hash}` : hash;
 }
@@ -122,7 +118,7 @@ class AuditService {
     if (this.flushInterval) return;
 
     this.flushInterval = setInterval(() => {
-      this.flush().catch(err => {
+      this.flush().catch((err) => {
         logger.error('AUDIT', 'Failed to flush audit buffer', { error: err.message });
       });
     }, FLUSH_INTERVAL_MS);
@@ -333,7 +329,8 @@ function logSecurityEvent(eventType, data) {
 }
 
 function logRateLimited(type, data) {
-  const eventType = type === 'wallet' ? AUDIT_EVENTS.WALLET_RATE_LIMITED : AUDIT_EVENTS.IP_RATE_LIMITED;
+  const eventType =
+    type === 'wallet' ? AUDIT_EVENTS.WALLET_RATE_LIMITED : AUDIT_EVENTS.IP_RATE_LIMITED;
   return auditService.log(eventType, {
     wallet: anonymizeWallet(data.wallet),
     ip: anonymizeIP(data.ip),
diff --git a/src/services/burn.js b/src/services/burn.js
index 496e832..27ab641 100644
--- a/src/services/burn.js
+++ b/src/services/burn.js
@@ -1,7 +1,4 @@
-const {
-  PublicKey,
-  Transaction,
-} = require('@solana/web3.js');
+const { PublicKey, Transaction } = require('@solana/web3.js');
 const {
   createBurnInstruction,
   getAssociatedTokenAddress,
@@ -46,7 +43,7 @@ const BURN_LOCK_TTL = 120; // 2 minutes max for burn operation
 //
 // This maximizes $ASDF deflation while keeping unified model for other tokens
 // TX costs: ~0.000005 SOL (~$0.001) per transaction
-const MIN_VALUE_USD = 0.50;
+const MIN_VALUE_USD = 0.5;
 
 // =============================================================================
 // VELOCITY-BASED REFILL (Behavioral Proof > Fixed Thresholds)
@@ -121,8 +118,11 @@ async function getTokenValueUsd(mint, amount, decimals) {
     }
 
     // For USDC/USDT, value is direct (1:1 with USD)
-    if (mint === 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' || // USDC
-        mint === 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB') {  // USDT
+    if (
+      mint === 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' || // USDC
+      mint === 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB'
+    ) {
+      // USDT
       return amount / Math.pow(10, decimals);
     }
 
@@ -133,7 +133,12 @@ async function getTokenValueUsd(mint, amount, decimals) {
     }
 
     // For other tokens, get quote to USDC
-    const quote = await jupiter.getQuote(mint, 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', amount, 100);
+    const quote = await jupiter.getQuote(
+      mint,
+      'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
+      amount,
+      100
+    );
     return parseInt(quote.outAmount) / 1_000_000;
   } catch (error) {
     logger.debug('BURN', 'Failed to get token value, estimating via SOL', {
@@ -176,9 +181,7 @@ async function checkFeePayerNeedsRefill() {
     const bufferCalc = await redis.calculateVelocityBasedBuffer(BUFFER_HOURS, MIN_BUFFER_LAMPORTS);
 
     const needsRefill = balance < bufferCalc.required;
-    const refillAmount = needsRefill
-      ? bufferCalc.target - balance
-      : 0;
+    const refillAmount = needsRefill ? bufferCalc.target - balance : 0;
 
     logger.debug('BURN', 'Fee payer balance check (velocity-based)', {
       balance: balanceSol.toFixed(4),
@@ -343,10 +346,9 @@ async function getTreasuryTokenBalances() {
     const connection = rpc.getConnection();
 
     // Get all token accounts owned by treasury
-    const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
-      treasury,
-      { programId: TOKEN_PROGRAM_ID }
-    );
+    const tokenAccounts = await connection.getParsedTokenAccountsByOwner(treasury, {
+      programId: TOKEN_PROGRAM_ID,
+    });
 
     const balances = [];
     for (const { account, pubkey } of tokenAccounts.value) {
@@ -415,7 +417,7 @@ async function checkAndExecuteBurn() {
   if (refillCheck?.needsRefill) {
     logger.info('BURN', 'Fee payer needs refill, swapping $ASDF  SOL', {
       currentBalance: refillCheck.balanceSol.toFixed(4),
-      threshold: FEE_PAYER_REFILL_THRESHOLD_SOL,
+      threshold: LEGACY_REFILL_THRESHOLD_SOL,
     });
     await refillFeePayerFromAsdf();
   }
@@ -430,16 +432,20 @@ async function checkAndExecuteBurn() {
   // ==========================================================================
   // RACE CONDITION FIX: Distributed lock prevents concurrent burn executions
   // ==========================================================================
-  const lockResult = await redis.withLock(BURN_LOCK_NAME, async () => {
-    // Re-check balances after acquiring lock (double-check pattern)
-    const confirmedBalances = await getTreasuryTokenBalances();
-    if (confirmedBalances.length === 0) {
-      logger.debug('BURN', 'No token balances after lock acquired');
-      return null;
-    }
+  const lockResult = await redis.withLock(
+    BURN_LOCK_NAME,
+    async () => {
+      // Re-check balances after acquiring lock (double-check pattern)
+      const confirmedBalances = await getTreasuryTokenBalances();
+      if (confirmedBalances.length === 0) {
+        logger.debug('BURN', 'No token balances after lock acquired');
+        return null;
+      }
 
-    return executeBurnWithLock(confirmedBalances);
-  }, BURN_LOCK_TTL);
+      return executeBurnWithLock(confirmedBalances);
+    },
+    BURN_LOCK_TTL
+  );
 
   if (!lockResult.success) {
     if (lockResult.error === 'LOCK_HELD') {
@@ -500,7 +506,7 @@ async function executeBurnWithLock(tokenBalances) {
   if (pendingBurns.length > 0) {
     logger.info('BURN', 'Executing batched burns', {
       burnCount: pendingBurns.length,
-      tokens: pendingBurns.map(b => b.mint.slice(0, 8)),
+      tokens: pendingBurns.map((b) => b.mint.slice(0, 8)),
     });
 
     try {
@@ -510,7 +516,7 @@ async function executeBurnWithLock(tokenBalances) {
       if (batchResult.signature) {
         // Update burn stats
         const totalAsdfBurned = pendingBurns
-          .filter(b => b.type === 'asdf')
+          .filter((b) => b.type === 'asdf')
           .reduce((sum, b) => sum + b.amount, 0);
 
         if (totalAsdfBurned > 0) {
@@ -523,7 +529,7 @@ async function executeBurnWithLock(tokenBalances) {
           amountBurned: totalAsdfBurned,
           method: 'batch',
           burnCount: batchResult.burns,
-          tokens: pendingBurns.map(b => ({
+          tokens: pendingBurns.map((b) => ({
             mint: b.mint,
             amount: b.amount,
             type: b.type,
@@ -596,8 +602,8 @@ async function processTokenForBatch(token, pendingBurns) {
   // Default: Golden Ratio split (no ecosystem burn bonus for unverified tokens)
   let ecosystemBurnBonus = {
     ecosystemBurnPct: 0,
-    asdfBurnPct: config.BURN_RATIO,      // 76.4% (1 - 1/)
-    treasuryPct: config.TREASURY_RATIO,  // 23.6% (1/)
+    asdfBurnPct: config.BURN_RATIO, // 76.4% (1 - 1/)
+    treasuryPct: config.TREASURY_RATIO, // 23.6% (1/)
   };
   let tokenBurnedPercent = 0;
 
@@ -642,7 +648,6 @@ async function processTokenForBatch(token, pendingBurns) {
         model: 'purist',
       });
     }
-
   } else {
     // ==========================================================================
     // UNIFIED $ASDF MODEL: Everything flows through $ASDF
@@ -679,7 +684,10 @@ async function processTokenForBatch(token, pendingBurns) {
         swapSignatures.push(swapResult.signature);
 
         // Split received $ASDF using Golden Ratio
-        const { burnAmount, treasuryAmount } = calculateTreasurySplit(asdfReceived, config.BURN_RATIO);
+        const { burnAmount, treasuryAmount } = calculateTreasurySplit(
+          asdfReceived,
+          config.BURN_RATIO
+        );
 
         // 2a. Queue 76.4% for burn
         if (burnAmount > 0) {
@@ -719,9 +727,10 @@ async function processTokenForBatch(token, pendingBurns) {
     asdfBurned,
     ecosystemBurned,
     tokenBurnedPercent: tokenBurnedPercent > 0 ? tokenBurnedPercent.toFixed(1) + '%' : null,
-    ecosystemBurnBonus: ecosystemBurnBonus.ecosystemBurnPct > 0
-      ? (ecosystemBurnBonus.ecosystemBurnPct * 100).toFixed(1) + '%'
-      : null,
+    ecosystemBurnBonus:
+      ecosystemBurnBonus.ecosystemBurnPct > 0
+        ? (ecosystemBurnBonus.ecosystemBurnPct * 100).toFixed(1) + '%'
+        : null,
     swapsUsed: swapSignatures.length,
     pendingBurnsTotal: pendingBurns.length,
     model: isAsdf ? '100% burn' : 'unified (76.4% burn)',
@@ -732,9 +741,10 @@ async function processTokenForBatch(token, pendingBurns) {
     symbol,
     asdfBurned,
     ecosystemBurned,
-    asdfRetained: !isAsdf && asdfBurned > 0
-      ? Math.floor(asdfBurned * (1 - config.BURN_RATIO) / config.BURN_RATIO)
-      : 0,
+    asdfRetained:
+      !isAsdf && asdfBurned > 0
+        ? Math.floor((asdfBurned * (1 - config.BURN_RATIO)) / config.BURN_RATIO)
+        : 0,
     swapSignatures,
     swapsUsed: swapSignatures.length,
     batched: true,
@@ -866,7 +876,9 @@ async function swapTokenToSol(tokenMint, amount, feePayer) {
       }
 
       // Jito failed, fall back to regular RPC
-      logger.warn('BURN', 'Jito failed for SOL swap, falling back to RPC', { error: jitoResult.error });
+      logger.warn('BURN', 'Jito failed for SOL swap, falling back to RPC', {
+        error: jitoResult.error,
+      });
     }
 
     // Standard RPC submission (fallback or non-mainnet)
@@ -898,18 +910,10 @@ async function burnAsdf(amount) {
   const asdfMint = getAsdfMint();
 
   // Get fee payer's ASDF token account
-  const tokenAccount = await getAssociatedTokenAddress(
-    asdfMint,
-    feePayer.publicKey
-  );
+  const tokenAccount = await getAssociatedTokenAddress(asdfMint, feePayer.publicKey);
 
   // Create burn instruction
-  const burnIx = createBurnInstruction(
-    tokenAccount,
-    asdfMint,
-    feePayer.publicKey,
-    amount
-  );
+  const burnIx = createBurnInstruction(tokenAccount, asdfMint, feePayer.publicKey, amount);
 
   // Build and send transaction
   const { blockhash, lastValidBlockHeight } = await rpc.getLatestBlockhash();
@@ -963,12 +967,7 @@ async function batchBurnFromTreasury(burns) {
       const tokenMint = new PublicKey(burn.mint);
       const treasuryAta = await getAssociatedTokenAddress(tokenMint, treasury);
 
-      const burnIx = createBurnInstruction(
-        treasuryAta,
-        tokenMint,
-        treasury,
-        burn.amount
-      );
+      const burnIx = createBurnInstruction(treasuryAta, tokenMint, treasury, burn.amount);
 
       transaction.add(burnIx);
       burnCount++;
@@ -1014,10 +1013,7 @@ async function burnAsdfFromTreasury(amount) {
   const asdfMint = getAsdfMint();
 
   // Get treasury's ASDF token account
-  const treasuryAta = await getAssociatedTokenAddress(
-    asdfMint,
-    treasury
-  );
+  const treasuryAta = await getAssociatedTokenAddress(asdfMint, treasury);
 
   // Check if fee payer is the treasury (can burn directly)
   const feePayerIsTreasury = feePayer.publicKey.equals(treasury);
@@ -1034,12 +1030,7 @@ async function burnAsdfFromTreasury(amount) {
   }
 
   // Create burn instruction (treasury is fee payer, so we have authority)
-  const burnIx = createBurnInstruction(
-    treasuryAta,
-    asdfMint,
-    treasury,
-    amount
-  );
+  const burnIx = createBurnInstruction(treasuryAta, asdfMint, treasury, amount);
 
   // Build and send transaction
   const { blockhash, lastValidBlockHeight } = await rpc.getLatestBlockhash();
@@ -1072,10 +1063,7 @@ async function burnTokenFromTreasury(mint, amount, feePayer) {
   const tokenMint = new PublicKey(mint);
 
   // Get treasury's token account for this mint
-  const treasuryAta = await getAssociatedTokenAddress(
-    tokenMint,
-    treasury
-  );
+  const treasuryAta = await getAssociatedTokenAddress(tokenMint, treasury);
 
   // Verify the token account exists and has sufficient balance
   try {
@@ -1099,12 +1087,7 @@ async function burnTokenFromTreasury(mint, amount, feePayer) {
   }
 
   // Create burn instruction (treasury is fee payer, so we have authority)
-  const burnIx = createBurnInstruction(
-    treasuryAta,
-    tokenMint,
-    treasury,
-    amount
-  );
+  const burnIx = createBurnInstruction(treasuryAta, tokenMint, treasury, amount);
 
   // Build and send transaction
   const { blockhash, lastValidBlockHeight } = await rpc.getLatestBlockhash();
diff --git a/src/services/fee-payer-pool.js b/src/services/fee-payer-pool.js
index f795431..93b4a66 100644
--- a/src/services/fee-payer-pool.js
+++ b/src/services/fee-payer-pool.js
@@ -36,9 +36,9 @@ const RESERVATION_TTL_MS = 90_000; // 90 seconds
 
 // Key rotation states
 const KEY_STATUS = {
-  ACTIVE: 'active',       // Normal operation, accepts new quotes
-  RETIRING: 'retiring',   // No new quotes, still processes existing reservations
-  RETIRED: 'retired',     // Fully deprecated, should not be used
+  ACTIVE: 'active', // Normal operation, accepts new quotes
+  RETIRING: 'retiring', // No new quotes, still processes existing reservations
+  RETIRED: 'retired', // Fully deprecated, should not be used
 };
 
 class FeePayerPool {
@@ -140,12 +140,12 @@ class FeePayerPool {
     this.initialized = true;
 
     // Initial balance refresh
-    this.refreshBalances().catch(err => {
+    this.refreshBalances().catch((err) => {
       logger.warn('FEE_PAYER_POOL', 'Initial balance refresh failed', { error: err.message });
     });
 
     // SECURITY: Verify fee payers have no token accounts (critical invariant)
-    this.verifyNoTokenAccounts().catch(err => {
+    this.verifyNoTokenAccounts().catch((err) => {
       logger.error('FEE_PAYER_POOL', 'Security check failed', { error: err.message });
     });
   }
@@ -169,13 +169,12 @@ class FeePayerPool {
 
       try {
         const connection = rpc.getConnection();
-        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
-          pubkey,
-          { programId: TOKEN_PROGRAM_ID }
-        );
+        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(pubkey, {
+          programId: TOKEN_PROGRAM_ID,
+        });
 
         if (tokenAccounts.value.length > 0) {
-          const accounts = tokenAccounts.value.map(acc => ({
+          const accounts = tokenAccounts.value.map((acc) => ({
             mint: acc.account.data.parsed.info.mint.slice(0, 8),
             balance: acc.account.data.parsed.info.tokenAmount.uiAmountString,
           }));
@@ -229,7 +228,7 @@ class FeePayerPool {
 
     try {
       // Batch fetch all balances in a single RPC call
-      const pubkeys = this.payers.map(p => p.publicKey);
+      const pubkeys = this.payers.map((p) => p.publicKey);
       const balanceMap = await rpc.getMultipleBalances(pubkeys);
 
       // Update balances and check health status
@@ -242,7 +241,10 @@ class FeePayerPool {
         // Auto-heal if balance is now healthy
         if (balance >= MIN_HEALTHY_BALANCE && this.unhealthyUntil.has(pubkey)) {
           this.unhealthyUntil.delete(pubkey);
-          logger.info('FEE_PAYER_POOL', `Payer ${pubkey.slice(0, 8)}... recovered (balance: ${balance / 1e9} SOL)`);
+          logger.info(
+            'FEE_PAYER_POOL',
+            `Payer ${pubkey.slice(0, 8)}... recovered (balance: ${balance / 1e9} SOL)`
+          );
         }
       }
 
@@ -322,7 +324,7 @@ class FeePayerPool {
    */
   getPayerByPubkey(pubkey) {
     this.initialize();
-    return this.payers.find(p => p.publicKey.toBase58() === pubkey);
+    return this.payers.find((p) => p.publicKey.toBase58() === pubkey);
   }
 
   /**
@@ -330,7 +332,10 @@ class FeePayerPool {
    */
   markUnhealthy(pubkey, durationMs = 60_000) {
     this.unhealthyUntil.set(pubkey, Date.now() + durationMs);
-    logger.warn('FEE_PAYER_POOL', `Marked ${pubkey.slice(0, 8)}... as unhealthy for ${durationMs / 1000}s`);
+    logger.warn(
+      'FEE_PAYER_POOL',
+      `Marked ${pubkey.slice(0, 8)}... as unhealthy for ${durationMs / 1000}s`
+    );
   }
 
   /**
@@ -338,7 +343,7 @@ class FeePayerPool {
    */
   getAllPublicKeys() {
     this.initialize();
-    return this.payers.map(p => p.publicKey);
+    return this.payers.map((p) => p.publicKey);
   }
 
   /**
@@ -357,8 +362,8 @@ class FeePayerPool {
         balance,
         balanceSol: balance / 1e9,
         isHealthy: this.isPayerHealthy(pubkey),
-        status: balance < MIN_HEALTHY_BALANCE ? 'critical' :
-                balance < WARNING_BALANCE ? 'warning' : 'ok',
+        status:
+          balance < MIN_HEALTHY_BALANCE ? 'critical' : balance < WARNING_BALANCE ? 'warning' : 'ok',
       });
     }
     return result;
@@ -469,14 +474,21 @@ class FeePayerPool {
     const existingStatus = this.getKeyStatus(pubkey);
 
     if (existingStatus.status !== KEY_STATUS.RETIRING) {
-      logger.warn('FEE_PAYER_POOL', `Cannot complete retirement for non-retiring key: ${pubkey.slice(0, 8)}...`);
+      logger.warn(
+        'FEE_PAYER_POOL',
+        `Cannot complete retirement for non-retiring key: ${pubkey.slice(0, 8)}...`
+      );
       return false;
     }
 
     // Check if there are pending reservations
     const pendingReservations = this.reservationsByPayer.get(pubkey)?.size || 0;
     if (pendingReservations > 0) {
-      logger.warn('FEE_PAYER_POOL', `Cannot complete retirement: ${pendingReservations} pending reservations`, { pubkey: pubkey.slice(0, 8) });
+      logger.warn(
+        'FEE_PAYER_POOL',
+        `Cannot complete retirement: ${pendingReservations} pending reservations`,
+        { pubkey: pubkey.slice(0, 8) }
+      );
       return false;
     }
 
@@ -511,10 +523,14 @@ class FeePayerPool {
       for (const quoteId of [...quoteIds]) {
         this.releaseReservation(quoteId);
       }
-      logger.error('FEE_PAYER_POOL', `Emergency retirement: cancelled ${cancelled} reservations`, { pubkey: pubkey.slice(0, 8) });
+      logger.error('FEE_PAYER_POOL', `Emergency retirement: cancelled ${cancelled} reservations`, {
+        pubkey: pubkey.slice(0, 8),
+      });
     }
 
-    logger.error('FEE_PAYER_POOL', `EMERGENCY key retirement for ${pubkey.slice(0, 8)}...`, { reason });
+    logger.error('FEE_PAYER_POOL', `EMERGENCY key retirement for ${pubkey.slice(0, 8)}...`, {
+      reason,
+    });
 
     // Log to audit
     try {
@@ -538,7 +554,10 @@ class FeePayerPool {
     }
 
     if (existingStatus.forced) {
-      logger.error('FEE_PAYER_POOL', `Cannot reactivate emergency-retired key: ${pubkey.slice(0, 8)}...`);
+      logger.error(
+        'FEE_PAYER_POOL',
+        `Cannot reactivate emergency-retired key: ${pubkey.slice(0, 8)}...`
+      );
       return false;
     }
 
@@ -566,7 +585,9 @@ class FeePayerPool {
         canAcceptQuotes: this.canAcceptNewQuotes(pubkey),
         canProcessReservations: this.canProcessReservations(pubkey),
         pendingReservations,
-        ...(keyInfo.retirementStartedAt && { retirementStartedAt: new Date(keyInfo.retirementStartedAt).toISOString() }),
+        ...(keyInfo.retirementStartedAt && {
+          retirementStartedAt: new Date(keyInfo.retirementStartedAt).toISOString(),
+        }),
         ...(keyInfo.retiredAt && { retiredAt: new Date(keyInfo.retiredAt).toISOString() }),
         ...(keyInfo.reason && { reason: keyInfo.reason }),
       });
@@ -649,81 +670,88 @@ class FeePayerPool {
     // Lock name is per-pool to prevent all reservations from blocking each other
     // Lock TTL is short (5s) to prevent deadlocks while allowing for retries
     // ==========================================================================
-    const lockResult = await redis.withLock('fee-payer-reservation', async () => {
-      // Cleanup expired reservations inside lock
-      await this._cleanupExpiredReservationsDistributed();
+    const lockResult = await redis.withLock(
+      'fee-payer-reservation',
+      async () => {
+        // Cleanup expired reservations inside lock
+        await this._cleanupExpiredReservationsDistributed();
+
+        // Check circuit breaker
+        if (this.isCircuitOpen()) {
+          logger.warn('FEE_PAYER_POOL', 'Circuit breaker open, rejecting reservation', { quoteId });
+          return null;
+        }
 
-      // Check circuit breaker
-      if (this.isCircuitOpen()) {
-        logger.warn('FEE_PAYER_POOL', 'Circuit breaker open, rejecting reservation', { quoteId });
-        return null;
-      }
+        // Find a payer with capacity
+        for (let i = 0; i < this.payers.length; i++) {
+          const index = (this.currentIndex + i) % this.payers.length;
+          const payer = this.payers[index];
+          const pubkey = payer.publicKey.toBase58();
 
-      // Find a payer with capacity
-      for (let i = 0; i < this.payers.length; i++) {
-        const index = (this.currentIndex + i) % this.payers.length;
-        const payer = this.payers[index];
-        const pubkey = payer.publicKey.toBase58();
+          // Skip unhealthy payers
+          if (!this.isPayerHealthy(pubkey)) continue;
 
-        // Skip unhealthy payers
-        if (!this.isPayerHealthy(pubkey)) continue;
+          // Check reservation count limit (from Redis in multi-instance mode)
+          const reservationCount = await this._getReservationCountDistributed(pubkey);
+          if (reservationCount >= MAX_RESERVATIONS_PER_PAYER) {
+            logger.debug('FEE_PAYER_POOL', `Payer ${pubkey.slice(0, 8)}... at max reservations`);
+            continue;
+          }
 
-        // Check reservation count limit (from Redis in multi-instance mode)
-        const reservationCount = await this._getReservationCountDistributed(pubkey);
-        if (reservationCount >= MAX_RESERVATIONS_PER_PAYER) {
-          logger.debug('FEE_PAYER_POOL', `Payer ${pubkey.slice(0, 8)}... at max reservations`);
-          continue;
-        }
+          // Check available balance (from Redis in multi-instance mode)
+          const availableBalance = await this._getAvailableBalanceDistributed(pubkey);
+          if (availableBalance < amountLamports + MIN_HEALTHY_BALANCE) {
+            logger.debug(
+              'FEE_PAYER_POOL',
+              `Payer ${pubkey.slice(0, 8)}... insufficient available balance`
+            );
+            continue;
+          }
 
-        // Check available balance (from Redis in multi-instance mode)
-        const availableBalance = await this._getAvailableBalanceDistributed(pubkey);
-        if (availableBalance < amountLamports + MIN_HEALTHY_BALANCE) {
-          logger.debug('FEE_PAYER_POOL', `Payer ${pubkey.slice(0, 8)}... insufficient available balance`);
-          continue;
-        }
+          // Create reservation in Redis (shared across instances)
+          const reservation = {
+            pubkey,
+            amount: amountLamports,
+            expiresAt: Date.now() + RESERVATION_TTL_MS,
+            createdAt: Date.now(),
+          };
 
-        // Create reservation in Redis (shared across instances)
-        const reservation = {
-          pubkey,
-          amount: amountLamports,
-          expiresAt: Date.now() + RESERVATION_TTL_MS,
-          createdAt: Date.now(),
-        };
+          await this._setReservationDistributed(quoteId, reservation);
 
-        await this._setReservationDistributed(quoteId, reservation);
+          // Also keep in-memory for fast lookups
+          this.reservations.set(quoteId, reservation);
+          if (!this.reservationsByPayer.has(pubkey)) {
+            this.reservationsByPayer.set(pubkey, new Set());
+          }
+          this.reservationsByPayer.get(pubkey).add(quoteId);
 
-        // Also keep in-memory for fast lookups
-        this.reservations.set(quoteId, reservation);
-        if (!this.reservationsByPayer.has(pubkey)) {
-          this.reservationsByPayer.set(pubkey, new Set());
-        }
-        this.reservationsByPayer.get(pubkey).add(quoteId);
+          // Move to next payer for round-robin
+          this.currentIndex = (index + 1) % this.payers.length;
 
-        // Move to next payer for round-robin
-        this.currentIndex = (index + 1) % this.payers.length;
+          logger.debug('FEE_PAYER_POOL', 'Reserved balance (distributed)', {
+            quoteId,
+            pubkey: pubkey.slice(0, 8),
+            amount: amountLamports,
+            availableAfter: availableBalance - amountLamports,
+          });
+
+          // Reset consecutive failures on successful reservation
+          this.consecutiveFailures = 0;
+
+          return pubkey;
+        }
 
-        logger.debug('FEE_PAYER_POOL', 'Reserved balance (distributed)', {
+        // No payer available - record failure
+        this.recordFailure();
+        logger.error('FEE_PAYER_POOL', 'No payer available for reservation', {
           quoteId,
-          pubkey: pubkey.slice(0, 8),
           amount: amountLamports,
-          availableAfter: availableBalance - amountLamports,
         });
 
-        // Reset consecutive failures on successful reservation
-        this.consecutiveFailures = 0;
-
-        return pubkey;
-      }
-
-      // No payer available - record failure
-      this.recordFailure();
-      logger.error('FEE_PAYER_POOL', 'No payer available for reservation', {
-        quoteId,
-        amount: amountLamports,
-      });
-
-      return null;
-    }, 5); // 5 second lock TTL
+        return null;
+      },
+      5
+    ); // 5 second lock TTL
 
     // Handle lock acquisition failure
     if (!lockResult.success) {
@@ -988,7 +1016,7 @@ function isTransactionSignedByFeePayer(transaction) {
   pool.initialize();
 
   // Get all valid fee payer pubkeys
-  const validPubkeys = new Set(pool.payers.map(p => p.publicKey.toBase58()));
+  const validPubkeys = new Set(pool.payers.map((p) => p.publicKey.toBase58()));
 
   if (transaction instanceof VersionedTransaction) {
     const signerKeys = transaction.message.staticAccountKeys;
@@ -1012,8 +1040,8 @@ function isTransactionSignedByFeePayer(transaction) {
       return false;
     }
 
-    const feePayerSig = transaction.signatures.find(
-      (sig) => validPubkeys.has(sig.publicKey.toBase58())
+    const feePayerSig = transaction.signatures.find((sig) =>
+      validPubkeys.has(sig.publicKey.toBase58())
     );
     return feePayerSig?.signature !== null;
   }
@@ -1024,7 +1052,7 @@ function isTransactionSignedByFeePayer(transaction) {
  */
 function getTransactionFeePayer(transaction) {
   pool.initialize();
-  const validPubkeys = new Set(pool.payers.map(p => p.publicKey.toBase58()));
+  const validPubkeys = new Set(pool.payers.map((p) => p.publicKey.toBase58()));
 
   if (transaction instanceof VersionedTransaction) {
     const signerKeys = transaction.message.staticAccountKeys;
diff --git a/src/services/holdex.js b/src/services/holdex.js
index f3f5996..c0071aa 100644
--- a/src/services/holdex.js
+++ b/src/services/holdex.js
@@ -84,7 +84,16 @@ const HOLDEX_TIMEOUT = 5000; // 5 seconds
 const ACCEPTED_TIERS = new Set(['Diamond', 'Platinum', 'Gold', 'Silver', 'Bronze']);
 
 // All valid tier names
-const VALID_TIERS = new Set(['Diamond', 'Platinum', 'Gold', 'Silver', 'Bronze', 'Copper', 'Iron', 'Rust']);
+const VALID_TIERS = new Set([
+  'Diamond',
+  'Platinum',
+  'Gold',
+  'Silver',
+  'Bronze',
+  'Copper',
+  'Iron',
+  'Rust',
+]);
 
 /**
  * Get metal rank info from K-score
@@ -93,14 +102,14 @@ const VALID_TIERS = new Set(['Diamond', 'Platinum', 'Gold', 'Silver', 'Bronze',
  * @returns {{tier: string, icon: string, level: number}}
  */
 function getKRank(score) {
-  if (score >= 90) return { tier: 'Diamond', icon: '', level: 8 };  // A1 [90-99], 100 = native
+  if (score >= 90) return { tier: 'Diamond', icon: '', level: 8 }; // A1 [90-99], 100 = native
   if (score >= 80) return { tier: 'Platinum', icon: '', level: 7 }; // A2 [80-89]
-  if (score >= 70) return { tier: 'Gold', icon: '', level: 6 };     // A3 [70-79]
-  if (score >= 60) return { tier: 'Silver', icon: '', level: 5 };   // B1 [60-69]
-  if (score >= 50) return { tier: 'Bronze', icon: '', level: 4 };   // B2 [50-59]
-  if (score >= 40) return { tier: 'Copper', icon: '', level: 3 };   // B3 [40-49]
-  if (score >= 20) return { tier: 'Iron', icon: '', level: 2 };     // C  [20-39]
-  return { tier: 'Rust', icon: '', level: 1 };                      // D  [0-19]
+  if (score >= 70) return { tier: 'Gold', icon: '', level: 6 }; // A3 [70-79]
+  if (score >= 60) return { tier: 'Silver', icon: '', level: 5 }; // B1 [60-69]
+  if (score >= 50) return { tier: 'Bronze', icon: '', level: 4 }; // B2 [50-59]
+  if (score >= 40) return { tier: 'Copper', icon: '', level: 3 }; // B3 [40-49]
+  if (score >= 20) return { tier: 'Iron', icon: '', level: 2 }; // C  [20-39]
+  return { tier: 'Rust', icon: '', level: 1 }; // D  [0-19]
 }
 
 /**
@@ -135,21 +144,37 @@ function getCreditRating(kScore, trajectory = null) {
   // Grade mapping
   let grade, label, risk;
   if (adjustedScore >= 90) {
-    grade = 'A1'; label = 'Prime Quality'; risk = 'minimal';
+    grade = 'A1';
+    label = 'Prime Quality';
+    risk = 'minimal';
   } else if (adjustedScore >= 80) {
-    grade = 'A2'; label = 'Excellent'; risk = 'very_low';
+    grade = 'A2';
+    label = 'Excellent';
+    risk = 'very_low';
   } else if (adjustedScore >= 70) {
-    grade = 'A3'; label = 'Good'; risk = 'low';
+    grade = 'A3';
+    label = 'Good';
+    risk = 'low';
   } else if (adjustedScore >= 60) {
-    grade = 'B1'; label = 'Fair'; risk = 'moderate';
+    grade = 'B1';
+    label = 'Fair';
+    risk = 'moderate';
   } else if (adjustedScore >= 50) {
-    grade = 'B2'; label = 'Speculative'; risk = 'high';
+    grade = 'B2';
+    label = 'Speculative';
+    risk = 'high';
   } else if (adjustedScore >= 40) {
-    grade = 'B3'; label = 'Very Speculative'; risk = 'very_high';
+    grade = 'B3';
+    label = 'Very Speculative';
+    risk = 'very_high';
   } else if (adjustedScore >= 20) {
-    grade = 'C'; label = 'Substantial Risk'; risk = 'severe';
+    grade = 'C';
+    label = 'Substantial Risk';
+    risk = 'severe';
   } else {
-    grade = 'D'; label = 'Default'; risk = 'extreme';
+    grade = 'D';
+    label = 'Default';
+    risk = 'extreme';
   }
 
   // Outlook based on trajectory
@@ -272,7 +297,15 @@ async function getToken(mint) {
     logger.debug('HOLDEX', 'HOLDEX_URL not configured, skipping verification');
     const kRank = getKRank(0);
     const creditRating = getCreditRating(0);
-    return { tier: 'Rust', kScore: 0, kRank, creditRating, hasCommunityUpdate: false, cached: false, error: 'HOLDEX_URL not configured' };
+    return {
+      tier: 'Rust',
+      kScore: 0,
+      kRank,
+      creditRating,
+      hasCommunityUpdate: false,
+      cached: false,
+      error: 'HOLDEX_URL not configured',
+    };
   }
 
   try {
@@ -284,7 +317,7 @@ async function getToken(mint) {
       try {
         const res = await fetch(`${holdexUrl}/token/${mint}`, {
           signal: controller.signal,
-          headers: { 'Accept': 'application/json' },
+          headers: { Accept: 'application/json' },
         });
         clearTimeout(timeout);
         return res;
@@ -315,27 +348,32 @@ async function getToken(mint) {
     // Use kRank from API if available, otherwise calculate locally
     const kRank = token.kRank || getKRank(kScore);
     const tier = VALID_TIERS.has(kRank.tier) ? kRank.tier : getKRank(kScore).tier;
-    const hasCommunityUpdate = token.hasCommunityUpdate === true || token.hascommunityupdate === true;
+    const hasCommunityUpdate =
+      token.hasCommunityUpdate === true || token.hascommunityupdate === true;
 
     // Use creditRating from API if available, otherwise calculate locally
     const creditRating = token.creditRating || getCreditRating(kScore);
 
     // Extract conviction data if available
-    const conviction = token.conviction ? {
-      score: token.conviction.score || 0,
-      accumulators: token.conviction.accumulators || 0,
-      holders: token.conviction.holders || 0,
-      reducers: token.conviction.reducers || 0,
-      extractors: token.conviction.extractors || 0,
-      analyzed: token.conviction.analyzed || 0,
-    } : (token.conviction_score ? {
-      score: token.conviction_score,
-      accumulators: token.conviction_accumulators || 0,
-      holders: token.conviction_holders || 0,
-      reducers: token.conviction_reducers || 0,
-      extractors: token.conviction_extractors || 0,
-      analyzed: token.conviction_analyzed || 0,
-    } : null);
+    const conviction = token.conviction
+      ? {
+          score: token.conviction.score || 0,
+          accumulators: token.conviction.accumulators || 0,
+          holders: token.conviction.holders || 0,
+          reducers: token.conviction.reducers || 0,
+          extractors: token.conviction.extractors || 0,
+          analyzed: token.conviction.analyzed || 0,
+        }
+      : token.conviction_score
+        ? {
+            score: token.conviction_score,
+            accumulators: token.conviction_accumulators || 0,
+            holders: token.conviction_holders || 0,
+            reducers: token.conviction_reducers || 0,
+            extractors: token.conviction_extractors || 0,
+            analyzed: token.conviction_analyzed || 0,
+          }
+        : null;
 
     // ==========================================================================
     // DUAL-BURN FLYWHEEL: Use HolDex burn data (source of truth) or calculate
@@ -369,13 +407,17 @@ async function getToken(mint) {
       // Non-pump.fun: Use HolDex data if available
       burnedPercent = token.burnedPercent;
       burnedAmount = token.burnedAmount || 0;
-      initialSupply = parseFloat(token.initialSupply) * Math.pow(10, token.decimals || 6) || PUMP_FUN_INITIAL_SUPPLY;
+      initialSupply =
+        parseFloat(token.initialSupply) * Math.pow(10, token.decimals || 6) ||
+        PUMP_FUN_INITIAL_SUPPLY;
       burnSource = 'holdex';
     } else if (token.burned_percent && token.burned_percent > 0) {
       // Alternative field names
       burnedPercent = token.burned_percent;
       burnedAmount = token.burned_amount || 0;
-      initialSupply = parseFloat(token.initial_supply) * Math.pow(10, token.decimals || 6) || PUMP_FUN_INITIAL_SUPPLY;
+      initialSupply =
+        parseFloat(token.initial_supply) * Math.pow(10, token.decimals || 6) ||
+        PUMP_FUN_INITIAL_SUPPLY;
       burnSource = 'holdex';
     } else if (currentSupply > 0 && currentSupply < PUMP_FUN_INITIAL_SUPPLY) {
       // Fallback: Calculate from pump.fun standard 1B initial supply
@@ -425,12 +467,18 @@ async function getToken(mint) {
     // Check if circuit breaker is open
     const isCircuitOpen = error.code === 'CIRCUIT_OPEN';
 
-    logger.warn('HOLDEX', isCircuitOpen ? 'Circuit breaker open, using fallback' : 'Token fetch failed, trying on-chain fallback', {
-      mint: mint.slice(0, 8),
-      error: error.message,
-      circuitOpen: isCircuitOpen,
-      circuitState: holdexBreaker.getStatus().state,
-    });
+    logger.warn(
+      'HOLDEX',
+      isCircuitOpen
+        ? 'Circuit breaker open, using fallback'
+        : 'Token fetch failed, trying on-chain fallback',
+      {
+        mint: mint.slice(0, 8),
+        error: error.message,
+        circuitOpen: isCircuitOpen,
+        circuitState: holdexBreaker.getStatus().state,
+      }
+    );
 
     // ==========================================================================
     // FALLBACK: On-chain is truth - get supply directly from Solana
diff --git a/src/services/jito.js b/src/services/jito.js
index 9347a23..cb2603c 100644
--- a/src/services/jito.js
+++ b/src/services/jito.js
@@ -297,7 +297,10 @@ async function getBundleStatus(bundleId) {
     }
 
     // Track landed bundles
-    if (bundleStatus.confirmation_status === 'confirmed' || bundleStatus.confirmation_status === 'finalized') {
+    if (
+      bundleStatus.confirmation_status === 'confirmed' ||
+      bundleStatus.confirmation_status === 'finalized'
+    ) {
       bundlesLanded++;
     }
 
diff --git a/src/services/jupiter.js b/src/services/jupiter.js
index 1998efb..8f1848d 100644
--- a/src/services/jupiter.js
+++ b/src/services/jupiter.js
@@ -38,11 +38,11 @@ function getJupiterHeaders(contentType = false) {
 
 // Common token info (avoid extra API calls)
 const TOKEN_INFO = {
-  'So11111111111111111111111111111111111111112': { symbol: 'SOL', decimals: 9 },
-  'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': { symbol: 'USDC', decimals: 6 },
-  'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB': { symbol: 'USDT', decimals: 6 },
-  'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So': { symbol: 'mSOL', decimals: 9 },
-  'J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn': { symbol: 'jitoSOL', decimals: 9 },
+  So11111111111111111111111111111111111111112: { symbol: 'SOL', decimals: 9 },
+  EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v: { symbol: 'USDC', decimals: 6 },
+  Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB: { symbol: 'USDT', decimals: 6 },
+  mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So: { symbol: 'mSOL', decimals: 9 },
+  J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn: { symbol: 'jitoSOL', decimals: 9 },
   '9zB5wRarXMj86MymwLumSKA1Dx35zPqqKfcZtK1Spump': { symbol: '$ASDF', decimals: 6 },
 };
 
@@ -214,7 +214,7 @@ async function getFeeInToken(inputMint, solAmountLamports) {
         inputAmount = Math.ceil((solAmountLamports / 1e9) * 200 * Math.pow(10, tokenInfo.decimals));
       } else {
         // For other tokens, assume 1:1 with SOL as fallback
-        inputAmount = Math.ceil(solAmountLamports * Math.pow(10, tokenInfo.decimals) / 1e9);
+        inputAmount = Math.ceil((solAmountLamports * Math.pow(10, tokenInfo.decimals)) / 1e9);
       }
 
       return {
@@ -296,9 +296,10 @@ module.exports = {
     cache: {
       hits: cacheHits,
       misses: cacheMisses,
-      hitRate: cacheHits + cacheMisses > 0
-        ? ((cacheHits / (cacheHits + cacheMisses)) * 100).toFixed(1) + '%'
-        : 'N/A',
+      hitRate:
+        cacheHits + cacheMisses > 0
+          ? ((cacheHits / (cacheHits + cacheMisses)) * 100).toFixed(1) + '%'
+          : 'N/A',
       ...redis.getJupiterCacheStats(),
     },
   }),
diff --git a/src/services/pyth.js b/src/services/pyth.js
index aa0b93d..62e563d 100644
--- a/src/services/pyth.js
+++ b/src/services/pyth.js
@@ -44,11 +44,11 @@ const PriceStatus = {
 // Token mint  Pyth feed mapping
 const MINT_TO_FEED = {
   // SOL (wrapped)
-  'So11111111111111111111111111111111111111112': 'SOL/USD',
+  So11111111111111111111111111111111111111112: 'SOL/USD',
   // USDC
-  'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': 'USDC/USD',
+  EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v: 'USDC/USD',
   // USDT
-  'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB': 'USDT/USD',
+  Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB: 'USDT/USD',
 };
 
 // Cache for price data (reduces RPC calls)
@@ -159,7 +159,9 @@ async function getPrice(feedName) {
     // Validate it's a PriceUpdateV2 account (owner = Pyth Solana Receiver)
     const PYTH_RECEIVER = 'rec5EKMGg6MxZYaMdyBfgwp4d5rB9T1VQH5pJv5LtFJ';
     if (accountInfo.owner.toBase58() !== PYTH_RECEIVER) {
-      throw new Error(`Invalid account owner for ${feedName}: expected ${PYTH_RECEIVER}, got ${accountInfo.owner.toBase58()}`);
+      throw new Error(
+        `Invalid account owner for ${feedName}: expected ${PYTH_RECEIVER}, got ${accountInfo.owner.toBase58()}`
+      );
     }
 
     const priceData = parsePriceUpdateV2(accountInfo.data);
@@ -197,7 +199,10 @@ async function getPrice(feedName) {
 
     // Return stale cache if available
     if (cached) {
-      logger.warn('PYTH', 'Using stale cache', { feed: feedName, age: Date.now() - cached.fetchedAt });
+      logger.warn('PYTH', 'Using stale cache', {
+        feed: feedName,
+        age: Date.now() - cached.fetchedAt,
+      });
       return { ...cached, cached: true, stale: true };
     }
 
@@ -335,9 +340,10 @@ function getStatus() {
       ttlMs: CACHE_TTL_MS,
       hits: cacheHits,
       misses: cacheMisses,
-      hitRate: cacheHits + cacheMisses > 0
-        ? ((cacheHits / (cacheHits + cacheMisses)) * 100).toFixed(1) + '%'
-        : 'N/A',
+      hitRate:
+        cacheHits + cacheMisses > 0
+          ? ((cacheHits / (cacheHits + cacheMisses)) * 100).toFixed(1) + '%'
+          : 'N/A',
     },
     rpcCalls,
   };
diff --git a/src/services/token-gate.js b/src/services/token-gate.js
index aafedb8..5270c47 100644
--- a/src/services/token-gate.js
+++ b/src/services/token-gate.js
@@ -36,10 +36,10 @@ const holdex = require('./holdex');
 // HolDex should return tier="Diamond" for these, but we also check locally
 // for performance (skip network call).
 const DIAMOND_TOKENS = new Set([
-  'So11111111111111111111111111111111111111112',   // SOL (native)
+  'So11111111111111111111111111111111111111112', // SOL (native)
   'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC
   'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', // USDT
-  'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So',  // mSOL
+  'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So', // mSOL
   'J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn', // jitoSOL
 ]);
 
@@ -175,13 +175,17 @@ function getDiamondTokensList() {
       tier: 'Diamond',
     },
     // $ASDF added dynamically if configured
-    ...(config.ASDF_MINT && !config.ASDF_MINT.includes('Devnet') ? [{
-      mint: config.ASDF_MINT,
-      symbol: 'ASDF',
-      name: '$ASDF',
-      decimals: 6,
-      tier: 'Diamond',
-    }] : []),
+    ...(config.ASDF_MINT && !config.ASDF_MINT.includes('Devnet')
+      ? [
+          {
+            mint: config.ASDF_MINT,
+            symbol: 'ASDF',
+            name: '$ASDF',
+            decimals: 6,
+            tier: 'Diamond',
+          },
+        ]
+      : []),
   ];
 }
 
diff --git a/src/services/treasury-ata.js b/src/services/treasury-ata.js
index 13c9bef..91157a5 100644
--- a/src/services/treasury-ata.js
+++ b/src/services/treasury-ata.js
@@ -69,13 +69,19 @@ async function checkTreasuryAta(tokenMint) {
     if (account) {
       // Cache the result
       ataCache.set(mintStr, ataAddress.toBase58());
-      logger.debug('TREASURY_ATA', 'ATA exists', { mint: mintStr.slice(0, 8), ata: ataAddress.toBase58().slice(0, 8) });
+      logger.debug('TREASURY_ATA', 'ATA exists', {
+        mint: mintStr.slice(0, 8),
+        ata: ataAddress.toBase58().slice(0, 8),
+      });
       return ataAddress.toBase58();
     }
 
     return null;
   } catch (error) {
-    logger.error('TREASURY_ATA', 'Error checking ATA', { mint: mintStr.slice(0, 8), error: error.message });
+    logger.error('TREASURY_ATA', 'Error checking ATA', {
+      mint: mintStr.slice(0, 8),
+      error: error.message,
+    });
     return null;
   }
 }
@@ -91,7 +97,7 @@ async function createTreasuryAta(tokenMint, tokenProgram = TOKEN_PROGRAM_ID) {
   if (pendingCreations.has(mintStr)) {
     logger.debug('TREASURY_ATA', 'Creation already pending', { mint: mintStr.slice(0, 8) });
     // Wait a bit and check again
-    await new Promise(r => setTimeout(r, 2000));
+    await new Promise((r) => setTimeout(r, 2000));
     return checkTreasuryAta(tokenMint);
   }
 
@@ -114,7 +120,10 @@ async function createTreasuryAta(tokenMint, tokenProgram = TOKEN_PROGRAM_ID) {
       return ataAddress.toBase58();
     }
 
-    logger.info('TREASURY_ATA', 'Creating ATA', { mint: mintStr.slice(0, 8), treasury: treasury.toBase58().slice(0, 8) });
+    logger.info('TREASURY_ATA', 'Creating ATA', {
+      mint: mintStr.slice(0, 8),
+      treasury: treasury.toBase58().slice(0, 8),
+    });
 
     // Get fee payer for creation
     const feePayer = getFeePayer();
@@ -129,11 +138,11 @@ async function createTreasuryAta(tokenMint, tokenProgram = TOKEN_PROGRAM_ID) {
 
     transaction.add(
       createAssociatedTokenAccountInstruction(
-        feePayer.publicKey,  // payer
-        ataAddress,          // ata
-        treasury,            // owner
-        mint,                // mint
-        tokenProgram         // token program
+        feePayer.publicKey, // payer
+        ataAddress, // ata
+        treasury, // owner
+        mint, // mint
+        tokenProgram // token program
       )
     );
 
@@ -144,11 +153,14 @@ async function createTreasuryAta(tokenMint, tokenProgram = TOKEN_PROGRAM_ID) {
       preflightCommitment: 'confirmed',
     });
 
-    await connection.confirmTransaction({
-      signature,
-      blockhash,
-      lastValidBlockHeight,
-    }, 'confirmed');
+    await connection.confirmTransaction(
+      {
+        signature,
+        blockhash,
+        lastValidBlockHeight,
+      },
+      'confirmed'
+    );
 
     // Cache the result
     ataCache.set(mintStr, ataAddress.toBase58());
@@ -161,7 +173,10 @@ async function createTreasuryAta(tokenMint, tokenProgram = TOKEN_PROGRAM_ID) {
 
     return ataAddress.toBase58();
   } catch (error) {
-    logger.error('TREASURY_ATA', 'Failed to create ATA', { mint: mintStr.slice(0, 8), error: error.message });
+    logger.error('TREASURY_ATA', 'Failed to create ATA', {
+      mint: mintStr.slice(0, 8),
+      error: error.message,
+    });
     throw error;
   } finally {
     pendingCreations.delete(mintStr);
@@ -203,7 +218,10 @@ async function detectTokenProgram(tokenMint) {
  */
 async function ensureTreasuryAta(tokenMint, tokenProgram = null) {
   // Skip for native SOL
-  if (tokenMint === config.WSOL_MINT || tokenMint === 'So11111111111111111111111111111111111111112') {
+  if (
+    tokenMint === config.WSOL_MINT ||
+    tokenMint === 'So11111111111111111111111111111111111111112'
+  ) {
     return null; // Native SOL doesn't need ATA
   }
 
@@ -231,7 +249,10 @@ async function getTreasuryAtaInfo(tokenMint) {
   }
 
   // Native SOL doesn't need ATA
-  if (tokenMint === config.WSOL_MINT || tokenMint === 'So11111111111111111111111111111111111111112') {
+  if (
+    tokenMint === config.WSOL_MINT ||
+    tokenMint === 'So11111111111111111111111111111111111111112'
+  ) {
     return {
       exists: true,
       address: treasury.toBase58(),
diff --git a/src/services/tx-queue.js b/src/services/tx-queue.js
index 53c6db5..610ec86 100644
--- a/src/services/tx-queue.js
+++ b/src/services/tx-queue.js
@@ -16,9 +16,9 @@ const RETRY_DELAYS = [1000, 5000, 15000]; // ms (legacy, kept for compatibility)
 
 // Exponential backoff configuration
 const BACKOFF_CONFIG = {
-  baseDelayMs: 500,      // Initial delay
-  maxDelayMs: 15000,     // Cap at 15 seconds
-  jitterMs: 500,         // Random jitter range (0 to jitterMs)
+  baseDelayMs: 500, // Initial delay
+  maxDelayMs: 15000, // Cap at 15 seconds
+  jitterMs: 500, // Random jitter range (0 to jitterMs)
 };
 
 /**
@@ -34,10 +34,7 @@ function getRetryDelay(attempt) {
   const { baseDelayMs, maxDelayMs, jitterMs } = BACKOFF_CONFIG;
 
   // Exponential: 500ms, 1000ms, 2000ms, 4000ms, 8000ms... capped at maxDelay
-  const exponentialDelay = Math.min(
-    baseDelayMs * Math.pow(2, attempt - 1),
-    maxDelayMs
-  );
+  const exponentialDelay = Math.min(baseDelayMs * Math.pow(2, attempt - 1), maxDelayMs);
 
   // Add random jitter to prevent synchronized retries
   const jitter = Math.floor(Math.random() * jitterMs);
@@ -144,9 +141,7 @@ async function markSuccess(txId, signature) {
  */
 function isRetryableError(error) {
   const errorStr = String(error.message || error);
-  return RETRYABLE_ERRORS.some(pattern =>
-    errorStr.toLowerCase().includes(pattern.toLowerCase())
-  );
+  return RETRYABLE_ERRORS.some((pattern) => errorStr.toLowerCase().includes(pattern.toLowerCase()));
 }
 
 /**
@@ -246,7 +241,7 @@ module.exports = {
 
   // Constants
   MAX_RETRIES,
-  RETRY_DELAYS,      // Legacy, use getRetryDelay() instead
+  RETRY_DELAYS, // Legacy, use getRetryDelay() instead
   RETRYABLE_ERRORS,
   BACKOFF_CONFIG,
 };
diff --git a/src/services/validator.js b/src/services/validator.js
index 0817a69..1642c7a 100644
--- a/src/services/validator.js
+++ b/src/services/validator.js
@@ -42,12 +42,12 @@ const TOKEN_2022_PROGRAM_ID = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb';
 // Defense-in-depth: block obvious attacks, but simulation is primary defense
 const TOKEN_DANGEROUS_INSTRUCTIONS = {
   3: 'Transfer',
-  4: 'Approve',           // Grants delegate access
-  5: 'Revoke',            // Could be part of exploit chain
-  6: 'SetAuthority',      // Changes ownership
-  7: 'MintTo',            // Could mint if fee payer is mint authority
-  8: 'Burn',              // Burns tokens
-  9: 'CloseAccount',      // Closes account, sends SOL to destination
+  4: 'Approve', // Grants delegate access
+  5: 'Revoke', // Could be part of exploit chain
+  6: 'SetAuthority', // Changes ownership
+  7: 'MintTo', // Could mint if fee payer is mint authority
+  8: 'Burn', // Burns tokens
+  9: 'CloseAccount', // Closes account, sends SOL to destination
   12: 'TransferChecked',
   13: 'ApproveChecked',
   14: 'MintToChecked',
@@ -57,8 +57,8 @@ const TOKEN_DANGEROUS_INSTRUCTIONS = {
 // System Program dangerous instructions
 const SYSTEM_DANGEROUS_INSTRUCTIONS = {
   2: 'Transfer',
-  3: 'CreateAccountWithSeed',  // Could create account for draining
-  8: 'Allocate',               // Could manipulate account data
+  3: 'CreateAccountWithSeed', // Could create account for draining
+  8: 'Allocate', // Could manipulate account data
   9: 'AllocateWithSeed',
   10: 'AssignWithSeed',
   11: 'TransferWithSeed',
@@ -121,7 +121,7 @@ function validateTransaction(transaction, expectedFeeAmount, userPubkey) {
 
   // Get all valid fee payer pubkeys
   const validFeePayerPubkeys = getAllFeePayerPublicKeys();
-  const validPubkeySet = new Set(validFeePayerPubkeys.map(p => p.toBase58()));
+  const validPubkeySet = new Set(validFeePayerPubkeys.map((p) => p.toBase58()));
 
   // Check 1: Fee payer must be one of our wallets
   let txFeePayer;
@@ -225,19 +225,19 @@ function validateNoFeePayerTokenDrain(transaction, feePayerPubkeys) {
           let authorityIndex;
 
           switch (discriminator) {
-            case 3:  // Transfer
-            case 4:  // Approve
-            case 5:  // Revoke
-            case 8:  // Burn
+            case 3: // Transfer
+            case 4: // Approve
+            case 5: // Revoke
+            case 8: // Burn
               authorityIndex = 2; // source, (dest|delegate), authority
               break;
-            case 6:  // SetAuthority
+            case 6: // SetAuthority
               authorityIndex = 1; // account, currentAuthority
               break;
-            case 7:  // MintTo
+            case 7: // MintTo
               authorityIndex = 2; // mint, dest, mintAuthority
               break;
-            case 9:  // CloseAccount
+            case 9: // CloseAccount
               authorityIndex = 2; // account, dest, authority
               break;
             case 12: // TransferChecked
@@ -308,9 +308,7 @@ function verifyUserSignature(transaction, userPubkey) {
     } else {
       // Legacy Transaction
       messageBytes = transaction.serializeMessage();
-      const userSig = transaction.signatures.find(
-        (sig) => sig.publicKey.toBase58() === userPubkey
-      );
+      const userSig = transaction.signatures.find((sig) => sig.publicKey.toBase58() === userPubkey);
 
       if (!userSig) {
         return { valid: false, error: 'User public key not found in transaction signers' };
@@ -326,8 +324,10 @@ function verifyUserSignature(transaction, userPubkey) {
 
     // Cryptographic Ed25519 signature verification
     const signatureBytes = signature instanceof Uint8Array ? signature : new Uint8Array(signature);
-    const messageUint8 = messageBytes instanceof Uint8Array ? messageBytes : new Uint8Array(messageBytes);
-    const pubkeyUint8 = publicKeyBytes instanceof Uint8Array ? publicKeyBytes : new Uint8Array(publicKeyBytes);
+    const messageUint8 =
+      messageBytes instanceof Uint8Array ? messageBytes : new Uint8Array(messageBytes);
+    const pubkeyUint8 =
+      publicKeyBytes instanceof Uint8Array ? publicKeyBytes : new Uint8Array(publicKeyBytes);
 
     const isValid = nacl.sign.detached.verify(messageUint8, signatureBytes, pubkeyUint8);
 
@@ -512,7 +512,9 @@ async function validateFeePayment(transaction, quote, userPubkey) {
 
   const expectedAmount = parseInt(quote.feeAmount);
   const paymentToken = quote.paymentToken?.mint || quote.paymentToken;
-  const isSOL = paymentToken === config.WSOL_MINT || paymentToken === 'So11111111111111111111111111111111111111112';
+  const isSOL =
+    paymentToken === config.WSOL_MINT ||
+    paymentToken === 'So11111111111111111111111111111111111111112';
 
   let foundPayment = false;
   let actualAmount = 0;
@@ -547,12 +549,14 @@ async function validateFeePayment(transaction, quote, userPubkey) {
         // Transfer (3) or TransferChecked (12)
         if (discriminator === 3 || discriminator === 12) {
           const sourceAccount = getAccountAtIndex(ix, 0, accountKeys);
-          const destAccount = discriminator === 3
-            ? getAccountAtIndex(ix, 1, accountKeys)
-            : getAccountAtIndex(ix, 2, accountKeys); // TransferChecked has mint at index 1
-          const authority = discriminator === 3
-            ? getAccountAtIndex(ix, 2, accountKeys)
-            : getAccountAtIndex(ix, 3, accountKeys);
+          const destAccount =
+            discriminator === 3
+              ? getAccountAtIndex(ix, 1, accountKeys)
+              : getAccountAtIndex(ix, 2, accountKeys); // TransferChecked has mint at index 1
+          const authority =
+            discriminator === 3
+              ? getAccountAtIndex(ix, 2, accountKeys)
+              : getAccountAtIndex(ix, 3, accountKeys);
 
           // Verify authority is the user
           if (authority !== userPubkey) continue;
diff --git a/src/utils/alt.js b/src/utils/alt.js
index 3ece274..d145695 100644
--- a/src/utils/alt.js
+++ b/src/utils/alt.js
@@ -206,7 +206,7 @@ function calculateSizeSavings(addressCount, altHits) {
     withoutAlt,
     withAlt,
     savings: withoutAlt - withAlt,
-    savingsPercent: ((withoutAlt - withAlt) / withoutAlt * 100).toFixed(1),
+    savingsPercent: (((withoutAlt - withAlt) / withoutAlt) * 100).toFixed(1),
   };
 }
 
diff --git a/src/utils/circuit-breaker.js b/src/utils/circuit-breaker.js
index db07ff8..6416a19 100644
--- a/src/utils/circuit-breaker.js
+++ b/src/utils/circuit-breaker.js
@@ -5,8 +5,8 @@ const logger = require('./logger');
 // =============================================================================
 
 const STATE = {
-  CLOSED: 'closed',     // Normal operation
-  OPEN: 'open',         // Failures threshold reached, fast-fail
+  CLOSED: 'closed', // Normal operation
+  OPEN: 'open', // Failures threshold reached, fast-fail
   HALF_OPEN: 'half-open', // Testing if service recovered
 };
 
@@ -214,9 +214,10 @@ class CircuitBreaker {
       resetTimeout: this.resetTimeout,
       lastFailure: this.lastFailure,
       openedAt: this.openedAt,
-      timeUntilRetry: this.state === STATE.OPEN
-        ? Math.max(0, this.resetTimeout - (Date.now() - this.openedAt))
-        : 0,
+      timeUntilRetry:
+        this.state === STATE.OPEN
+          ? Math.max(0, this.resetTimeout - (Date.now() - this.openedAt))
+          : 0,
     };
   }
 
@@ -226,9 +227,10 @@ class CircuitBreaker {
   getStats() {
     return {
       ...this.stats,
-      successRate: this.stats.totalRequests > 0
-        ? (this.stats.successfulRequests / this.stats.totalRequests * 100).toFixed(2) + '%'
-        : 'N/A',
+      successRate:
+        this.stats.totalRequests > 0
+          ? ((this.stats.successfulRequests / this.stats.totalRequests) * 100).toFixed(2) + '%'
+          : 'N/A',
       recentStateChanges: this.stats.stateChanges.slice(-5),
     };
   }
@@ -294,32 +296,36 @@ const rpcBreaker = new CircuitBreaker({
   isFailure: (error) => {
     const msg = error.message?.toLowerCase() || '';
     // Only count network/service errors
-    return msg.includes('timeout') ||
-           msg.includes('econnrefused') ||
-           msg.includes('service unavailable') ||
-           msg.includes('too many requests');
+    return (
+      msg.includes('timeout') ||
+      msg.includes('econnrefused') ||
+      msg.includes('service unavailable') ||
+      msg.includes('too many requests')
+    );
   },
 });
 
 // HolDex API circuit breaker
 const holdexBreaker = new CircuitBreaker({
   name: 'holdex',
-  failureThreshold: 3,       // Open after 3 failures
-  resetTimeout: 60000,       // 60 seconds - external API, give it time
+  failureThreshold: 3, // Open after 3 failures
+  resetTimeout: 60000, // 60 seconds - external API, give it time
   isFailure: (error) => {
     const msg = error.message?.toLowerCase() || '';
     // Don't count 404 (token not found) as failure - that's expected
     // Don't count client errors (400) as failure
     // Only count network/service errors
-    return msg.includes('timeout') ||
-           msg.includes('aborted') ||
-           msg.includes('econnrefused') ||
-           msg.includes('enotfound') ||
-           msg.includes('service unavailable') ||
-           msg.includes('500') ||
-           msg.includes('502') ||
-           msg.includes('503') ||
-           msg.includes('504');
+    return (
+      msg.includes('timeout') ||
+      msg.includes('aborted') ||
+      msg.includes('econnrefused') ||
+      msg.includes('enotfound') ||
+      msg.includes('service unavailable') ||
+      msg.includes('500') ||
+      msg.includes('502') ||
+      msg.includes('503') ||
+      msg.includes('504')
+    );
   },
 });
 
diff --git a/src/utils/config.js b/src/utils/config.js
index dc6fe43..98305c1 100644
--- a/src/utils/config.js
+++ b/src/utils/config.js
@@ -83,9 +83,11 @@ const config = {
   FEE_PAYER_KEYS: process.env.FEE_PAYER_KEYS?.split(',').filter(Boolean) || [],
 
   // $ASDF token mint
-  ASDF_MINT: process.env.ASDF_MINT || (IS_DEV
-    ? 'ASdfDevnetFakeMintAddress1111111111111'
-    : '9zB5wRarXMj86MymwLumSKA1Dx35zPqqKfcZtK1Spump'),
+  ASDF_MINT:
+    process.env.ASDF_MINT ||
+    (IS_DEV
+      ? 'ASdfDevnetFakeMintAddress1111111111111'
+      : '9zB5wRarXMj86MymwLumSKA1Dx35zPqqKfcZtK1Spump'),
 
   // Wrapped SOL mint (same on all networks)
   WSOL_MINT: 'So11111111111111111111111111111111111111112',
@@ -193,7 +195,9 @@ function validateConfig() {
 
   // Validate fee payer private key format
   if (config.FEE_PAYER_PRIVATE_KEY && !PRIVATE_KEY_REGEX.test(config.FEE_PAYER_PRIVATE_KEY)) {
-    errors.push('FEE_PAYER_PRIVATE_KEY must be a valid base58 encoded private key (64-88 characters)');
+    errors.push(
+      'FEE_PAYER_PRIVATE_KEY must be a valid base58 encoded private key (64-88 characters)'
+    );
   }
 
   // Validate multi fee payer keys format (Phase 2)
@@ -212,9 +216,10 @@ function validateConfig() {
     }
 
     // Check for placeholder values
-    const isPlaceholder = config.ASDF_MINT.includes('evnet') ||
-                         config.ASDF_MINT.includes('FakeMint') ||
-                         config.ASDF_MINT.includes('Devnet');
+    const isPlaceholder =
+      config.ASDF_MINT.includes('evnet') ||
+      config.ASDF_MINT.includes('FakeMint') ||
+      config.ASDF_MINT.includes('Devnet');
 
     if (isPlaceholder) {
       if (IS_PROD) {
@@ -246,7 +251,9 @@ function validateConfig() {
   // Jupiter API key required in production (lite-api deprecated Jan 31, 2026)
   if (!config.JUPITER_API_KEY) {
     if (IS_PROD) {
-      errors.push('JUPITER_API_KEY required - lite-api deprecated Jan 31, 2026 (get key at portal.jup.ag)');
+      errors.push(
+        'JUPITER_API_KEY required - lite-api deprecated Jan 31, 2026 (get key at portal.jup.ag)'
+      );
     } else {
       warnings.push('JUPITER_API_KEY not set - lite-api deprecated, get key at portal.jup.ag');
     }
diff --git a/src/utils/db.js b/src/utils/db.js
index c9135cf..3f9da13 100644
--- a/src/utils/db.js
+++ b/src/utils/db.js
@@ -27,8 +27,8 @@ const RECONNECT_BASE_DELAY = 1000;
 const dbCircuit = new CircuitBreaker({
   name: 'postgresql',
   failureThreshold: 3,
-  resetTimeout: 30000,         // Try to recover after 30s
-  halfOpenMaxRequests: 2,      // Allow 2 test requests in half-open
+  resetTimeout: 30000, // Try to recover after 30s
+  halfOpenMaxRequests: 2, // Allow 2 test requests in half-open
   isFailure: (error) => {
     // Don't count constraint violations or data errors as circuit failures
     const code = error.code || '';
@@ -50,8 +50,9 @@ async function initialize() {
   try {
     // Determine SSL config based on URL and environment
     // Render external connections require SSL with self-signed certs
-    const isRender = config.DATABASE_URL.includes('render.com') ||
-                     config.DATABASE_URL.includes('postgres.render.com');
+    const isRender =
+      config.DATABASE_URL.includes('render.com') ||
+      config.DATABASE_URL.includes('postgres.render.com');
 
     pool = new Pool({
       connectionString: config.DATABASE_URL,
@@ -202,26 +203,28 @@ function isTransientError(error) {
     'ETIMEDOUT',
     'EPIPE',
     'EAI_AGAIN',
-    '57P01',  // admin_shutdown
-    '57P02',  // crash_shutdown
-    '57P03',  // cannot_connect_now
-    '08000',  // connection_exception
-    '08003',  // connection_does_not_exist
-    '08006',  // connection_failure
-    '40001',  // serialization_failure
-    '40P01',  // deadlock_detected
+    '57P01', // admin_shutdown
+    '57P02', // crash_shutdown
+    '57P03', // cannot_connect_now
+    '08000', // connection_exception
+    '08003', // connection_does_not_exist
+    '08006', // connection_failure
+    '40001', // serialization_failure
+    '40P01', // deadlock_detected
   ];
 
-  return transientCodes.includes(error.code) ||
-         error.message?.includes('Connection terminated') ||
-         error.message?.includes('timeout') ||
-         error.message?.includes('ECONNRESET');
+  return (
+    transientCodes.includes(error.code) ||
+    error.message?.includes('Connection terminated') ||
+    error.message?.includes('timeout') ||
+    error.message?.includes('ECONNRESET')
+  );
 }
 
 /**
  * Sleep helper for backoff
  */
-const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
+const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
 
 /**
  * Execute query with retry and circuit breaker protection
@@ -230,11 +233,7 @@ const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
  * @returns {Promise<any>} Query result or fallback
  */
 async function withDb(queryFn, options = {}) {
-  const {
-    retries = 2,
-    fallback = null,
-    operation = 'query',
-  } = options;
+  const { retries = 2, fallback = null, operation = 'query' } = options;
 
   // Check circuit breaker state
   if (!dbCircuit.canExecute()) {
@@ -254,7 +253,6 @@ async function withDb(queryFn, options = {}) {
       reconnectAttempts = 0; // Reset on success
       return result;
     } catch (error) {
-
       // Check if retryable
       if (isTransientError(error) && attempt < retries) {
         // Exponential backoff with jitter to prevent thundering herd
@@ -351,51 +349,55 @@ async function ping() {
  * Record a burn in the database
  */
 async function recordBurn(burn) {
-  return withDb(async (p) => {
-    const query = `
+  return withDb(
+    async (p) => {
+      const query = `
       INSERT INTO burns (signature, swap_signature, amount_burned, sol_equivalent, treasury_amount, method, wallet)
       VALUES ($1, $2, $3, $4, $5, $6, $7)
       ON CONFLICT (signature) DO NOTHING
       RETURNING *
     `;
-    const result = await p.query(query, [
-      burn.signature,
-      burn.swapSignature || null,
-      burn.amountBurned,
-      burn.solEquivalent || null,
-      burn.treasuryAmount || null,
-      burn.method || 'jupiter',
-      burn.wallet || null,
-    ]);
-    return result.rows[0] || null;
-  }, { operation: 'recordBurn', retries: 3 }); // Burns are critical, more retries
+      const result = await p.query(query, [
+        burn.signature,
+        burn.swapSignature || null,
+        burn.amountBurned,
+        burn.solEquivalent || null,
+        burn.treasuryAmount || null,
+        burn.method || 'jupiter',
+        burn.wallet || null,
+      ]);
+      return result.rows[0] || null;
+    },
+    { operation: 'recordBurn', retries: 3 }
+  ); // Burns are critical, more retries
 }
 
 /**
  * Get burn history with pagination
  */
 async function getBurnHistory(limit = 50, offset = 0) {
-  return withDb(async (p) => {
-    const [burns, countResult] = await Promise.all([
-      p.query(
-        'SELECT * FROM burns ORDER BY created_at DESC LIMIT $1 OFFSET $2',
-        [limit, offset]
-      ),
-      p.query('SELECT COUNT(*) FROM burns'),
-    ]);
-    return {
-      burns: burns.rows,
-      total: parseInt(countResult.rows[0].count),
-    };
-  }, { operation: 'getBurnHistory', fallback: { burns: [], total: 0 } });
+  return withDb(
+    async (p) => {
+      const [burns, countResult] = await Promise.all([
+        p.query('SELECT * FROM burns ORDER BY created_at DESC LIMIT $1 OFFSET $2', [limit, offset]),
+        p.query('SELECT COUNT(*) FROM burns'),
+      ]);
+      return {
+        burns: burns.rows,
+        total: parseInt(countResult.rows[0].count),
+      };
+    },
+    { operation: 'getBurnHistory', fallback: { burns: [], total: 0 } }
+  );
 }
 
 /**
  * Get burn statistics
  */
 async function getBurnStats() {
-  return withDb(async (p) => {
-    const query = `
+  return withDb(
+    async (p) => {
+      const query = `
       SELECT
         COUNT(*) as total_burns,
         COALESCE(SUM(amount_burned), 0) as total_amount,
@@ -405,22 +407,27 @@ async function getBurnStats() {
         MAX(created_at) as last_burn
       FROM burns
     `;
-    const result = await p.query(query);
-    return result.rows[0];
-  }, { operation: 'getBurnStats' });
+      const result = await p.query(query);
+      return result.rows[0];
+    },
+    { operation: 'getBurnStats' }
+  );
 }
 
 /**
  * Get burns by wallet
  */
 async function getBurnsByWallet(wallet, limit = 50) {
-  return withDb(async (p) => {
-    const result = await p.query(
-      'SELECT * FROM burns WHERE wallet = $1 ORDER BY created_at DESC LIMIT $2',
-      [wallet, limit]
-    );
-    return result.rows;
-  }, { operation: 'getBurnsByWallet', fallback: [] });
+  return withDb(
+    async (p) => {
+      const result = await p.query(
+        'SELECT * FROM burns WHERE wallet = $1 ORDER BY created_at DESC LIMIT $2',
+        [wallet, limit]
+      );
+      return result.rows;
+    },
+    { operation: 'getBurnsByWallet', fallback: [] }
+  );
 }
 
 // =============================================================================
@@ -431,8 +438,9 @@ async function getBurnsByWallet(wallet, limit = 50) {
  * Record a transaction
  */
 async function recordTransaction(tx) {
-  return withDb(async (p) => {
-    const query = `
+  return withDb(
+    async (p) => {
+      const query = `
       INSERT INTO transactions (quote_id, signature, user_wallet, payment_token, fee_amount, fee_sol_equivalent, status, ip_address)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
       ON CONFLICT (quote_id) DO UPDATE SET
@@ -441,26 +449,29 @@ async function recordTransaction(tx) {
         completed_at = CASE WHEN EXCLUDED.status IN ('confirmed', 'failed') THEN NOW() ELSE transactions.completed_at END
       RETURNING *
     `;
-    const result = await p.query(query, [
-      tx.quoteId,
-      tx.signature || null,
-      tx.userWallet,
-      tx.paymentToken,
-      tx.feeAmount,
-      tx.feeSolEquivalent || null,
-      tx.status || 'pending',
-      tx.ipAddress || null,
-    ]);
-    return result.rows[0] || null;
-  }, { operation: 'recordTransaction', retries: 3 }); // Transactions are critical
+      const result = await p.query(query, [
+        tx.quoteId,
+        tx.signature || null,
+        tx.userWallet,
+        tx.paymentToken,
+        tx.feeAmount,
+        tx.feeSolEquivalent || null,
+        tx.status || 'pending',
+        tx.ipAddress || null,
+      ]);
+      return result.rows[0] || null;
+    },
+    { operation: 'recordTransaction', retries: 3 }
+  ); // Transactions are critical
 }
 
 /**
  * Update transaction status
  */
 async function updateTransactionStatus(quoteId, status, signature = null, errorMessage = null) {
-  return withDb(async (p) => {
-    const query = `
+  return withDb(
+    async (p) => {
+      const query = `
       UPDATE transactions
       SET status = $2,
           signature = COALESCE($3, signature),
@@ -469,39 +480,44 @@ async function updateTransactionStatus(quoteId, status, signature = null, errorM
       WHERE quote_id = $1
       RETURNING *
     `;
-    const result = await p.query(query, [quoteId, status, signature, errorMessage]);
-    return result.rows[0] || null;
-  }, { operation: 'updateTransactionStatus', retries: 3 });
+      const result = await p.query(query, [quoteId, status, signature, errorMessage]);
+      return result.rows[0] || null;
+    },
+    { operation: 'updateTransactionStatus', retries: 3 }
+  );
 }
 
 /**
  * Get transaction history
  */
 async function getTransactionHistory(limit = 50, offset = 0, status = null) {
-  return withDb(async (p) => {
-    let query = 'SELECT * FROM transactions';
-    let countQuery = 'SELECT COUNT(*) FROM transactions';
-    const params = [];
-
-    if (status) {
-      query += ' WHERE status = $1';
-      countQuery += ' WHERE status = $1';
-      params.push(status);
-    }
-
-    query += ` ORDER BY created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
-    params.push(limit, offset);
-
-    const [txs, countResult] = await Promise.all([
-      p.query(query, params),
-      p.query(countQuery, status ? [status] : []),
-    ]);
+  return withDb(
+    async (p) => {
+      let query = 'SELECT * FROM transactions';
+      let countQuery = 'SELECT COUNT(*) FROM transactions';
+      const params = [];
+
+      if (status) {
+        query += ' WHERE status = $1';
+        countQuery += ' WHERE status = $1';
+        params.push(status);
+      }
 
-    return {
-      transactions: txs.rows,
-      total: parseInt(countResult.rows[0].count),
-    };
-  }, { operation: 'getTransactionHistory', fallback: { transactions: [], total: 0 } });
+      query += ` ORDER BY created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
+      params.push(limit, offset);
+
+      const [txs, countResult] = await Promise.all([
+        p.query(query, params),
+        p.query(countQuery, status ? [status] : []),
+      ]);
+
+      return {
+        transactions: txs.rows,
+        total: parseInt(countResult.rows[0].count),
+      };
+    },
+    { operation: 'getTransactionHistory', fallback: { transactions: [], total: 0 } }
+  );
 }
 
 // =============================================================================
@@ -512,8 +528,9 @@ async function getTransactionHistory(limit = 50, offset = 0, status = null) {
  * Update token statistics
  */
 async function updateTokenStats(mint, stats) {
-  return withDb(async (p) => {
-    const query = `
+  return withDb(
+    async (p) => {
+      const query = `
       INSERT INTO token_stats (mint, symbol, name, total_fees_collected, total_transactions, last_used, k_score)
       VALUES ($1, $2, $3, $4, 1, NOW(), $5)
       ON CONFLICT (mint) DO UPDATE SET
@@ -526,28 +543,33 @@ async function updateTokenStats(mint, stats) {
         updated_at = NOW()
       RETURNING *
     `;
-    const result = await p.query(query, [
-      mint,
-      stats.symbol || null,
-      stats.name || null,
-      stats.feeAmount || 0,
-      stats.kScore || 'UNKNOWN',
-    ]);
-    return result.rows[0] || null;
-  }, { operation: 'updateTokenStats' });
+      const result = await p.query(query, [
+        mint,
+        stats.symbol || null,
+        stats.name || null,
+        stats.feeAmount || 0,
+        stats.kScore || 'UNKNOWN',
+      ]);
+      return result.rows[0] || null;
+    },
+    { operation: 'updateTokenStats' }
+  );
 }
 
 /**
  * Get token leaderboard
  */
 async function getTokenLeaderboard(limit = 20) {
-  return withDb(async (p) => {
-    const result = await p.query(
-      'SELECT * FROM token_stats ORDER BY total_transactions DESC LIMIT $1',
-      [limit]
-    );
-    return result.rows;
-  }, { operation: 'getTokenLeaderboard', fallback: [] });
+  return withDb(
+    async (p) => {
+      const result = await p.query(
+        'SELECT * FROM token_stats ORDER BY total_transactions DESC LIMIT $1',
+        [limit]
+      );
+      return result.rows;
+    },
+    { operation: 'getTokenLeaderboard', fallback: [] }
+  );
 }
 
 // =============================================================================
@@ -558,51 +580,57 @@ async function getTokenLeaderboard(limit = 20) {
  * Add audit log entry
  */
 async function addAuditLog(event) {
-  return withDb(async (p) => {
-    const query = `
+  return withDb(
+    async (p) => {
+      const query = `
       INSERT INTO audit_log (event_type, event_data, wallet, ip_address, severity)
       VALUES ($1, $2, $3, $4, $5)
       RETURNING id
     `;
-    const result = await p.query(query, [
-      event.type,
-      JSON.stringify(event.data || {}),
-      event.wallet || null,
-      event.ipAddress || null,
-      event.severity || 'INFO',
-    ]);
-    return result.rows[0]?.id || null;
-  }, { operation: 'addAuditLog' }); // Audit logs are nice-to-have, no extra retries
+      const result = await p.query(query, [
+        event.type,
+        JSON.stringify(event.data || {}),
+        event.wallet || null,
+        event.ipAddress || null,
+        event.severity || 'INFO',
+      ]);
+      return result.rows[0]?.id || null;
+    },
+    { operation: 'addAuditLog' }
+  ); // Audit logs are nice-to-have, no extra retries
 }
 
 /**
  * Get audit logs
  */
 async function getAuditLogs(limit = 100, offset = 0, eventType = null) {
-  return withDb(async (p) => {
-    let query = 'SELECT * FROM audit_log';
-    let countQuery = 'SELECT COUNT(*) FROM audit_log';
-    const params = [];
-
-    if (eventType) {
-      query += ' WHERE event_type = $1';
-      countQuery += ' WHERE event_type = $1';
-      params.push(eventType);
-    }
-
-    query += ` ORDER BY created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
-    params.push(limit, offset);
-
-    const [logs, countResult] = await Promise.all([
-      p.query(query, params),
-      p.query(countQuery, eventType ? [eventType] : []),
-    ]);
+  return withDb(
+    async (p) => {
+      let query = 'SELECT * FROM audit_log';
+      let countQuery = 'SELECT COUNT(*) FROM audit_log';
+      const params = [];
+
+      if (eventType) {
+        query += ' WHERE event_type = $1';
+        countQuery += ' WHERE event_type = $1';
+        params.push(eventType);
+      }
 
-    return {
-      logs: logs.rows,
-      total: parseInt(countResult.rows[0].count),
-    };
-  }, { operation: 'getAuditLogs', fallback: { logs: [], total: 0 } });
+      query += ` ORDER BY created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
+      params.push(limit, offset);
+
+      const [logs, countResult] = await Promise.all([
+        p.query(query, params),
+        p.query(countQuery, eventType ? [eventType] : []),
+      ]);
+
+      return {
+        logs: logs.rows,
+        total: parseInt(countResult.rows[0].count),
+      };
+    },
+    { operation: 'getAuditLogs', fallback: { logs: [], total: 0 } }
+  );
 }
 
 // =============================================================================
@@ -615,8 +643,9 @@ async function getAuditLogs(limit = 100, offset = 0, eventType = null) {
 async function updateDailyStats(stats) {
   const today = new Date().toISOString().split('T')[0];
 
-  return withDb(async (p) => {
-    const query = `
+  return withDb(
+    async (p) => {
+      const query = `
       INSERT INTO daily_stats (date, total_burns, total_transactions, unique_wallets, total_fees_sol, treasury_balance)
       VALUES ($1, $2, $3, $4, $5, $6)
       ON CONFLICT (date) DO UPDATE SET
@@ -627,29 +656,31 @@ async function updateDailyStats(stats) {
         treasury_balance = EXCLUDED.treasury_balance
       RETURNING *
     `;
-    const result = await p.query(query, [
-      today,
-      stats.burns || 0,
-      stats.transactions || 0,
-      stats.uniqueWallets || 0,
-      stats.feesSol || 0,
-      stats.treasuryBalance || 0,
-    ]);
-    return result.rows[0] || null;
-  }, { operation: 'updateDailyStats' });
+      const result = await p.query(query, [
+        today,
+        stats.burns || 0,
+        stats.transactions || 0,
+        stats.uniqueWallets || 0,
+        stats.feesSol || 0,
+        stats.treasuryBalance || 0,
+      ]);
+      return result.rows[0] || null;
+    },
+    { operation: 'updateDailyStats' }
+  );
 }
 
 /**
  * Get daily stats for chart
  */
 async function getDailyStatsHistory(days = 30) {
-  return withDb(async (p) => {
-    const result = await p.query(
-      'SELECT * FROM daily_stats ORDER BY date DESC LIMIT $1',
-      [days]
-    );
-    return result.rows.reverse(); // Oldest first for charts
-  }, { operation: 'getDailyStatsHistory', fallback: [] });
+  return withDb(
+    async (p) => {
+      const result = await p.query('SELECT * FROM daily_stats ORDER BY date DESC LIMIT $1', [days]);
+      return result.rows.reverse(); // Oldest first for charts
+    },
+    { operation: 'getDailyStatsHistory', fallback: [] }
+  );
 }
 
 // =============================================================================
@@ -660,10 +691,11 @@ async function getDailyStatsHistory(days = 30) {
  * Get comprehensive analytics
  */
 async function getAnalytics() {
-  return withDb(async (p) => {
-    const [burns, txs, tokens, dailyStats] = await Promise.all([
-      getBurnStats(),
-      p.query(`
+  return withDb(
+    async (p) => {
+      const [burns, txs, tokens, dailyStats] = await Promise.all([
+        getBurnStats(),
+        p.query(`
         SELECT
           COUNT(*) as total,
           COUNT(*) FILTER (WHERE status = 'confirmed') as confirmed,
@@ -671,17 +703,19 @@ async function getAnalytics() {
           COUNT(*) FILTER (WHERE status = 'pending') as pending
         FROM transactions
       `),
-      p.query('SELECT COUNT(*) FROM token_stats'),
-      p.query('SELECT * FROM daily_stats ORDER BY date DESC LIMIT 7'),
-    ]);
-
-    return {
-      burns,
-      transactions: txs.rows[0],
-      uniqueTokens: parseInt(tokens.rows[0].count),
-      weeklyStats: dailyStats.rows,
-    };
-  }, { operation: 'getAnalytics' });
+        p.query('SELECT COUNT(*) FROM token_stats'),
+        p.query('SELECT * FROM daily_stats ORDER BY date DESC LIMIT 7'),
+      ]);
+
+      return {
+        burns,
+        transactions: txs.rows[0],
+        uniqueTokens: parseInt(tokens.rows[0].count),
+        weeklyStats: dailyStats.rows,
+      };
+    },
+    { operation: 'getAnalytics' }
+  );
 }
 
 /**
diff --git a/src/utils/fetch-timeout.js b/src/utils/fetch-timeout.js
index 0a7b651..57cbecd 100644
--- a/src/utils/fetch-timeout.js
+++ b/src/utils/fetch-timeout.js
@@ -6,10 +6,10 @@
 const logger = require('./logger');
 
 // Default timeouts (in milliseconds)
-const DEFAULT_TIMEOUT = 10_000;      // 10 seconds for general requests
-const JUPITER_TIMEOUT = 15_000;      // 15 seconds for Jupiter API (can be slow)
-const WEBHOOK_TIMEOUT = 5_000;       // 5 seconds for webhooks
-const HEALTH_CHECK_TIMEOUT = 3_000;  // 3 seconds for health checks
+const DEFAULT_TIMEOUT = 10_000; // 10 seconds for general requests
+const JUPITER_TIMEOUT = 15_000; // 15 seconds for Jupiter API (can be slow)
+const WEBHOOK_TIMEOUT = 5_000; // 5 seconds for webhooks
+const HEALTH_CHECK_TIMEOUT = 3_000; // 3 seconds for health checks
 
 /**
  * Fetch with timeout protection
@@ -91,10 +91,7 @@ function timeoutPromise(ms, operation = 'Operation') {
  * @returns {Promise<T>}
  */
 async function withTimeout(promise, ms, operation = 'Operation') {
-  return Promise.race([
-    promise,
-    timeoutPromise(ms, operation),
-  ]);
+  return Promise.race([promise, timeoutPromise(ms, operation)]);
 }
 
 /**
diff --git a/src/utils/metrics.js b/src/utils/metrics.js
index e212b7b..0a0fa68 100644
--- a/src/utils/metrics.js
+++ b/src/utils/metrics.js
@@ -34,16 +34,17 @@ class Counter {
   }
 
   getKey(labelsObj) {
-    return this.labels.map(l => labelsObj[l] || '').join('|');
+    return this.labels.map((l) => labelsObj[l] || '').join('|');
   }
 
   collect() {
     const lines = [`# HELP ${this.name} ${this.help}`, `# TYPE ${this.name} counter`];
     for (const [key, value] of this.values) {
       const labelValues = key.split('|');
-      const labelStr = this.labels.length > 0
-        ? `{${this.labels.map((l, i) => `${l}="${labelValues[i]}"`).join(',')}}`
-        : '';
+      const labelStr =
+        this.labels.length > 0
+          ? `{${this.labels.map((l, i) => `${l}="${labelValues[i]}"`).join(',')}}`
+          : '';
       lines.push(`${this.name}${labelStr} ${value}`);
     }
     return lines.join('\n');
@@ -76,16 +77,17 @@ class Gauge {
   }
 
   getKey(labelsObj) {
-    return this.labels.map(l => labelsObj[l] || '').join('|');
+    return this.labels.map((l) => labelsObj[l] || '').join('|');
   }
 
   collect() {
     const lines = [`# HELP ${this.name} ${this.help}`, `# TYPE ${this.name} gauge`];
     for (const [key, value] of this.values) {
       const labelValues = key.split('|');
-      const labelStr = this.labels.length > 0
-        ? `{${this.labels.map((l, i) => `${l}="${labelValues[i]}"`).join(',')}}`
-        : '';
+      const labelStr =
+        this.labels.length > 0
+          ? `{${this.labels.map((l, i) => `${l}="${labelValues[i]}"`).join(',')}}`
+          : '';
       lines.push(`${this.name}${labelStr} ${value}`);
     }
     return lines.join('\n');
@@ -105,7 +107,7 @@ class Histogram {
     const key = this.getKey(labelsObj);
     if (!this.observations.has(key)) {
       this.observations.set(key, {
-        buckets: new Map(this.buckets.map(b => [b, 0])),
+        buckets: new Map(this.buckets.map((b) => [b, 0])),
         sum: 0,
         count: 0,
       });
@@ -123,7 +125,7 @@ class Histogram {
   }
 
   getKey(labelsObj) {
-    return this.labels.map(l => labelsObj[l] || '').join('|');
+    return this.labels.map((l) => labelsObj[l] || '').join('|');
   }
 
   collect() {
@@ -131,16 +133,15 @@ class Histogram {
 
     for (const [key, obs] of this.observations) {
       const labelValues = key.split('|');
-      const baseLabelStr = this.labels.length > 0
-        ? this.labels.map((l, i) => `${l}="${labelValues[i]}"`).join(',')
-        : '';
+      const baseLabelStr =
+        this.labels.length > 0
+          ? this.labels.map((l, i) => `${l}="${labelValues[i]}"`).join(',')
+          : '';
 
       let cumulative = 0;
       for (const bucket of this.buckets) {
         cumulative += obs.buckets.get(bucket);
-        const labelStr = baseLabelStr
-          ? `{${baseLabelStr},le="${bucket}"}`
-          : `{le="${bucket}"}`;
+        const labelStr = baseLabelStr ? `{${baseLabelStr},le="${bucket}"}` : `{le="${bucket}"}`;
         lines.push(`${this.name}_bucket${labelStr} ${cumulative}`);
       }
 
@@ -161,23 +162,13 @@ class Histogram {
 // =============================================================================
 
 // Request counters
-const quotesTotal = new Counter(
-  'gasdf_quotes_total',
-  'Total number of quote requests',
-  ['status']
-);
+const quotesTotal = new Counter('gasdf_quotes_total', 'Total number of quote requests', ['status']);
 
-const submitsTotal = new Counter(
-  'gasdf_submits_total',
-  'Total number of submit requests',
-  ['status']
-);
+const submitsTotal = new Counter('gasdf_submits_total', 'Total number of submit requests', [
+  'status',
+]);
 
-const burnsTotal = new Counter(
-  'gasdf_burns_total',
-  'Total number of burn operations',
-  ['status']
-);
+const burnsTotal = new Counter('gasdf_burns_total', 'Total number of burn operations', ['status']);
 
 // Gauges
 const feePayerBalance = new Gauge(
@@ -192,11 +183,7 @@ const pendingSwapAmount = new Gauge(
   []
 );
 
-const activeQuotes = new Gauge(
-  'gasdf_active_quotes',
-  'Number of active quotes',
-  []
-);
+const activeQuotes = new Gauge('gasdf_active_quotes', 'Number of active quotes', []);
 
 const circuitBreakerState = new Gauge(
   'gasdf_circuit_breaker_state',
@@ -220,11 +207,11 @@ const submitDuration = new Histogram(
 );
 
 // HTTP request metrics
-const httpRequestsTotal = new Counter(
-  'gasdf_http_requests_total',
-  'Total HTTP requests',
-  ['method', 'path', 'status']
-);
+const httpRequestsTotal = new Counter('gasdf_http_requests_total', 'Total HTTP requests', [
+  'method',
+  'path',
+  'status',
+]);
 
 const httpRequestDuration = new Histogram(
   'gasdf_http_request_duration_seconds',
diff --git a/src/utils/redis.js b/src/utils/redis.js
index a209747..6d603c9 100644
--- a/src/utils/redis.js
+++ b/src/utils/redis.js
@@ -59,7 +59,10 @@ const memoryStore = {
     }
 
     if (deleted > 0) {
-      logger.debug('REDIS', `Memory store cleanup: removed ${deleted} expired entries, ${this.data.size} remaining`);
+      logger.debug(
+        'REDIS',
+        `Memory store cleanup: removed ${deleted} expired entries, ${this.data.size} remaining`
+      );
     }
   },
 };
@@ -402,7 +405,7 @@ async function getTreasuryHistory(limit = 20) {
   return withRedis(
     async (redis) => {
       const history = await redis.lRange(`${KEY_PREFIX}treasury:history`, 0, limit - 1);
-      return history.map(h => JSON.parse(h));
+      return history.map((h) => JSON.parse(h));
     },
     () => []
   );
@@ -475,7 +478,7 @@ async function claimTransactionSlot(txHash) {
       // Returns 'OK' if set, null if key already exists
       const result = await redis.set(key, Date.now().toString(), {
         NX: true,
-        EX: TX_HASH_TTL_SECONDS
+        EX: TX_HASH_TTL_SECONDS,
       });
       return { claimed: result === 'OK' };
     },
@@ -570,7 +573,7 @@ async function appendAuditLog(events) {
 
   return withRedis(
     async (redis) => {
-      const serialized = events.map(e => JSON.stringify(e));
+      const serialized = events.map((e) => JSON.stringify(e));
       await redis.lPush(AUDIT_KEY, ...serialized);
       await redis.lTrim(AUDIT_KEY, 0, MAX_AUDIT_ENTRIES - 1);
       await redis.expire(AUDIT_KEY, AUDIT_TTL_SECONDS);
@@ -588,7 +591,7 @@ async function getAuditLog(limit = 100, offset = 0) {
   return withRedis(
     async (redis) => {
       const entries = await redis.lRange(AUDIT_KEY, offset, offset + limit - 1);
-      return entries.map(e => JSON.parse(e));
+      return entries.map((e) => JSON.parse(e));
     },
     () => []
   );
@@ -603,8 +606,8 @@ async function searchAuditLog(eventType, limit = 100) {
       // Get all entries and filter (not efficient for large logs, but simple)
       const entries = await redis.lRange(AUDIT_KEY, 0, 999);
       return entries
-        .map(e => JSON.parse(e))
-        .filter(e => e.type === eventType)
+        .map((e) => JSON.parse(e))
+        .filter((e) => e.type === eventType)
         .slice(0, limit);
     },
     () => []
@@ -678,7 +681,9 @@ async function getBurnLeaderboard(limit = 50) {
   return withRedis(
     async (redis) => {
       // Get top wallets with scores
-      const results = await redis.zRangeWithScores(`${KEY_PREFIX}burn:leaderboard`, 0, limit - 1, { REV: true });
+      const results = await redis.zRangeWithScores(`${KEY_PREFIX}burn:leaderboard`, 0, limit - 1, {
+        REV: true,
+      });
       return results.map((entry, index) => ({
         rank: index + 1,
         wallet: entry.value,
@@ -768,7 +773,7 @@ async function getBurnProofs(limit = 50) {
         redis.get(`${KEY_PREFIX}burn:proof:count`),
       ]);
       return {
-        proofs: proofs.map(p => JSON.parse(p)),
+        proofs: proofs.map((p) => JSON.parse(p)),
         totalCount: parseInt(totalCount) || 0,
       };
     },
@@ -970,7 +975,11 @@ async function withLock(lockName, fn, ttlSeconds = 60) {
   const token = await acquireLock(lockName, ttlSeconds);
 
   if (!token) {
-    return { success: false, error: 'LOCK_HELD', message: `Lock ${lockName} is held by another process` };
+    return {
+      success: false,
+      error: 'LOCK_HELD',
+      message: `Lock ${lockName} is held by another process`,
+    };
   }
 
   try {
@@ -1121,10 +1130,7 @@ async function calculateVelocityBasedBuffer(bufferHours = 2, minBufferLamports =
 
   // Calculate required buffer: (txPerHour  avgCost)  bufferHours
   const hourlyBurn = velocity.txPerHour * velocity.avgCost;
-  const requiredBuffer = Math.max(
-    minBufferLamports,
-    Math.ceil(hourlyBurn * bufferHours)
-  );
+  const requiredBuffer = Math.max(minBufferLamports, Math.ceil(hourlyBurn * bufferHours));
 
   // Target is 100x the required buffer (~1 week runway at steady state)
   // Minimizes refill frequency  less gas wasted on refill tx
diff --git a/src/utils/revenue-channels.js b/src/utils/revenue-channels.js
index 95d9b70..c72be3c 100644
--- a/src/utils/revenue-channels.js
+++ b/src/utils/revenue-channels.js
@@ -72,34 +72,34 @@
 
 // Revenue source types
 const REVENUE_SOURCE = {
-  FEE_ASDF: 'fee_asdf',     // User paid fee in $ASDF
-  FEE_TOKEN: 'fee_token',   // User paid fee in other token
+  FEE_ASDF: 'fee_asdf', // User paid fee in $ASDF
+  FEE_TOKEN: 'fee_token', // User paid fee in other token
 };
 
 // Processing channels
 const CHANNEL = {
-  PURIST: 'purist',         // $ASDF  100% burn
-  UNIFIED: 'unified',       // Token  $ASDF  burn/treasury split
+  PURIST: 'purist', // $ASDF  100% burn
+  UNIFIED: 'unified', // Token  $ASDF  burn/treasury split
 };
 
 // Burn types
 const BURN_TYPE = {
-  DIRECT: 'burn_direct',       // $ASDF burned directly (purist)
-  SWAP: 'burn_swap',           // $ASDF burned from swap (unified)
+  DIRECT: 'burn_direct', // $ASDF burned directly (purist)
+  SWAP: 'burn_swap', // $ASDF burned from swap (unified)
   ECOSYSTEM: 'burn_ecosystem', // Token burned directly (flywheel)
 };
 
 // Treasury event types
 const TREASURY_EVENT = {
-  RETAIN: 'treasury_retain',   // $ASDF kept from unified channel
-  REFILL: 'treasury_refill',   // $ASDF  SOL for fee payer
+  RETAIN: 'treasury_retain', // $ASDF kept from unified channel
+  REFILL: 'treasury_refill', // $ASDF  SOL for fee payer
 };
 
 // Proof/record types for transparency
 const PROOF_TYPE = {
-  BURN_BATCH: 'burn_batch',           // Batched burn transaction
-  SWAP_TO_ASDF: 'swap_to_asdf',       // Token  $ASDF swap
-  TREASURY_SWAP: 'treasury_swap',     // $ASDF  SOL for operations
+  BURN_BATCH: 'burn_batch', // Batched burn transaction
+  SWAP_TO_ASDF: 'swap_to_asdf', // Token  $ASDF swap
+  TREASURY_SWAP: 'treasury_swap', // $ASDF  SOL for operations
 };
 
 /**
@@ -124,7 +124,7 @@ function createRevenueEvent({
       symbol: tokenSymbol,
       amount: inputAmount,
     },
-    burns: burns.map(b => ({
+    burns: burns.map((b) => ({
       type: b.type,
       mint: b.mint,
       amount: b.amount,
@@ -162,7 +162,7 @@ function calculateFlowDistribution(amount, ecosystemBurnPct = 0, burnRatio = 0.7
     totals: {
       burned: ecosystemBurn + burnFromSwap,
       treasury: treasuryRetain,
-      burnPercent: ((ecosystemBurn + burnFromSwap) / amount * 100).toFixed(1),
+      burnPercent: (((ecosystemBurn + burnFromSwap) / amount) * 100).toFixed(1),
     },
   };
 }
diff --git a/src/utils/rpc.js b/src/utils/rpc.js
index b524643..e49a2fd 100644
--- a/src/utils/rpc.js
+++ b/src/utils/rpc.js
@@ -8,9 +8,9 @@ const { CircuitBreaker } = require('./circuit-breaker');
 const { withTimeout } = require('./fetch-timeout');
 
 // RPC operation timeouts (prevents hanging on slow/unresponsive RPC)
-const RPC_SIMULATION_TIMEOUT = 30_000;  // 30 seconds for simulation
-const RPC_SEND_TIMEOUT = 15_000;        // 15 seconds for send
-const RPC_QUERY_TIMEOUT = 10_000;       // 10 seconds for queries
+const RPC_SIMULATION_TIMEOUT = 30_000; // 30 seconds for simulation
+const RPC_SEND_TIMEOUT = 15_000; // 15 seconds for send
+const RPC_QUERY_TIMEOUT = 10_000; // 10 seconds for queries
 
 // =============================================================================
 // Rate Limit Tracking (Proactive backoff before 429)
@@ -19,25 +19,25 @@ const RPC_QUERY_TIMEOUT = 10_000;       // 10 seconds for queries
 class RateLimitTracker {
   constructor(endpointName) {
     this.endpointName = endpointName;
-    this.limit = null;           // x-ratelimit-limit-requests
-    this.remaining = null;       // x-ratelimit-remaining-requests
-    this.resetAt = null;         // When limit resets (timestamp)
+    this.limit = null; // x-ratelimit-limit-requests
+    this.remaining = null; // x-ratelimit-remaining-requests
+    this.resetAt = null; // When limit resets (timestamp)
     this.lastUpdated = 0;
 
     // Thresholds for proactive backoff
-    this.warningThreshold = 0.2;  // Start slowing at 20% remaining
+    this.warningThreshold = 0.2; // Start slowing at 20% remaining
     this.criticalThreshold = 0.05; // Heavy backoff at 5% remaining
 
     // 429 tracking (fallback when headers aren't available)
-    this.recent429s = [];         // Timestamps of recent 429 errors
-    this.consecutive429s = 0;     // Count of consecutive 429s
-    this.last429At = null;        // Last 429 timestamp
-    this.backoffUntil = null;     // Don't make requests until this time
-    this.requestsSince429 = 0;    // Successful requests since last 429
+    this.recent429s = []; // Timestamps of recent 429 errors
+    this.consecutive429s = 0; // Count of consecutive 429s
+    this.last429At = null; // Last 429 timestamp
+    this.backoffUntil = null; // Don't make requests until this time
+    this.requestsSince429 = 0; // Successful requests since last 429
 
     // 429 backoff configuration
-    this.baseBackoffMs = 1000;    // Start with 1 second
-    this.maxBackoffMs = 30000;    // Cap at 30 seconds
+    this.baseBackoffMs = 1000; // Start with 1 second
+    this.maxBackoffMs = 30000; // Cap at 30 seconds
     this.recoveryWindow = 60000; // Forget 429s after 60 seconds of success
   }
 
@@ -52,7 +52,7 @@ class RateLimitTracker {
     this.requestsSince429 = 0;
 
     // Clean old 429s (keep last 60 seconds)
-    this.recent429s = this.recent429s.filter(t => now - t < this.recoveryWindow);
+    this.recent429s = this.recent429s.filter((t) => now - t < this.recoveryWindow);
 
     // Calculate exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (capped)
     const backoffMs = Math.min(
@@ -96,18 +96,17 @@ class RateLimitTracker {
 
   update(headers) {
     // Helius rate limit headers (may not be present)
-    const limit = headers.get('x-ratelimit-limit-requests') ||
-                  headers.get('x-ratelimit-limit');
-    const remaining = headers.get('x-ratelimit-remaining-requests') ||
-                      headers.get('x-ratelimit-remaining');
-    const resetSeconds = headers.get('x-ratelimit-reset-requests') ||
-                         headers.get('x-ratelimit-reset');
+    const limit = headers.get('x-ratelimit-limit-requests') || headers.get('x-ratelimit-limit');
+    const remaining =
+      headers.get('x-ratelimit-remaining-requests') || headers.get('x-ratelimit-remaining');
+    const resetSeconds =
+      headers.get('x-ratelimit-reset-requests') || headers.get('x-ratelimit-reset');
 
     if (limit) this.limit = parseInt(limit, 10);
     if (remaining) this.remaining = parseInt(remaining, 10);
     if (resetSeconds) {
       const resetValue = parseFloat(resetSeconds);
-      this.resetAt = resetValue > 1e9 ? resetValue * 1000 : Date.now() + (resetValue * 1000);
+      this.resetAt = resetValue > 1e9 ? resetValue * 1000 : Date.now() + resetValue * 1000;
     }
 
     this.lastUpdated = Date.now();
@@ -179,8 +178,8 @@ class RateLimitTracker {
         return 1000;
       }
 
-      const backoffFactor = 1 - (percentRemaining / this.warningThreshold);
-      return Math.floor(100 + (backoffFactor * 400));
+      const backoffFactor = 1 - percentRemaining / this.warningThreshold;
+      return Math.floor(100 + backoffFactor * 400);
     }
 
     // Priority 3: Preventive slowdown if we've had recent 429s
@@ -237,7 +236,7 @@ function createRateLimitAwareFetch(endpointName) {
         isIn429Backoff: tracker.isIn429Backoff(),
         consecutive429s: tracker.consecutive429s,
       });
-      await new Promise(resolve => setTimeout(resolve, backoffDelay));
+      await new Promise((resolve) => setTimeout(resolve, backoffDelay));
     }
 
     // Make the actual request
@@ -285,13 +284,15 @@ class RpcEndpoint {
       resetTimeout: 15000, // 15 seconds
       isFailure: (error) => {
         const msg = error.message?.toLowerCase() || '';
-        return msg.includes('timeout') ||
-               msg.includes('econnrefused') ||
-               msg.includes('enotfound') ||
-               msg.includes('service unavailable') ||
-               msg.includes('429') ||
-               msg.includes('too many requests') ||
-               msg.includes('failed to fetch');
+        return (
+          msg.includes('timeout') ||
+          msg.includes('econnrefused') ||
+          msg.includes('enotfound') ||
+          msg.includes('service unavailable') ||
+          msg.includes('429') ||
+          msg.includes('too many requests') ||
+          msg.includes('failed to fetch')
+        );
       },
     });
   }
@@ -357,9 +358,10 @@ class RpcEndpoint {
   }
 
   getStatus() {
-    const successRate = this.health.totalRequests > 0
-      ? ((this.health.successfulRequests / this.health.totalRequests) * 100).toFixed(1)
-      : 0;
+    const successRate =
+      this.health.totalRequests > 0
+        ? ((this.health.successfulRequests / this.health.totalRequests) * 100).toFixed(1)
+        : 0;
 
     const status = {
       name: this.name,
@@ -397,9 +399,10 @@ class RpcPool {
     if (this.initialized) return;
 
     // Detect mainnet from config or explicit RPC_URL
-    const isMainnet = config.NETWORK === 'mainnet' ||
-                      config.USE_MAINNET ||
-                      (config.RPC_URL && config.RPC_URL.includes('mainnet'));
+    const isMainnet =
+      config.NETWORK === 'mainnet' ||
+      config.USE_MAINNET ||
+      (config.RPC_URL && config.RPC_URL.includes('mainnet'));
     const heliusKey = config.HELIUS_API_KEY;
 
     // Build endpoint list based on available config
@@ -441,7 +444,7 @@ class RpcPool {
     this.endpoints.sort((a, b) => a.priority - b.priority);
 
     logger.info('RPC_POOL', 'Initialized', {
-      endpoints: this.endpoints.map(e => e.name),
+      endpoints: this.endpoints.map((e) => e.name),
       primary: this.endpoints[0]?.name,
     });
 
@@ -449,7 +452,7 @@ class RpcPool {
   }
 
   getHealthyEndpoints() {
-    return this.endpoints.filter(e => e.isHealthy());
+    return this.endpoints.filter((e) => e.isHealthy());
   }
 
   getPrimaryEndpoint() {
@@ -521,11 +524,16 @@ class RpcPool {
     const primary = this.getPrimaryEndpoint();
 
     return {
-      status: healthyCount === 0 ? 'CRITICAL' : healthyCount < this.endpoints.length ? 'DEGRADED' : 'HEALTHY',
+      status:
+        healthyCount === 0
+          ? 'CRITICAL'
+          : healthyCount < this.endpoints.length
+            ? 'DEGRADED'
+            : 'HEALTHY',
       totalEndpoints: this.endpoints.length,
       healthyEndpoints: healthyCount,
       primary: primary?.name,
-      endpoints: this.endpoints.map(e => e.getStatus()),
+      endpoints: this.endpoints.map((e) => e.getStatus()),
     };
   }
 
@@ -544,12 +552,12 @@ const pool = new RpcPool();
 // =============================================================================
 
 const blockhashCache = {
-  data: null,        // { blockhash, lastValidBlockHeight }
-  fetchedAt: 0,      // Timestamp when fetched
-  ttlMs: 30_000,     // 30s TTL (blockhash valid ~60s, so 30s is safe)
+  data: null, // { blockhash, lastValidBlockHeight }
+  fetchedAt: 0, // Timestamp when fetched
+  ttlMs: 30_000, // 30s TTL (blockhash valid ~60s, so 30s is safe)
 
   isValid() {
-    return this.data && (Date.now() - this.fetchedAt) < this.ttlMs;
+    return this.data && Date.now() - this.fetchedAt < this.ttlMs;
   },
 
   set(blockhashInfo) {
@@ -616,30 +624,24 @@ function invalidateBlockhashCache() {
 }
 
 async function sendTransaction(signedTx) {
-  return pool.executeWithFailover(
-    async (conn) => {
-      const signature = await conn.sendRawTransaction(signedTx.serialize(), {
-        skipPreflight: false,
-        preflightCommitment: 'confirmed',
-        maxRetries: 3,
-      });
-      return signature;
-    },
-    'sendTransaction'
-  );
+  return pool.executeWithFailover(async (conn) => {
+    const signature = await conn.sendRawTransaction(signedTx.serialize(), {
+      skipPreflight: false,
+      preflightCommitment: 'confirmed',
+      maxRetries: 3,
+    });
+    return signature;
+  }, 'sendTransaction');
 }
 
 async function confirmTransaction(signature, blockhash, lastValidBlockHeight) {
-  return pool.executeWithFailover(
-    async (conn) => {
-      const result = await conn.confirmTransaction(
-        { signature, blockhash, lastValidBlockHeight },
-        'confirmed'
-      );
-      return result;
-    },
-    'confirmTransaction'
-  );
+  return pool.executeWithFailover(async (conn) => {
+    const result = await conn.confirmTransaction(
+      { signature, blockhash, lastValidBlockHeight },
+      'confirmed'
+    );
+    return result;
+  }, 'confirmTransaction');
 }
 
 /**
@@ -664,7 +666,8 @@ async function checkSignatureStatus(signature, maxRetries = 3, retryDelayMs = 10
         // Transaction found
         const status = result.value;
         return {
-          confirmed: status.confirmationStatus === 'confirmed' || status.confirmationStatus === 'finalized',
+          confirmed:
+            status.confirmationStatus === 'confirmed' || status.confirmationStatus === 'finalized',
           slot: status.slot,
           err: status.err,
           confirmationStatus: status.confirmationStatus,
@@ -673,7 +676,7 @@ async function checkSignatureStatus(signature, maxRetries = 3, retryDelayMs = 10
 
       // Not found yet, retry
       if (attempt < maxRetries - 1) {
-        await new Promise(resolve => setTimeout(resolve, retryDelayMs));
+        await new Promise((resolve) => setTimeout(resolve, retryDelayMs));
       }
     } catch (error) {
       logger.debug('RPC', 'Signature status check failed', {
@@ -683,7 +686,7 @@ async function checkSignatureStatus(signature, maxRetries = 3, retryDelayMs = 10
       });
 
       if (attempt < maxRetries - 1) {
-        await new Promise(resolve => setTimeout(resolve, retryDelayMs));
+        await new Promise((resolve) => setTimeout(resolve, retryDelayMs));
       }
     }
   }
@@ -692,10 +695,7 @@ async function checkSignatureStatus(signature, maxRetries = 3, retryDelayMs = 10
 }
 
 async function getBalance(pubkey) {
-  return pool.executeWithFailover(
-    async (conn) => conn.getBalance(pubkey),
-    'getBalance'
-  );
+  return pool.executeWithFailover(async (conn) => conn.getBalance(pubkey), 'getBalance');
 }
 
 /**
@@ -716,37 +716,31 @@ async function getMultipleBalances(pubkeys) {
     return new Map([[pubkeys[0].toBase58(), balance]]);
   }
 
-  return pool.executeWithFailover(
-    async (conn) => {
-      // Build batch RPC request using getMultipleAccounts
-      // This is more efficient than individual getBalance calls
-      const accounts = await conn.getMultipleAccountsInfo(pubkeys, 'confirmed');
+  return pool.executeWithFailover(async (conn) => {
+    // Build batch RPC request using getMultipleAccounts
+    // This is more efficient than individual getBalance calls
+    const accounts = await conn.getMultipleAccountsInfo(pubkeys, 'confirmed');
 
-      const results = new Map();
-      for (let i = 0; i < pubkeys.length; i++) {
-        const pubkey = pubkeys[i].toBase58();
-        const account = accounts[i];
-        // Account exists: return lamports. Account doesn't exist: 0
-        results.set(pubkey, account ? account.lamports : 0);
-      }
+    const results = new Map();
+    for (let i = 0; i < pubkeys.length; i++) {
+      const pubkey = pubkeys[i].toBase58();
+      const account = accounts[i];
+      // Account exists: return lamports. Account doesn't exist: 0
+      results.set(pubkey, account ? account.lamports : 0);
+    }
 
-      return results;
-    },
-    'getMultipleBalances'
-  );
+    return results;
+  }, 'getMultipleBalances');
 }
 
 async function getTokenBalance(pubkey, mint) {
-  return pool.executeWithFailover(
-    async (conn) => {
-      const tokenAccounts = await conn.getTokenAccountsByOwner(pubkey, { mint });
-      if (tokenAccounts.value.length === 0) return 0;
-
-      const balance = await conn.getTokenAccountBalance(tokenAccounts.value[0].pubkey);
-      return parseInt(balance.value.amount);
-    },
-    'getTokenBalance'
-  );
+  return pool.executeWithFailover(async (conn) => {
+    const tokenAccounts = await conn.getTokenAccountsByOwner(pubkey, { mint });
+    if (tokenAccounts.value.length === 0) return 0;
+
+    const balance = await conn.getTokenAccountBalance(tokenAccounts.value[0].pubkey);
+    return parseInt(balance.value.amount);
+  }, 'getTokenBalance');
 }
 
 async function isBlockhashValid(blockhash) {
@@ -766,15 +760,12 @@ async function simulateTransaction(signedTx) {
   try {
     // Wrap simulation with timeout to prevent hanging on slow/unresponsive RPC
     const result = await withTimeout(
-      pool.executeWithFailover(
-        async (conn) => {
-          return conn.simulateTransaction(signedTx, {
-            sigVerify: true,
-            commitment: 'confirmed',
-          });
-        },
-        'simulateTransaction'
-      ),
+      pool.executeWithFailover(async (conn) => {
+        return conn.simulateTransaction(signedTx, {
+          sigVerify: true,
+          commitment: 'confirmed',
+        });
+      }, 'simulateTransaction'),
       RPC_SIMULATION_TIMEOUT,
       'simulateTransaction'
     );
@@ -829,19 +820,16 @@ async function simulateWithBalanceCheck(signedTx, feePayerPubkey, expectedMaxSol
     // Simulate the transaction with timeout protection
     // Prevents hanging on slow/unresponsive RPC endpoints
     const result = await withTimeout(
-      pool.executeWithFailover(
-        async (c) => {
-          return c.simulateTransaction(signedTx, {
-            sigVerify: true,
-            commitment: 'confirmed',
-            accounts: {
-              encoding: 'base64',
-              addresses: [feePayerPubkey],
-            },
-          });
-        },
-        'simulateWithBalanceCheck'
-      ),
+      pool.executeWithFailover(async (c) => {
+        return c.simulateTransaction(signedTx, {
+          sigVerify: true,
+          commitment: 'confirmed',
+          accounts: {
+            encoding: 'base64',
+            addresses: [feePayerPubkey],
+          },
+        });
+      }, 'simulateWithBalanceCheck'),
       RPC_SIMULATION_TIMEOUT,
       'simulateWithBalanceCheck'
     );
diff --git a/tests/integration/routes/stats-burns.test.js b/tests/integration/routes/stats-burns.test.js
index 8b902bb..b3b9b7d 100644
--- a/tests/integration/routes/stats-burns.test.js
+++ b/tests/integration/routes/stats-burns.test.js
@@ -12,7 +12,9 @@ jest.mock('@solana/web3.js', () => {
     toBuffer: () => Buffer.from(key || ''),
     equals: () => false,
   }));
-  mockPublicKey.findProgramAddressSync = jest.fn().mockReturnValue([{ toBase58: () => 'PDA' }, 255]);
+  mockPublicKey.findProgramAddressSync = jest
+    .fn()
+    .mockReturnValue([{ toBase58: () => 'PDA' }, 255]);
 
   const mockSystemProgram = {
     programId: { toBase58: () => '11111111111111111111111111111111' },
@@ -80,18 +82,14 @@ describe('Stats & Burns API Routes', () => {
     });
 
     test('should include totalBurns count', async () => {
-      const response = await request(app)
-        .get('/v1/stats/burns')
-        .expect(200);
+      const response = await request(app).get('/v1/stats/burns').expect(200);
 
       expect(response.body).toHaveProperty('totalBurns');
       expect(typeof response.body.totalBurns).toBe('number');
     });
 
     test('should include verification message', async () => {
-      const response = await request(app)
-        .get('/v1/stats/burns')
-        .expect(200);
+      const response = await request(app).get('/v1/stats/burns').expect(200);
 
       expect(response.body).toHaveProperty('verification');
       expect(response.body.verification).toHaveProperty('message');
@@ -99,17 +97,13 @@ describe('Stats & Burns API Routes', () => {
     });
 
     test('should respect limit parameter', async () => {
-      const response = await request(app)
-        .get('/v1/stats/burns?limit=5')
-        .expect(200);
+      const response = await request(app).get('/v1/stats/burns?limit=5').expect(200);
 
       expect(response.body.burns.length).toBeLessThanOrEqual(5);
     });
 
     test('should cap limit at 100', async () => {
-      const response = await request(app)
-        .get('/v1/stats/burns?limit=500')
-        .expect(200);
+      const response = await request(app).get('/v1/stats/burns?limit=500').expect(200);
 
       // Should not exceed max limit
       expect(response.body.burns.length).toBeLessThanOrEqual(100);
@@ -119,18 +113,15 @@ describe('Stats & Burns API Routes', () => {
   describe('GET /v1/stats/burns/:signature', () => {
     test('should return 404 for non-existent signature', async () => {
       // Use a valid-looking signature that doesn't exist (87 chars base58)
-      const fakeSignature = '5XzL8mK9vN2pQ7wR4tU6yH3jF8gC1bD9aE0iO5kM2nP3qS4rT7uV6wX8yZ1aB2cD3eF4gH5iJ6kL7mN8oP9qR0sT';
-      const response = await request(app)
-        .get(`/v1/stats/burns/${fakeSignature}`)
-        .expect(404);
+      const fakeSignature =
+        '5XzL8mK9vN2pQ7wR4tU6yH3jF8gC1bD9aE0iO5kM2nP3qS4rT7uV6wX8yZ1aB2cD3eF4gH5iJ6kL7mN8oP9qR0sT';
+      const response = await request(app).get(`/v1/stats/burns/${fakeSignature}`).expect(404);
 
       expect(response.body).toHaveProperty('error');
     });
 
     test('should return 400 for invalid signature format', async () => {
-      const response = await request(app)
-        .get('/v1/stats/burns/short')
-        .expect(400);
+      const response = await request(app).get('/v1/stats/burns/short').expect(400);
 
       expect(response.body).toHaveProperty('error');
       expect(response.body.error).toContain('Invalid');
@@ -139,18 +130,13 @@ describe('Stats & Burns API Routes', () => {
 
   describe('GET /status', () => {
     test('should return 200 with status', async () => {
-      const response = await request(app)
-        .get('/status')
-        .expect('Content-Type', /json/)
-        .expect(200);
+      const response = await request(app).get('/status').expect('Content-Type', /json/).expect(200);
 
       expect(response.body).toHaveProperty('status');
     });
 
     test('should include components health', async () => {
-      const response = await request(app)
-        .get('/status')
-        .expect(200);
+      const response = await request(app).get('/status').expect(200);
 
       expect(response.body).toHaveProperty('components');
       expect(response.body.components).toHaveProperty('api');
@@ -159,27 +145,21 @@ describe('Stats & Burns API Routes', () => {
     });
 
     test('should include updated_at timestamp', async () => {
-      const response = await request(app)
-        .get('/status')
-        .expect(200);
+      const response = await request(app).get('/status').expect(200);
 
       expect(response.body).toHaveProperty('updated_at');
       expect(new Date(response.body.updated_at)).toBeInstanceOf(Date);
     });
 
     test('should include response_time_ms', async () => {
-      const response = await request(app)
-        .get('/status')
-        .expect(200);
+      const response = await request(app).get('/status').expect(200);
 
       expect(response.body).toHaveProperty('response_time_ms');
       expect(typeof response.body.response_time_ms).toBe('number');
     });
 
     test('should include Upptime-compatible page info', async () => {
-      const response = await request(app)
-        .get('/status')
-        .expect(200);
+      const response = await request(app).get('/status').expect(200);
 
       expect(response.body).toHaveProperty('page');
       expect(response.body.page).toHaveProperty('name');
@@ -187,9 +167,7 @@ describe('Stats & Burns API Routes', () => {
     });
 
     test('should include simple indicators', async () => {
-      const response = await request(app)
-        .get('/status')
-        .expect(200);
+      const response = await request(app).get('/status').expect(200);
 
       expect(response.body).toHaveProperty('indicators');
       expect(response.body.indicators).toHaveProperty('operational');
@@ -200,8 +178,7 @@ describe('Stats & Burns API Routes', () => {
 
   describe('Deprecation headers on legacy routes', () => {
     test('GET /health should include Deprecation header', async () => {
-      const response = await request(app)
-        .get('/health');
+      const response = await request(app).get('/health');
 
       // Health might return 503 in test mode (no Redis) but should still have headers
       expect([200, 503]).toContain(response.status);
@@ -209,17 +186,13 @@ describe('Stats & Burns API Routes', () => {
     });
 
     test('GET /stats should include Sunset header', async () => {
-      const response = await request(app)
-        .get('/stats')
-        .expect(200);
+      const response = await request(app).get('/stats').expect(200);
 
       expect(response.headers).toHaveProperty('sunset');
     });
 
     test('GET /stats should include Link header to v1', async () => {
-      const response = await request(app)
-        .get('/stats')
-        .expect(200);
+      const response = await request(app).get('/stats').expect(200);
 
       expect(response.headers).toHaveProperty('link');
       expect(response.headers.link).toContain('/v1');
@@ -227,9 +200,7 @@ describe('Stats & Burns API Routes', () => {
     });
 
     test('GET /v1/health should NOT include Deprecation header', async () => {
-      const response = await request(app)
-        .get('/v1/health')
-        .expect(200);
+      const response = await request(app).get('/v1/health').expect(200);
 
       expect(response.headers.deprecation).toBeUndefined();
     });
diff --git a/tests/setup.js b/tests/setup.js
index 4785733..24432e3 100644
--- a/tests/setup.js
+++ b/tests/setup.js
@@ -4,9 +4,10 @@
 // Set test environment variables
 process.env.NODE_ENV = 'test';
 process.env.HELIUS_API_KEY = 'test-helius-key';
-process.env.FEE_PAYER_PRIVATE_KEY = '4wBqpZM9xwHtzshcmxqXQKfTu1fnjgPHykLqxGtDFaYvwXLvEv7zgRMy9aVRZpgRdCZh5Qw7BxXhyKDBPfzJML4N';
+process.env.FEE_PAYER_PRIVATE_KEY =
+  '4wBqpZM9xwHtzshcmxqXQKfTu1fnjgPHykLqxGtDFaYvwXLvEv7zgRMy9aVRZpgRdCZh5Qw7BxXhyKDBPfzJML4N';
 process.env.ASDF_MINT = 'ASdfTest111111111111111111111111111111111111';
-process.env.REDIS_URL = '';  // Force memory fallback
+process.env.REDIS_URL = ''; // Force memory fallback
 
 // Suppress console during tests unless DEBUG=true
 if (!process.env.DEBUG) {
@@ -22,7 +23,7 @@ if (!process.env.DEBUG) {
 }
 
 // Global test utilities
-global.waitFor = (ms) => new Promise(resolve => setTimeout(resolve, ms));
+global.waitFor = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
 
 // Clean up after each test
 afterEach(() => {
diff --git a/tests/unit/middleware/validation.test.js b/tests/unit/middleware/validation.test.js
index 672f3af..2b77a83 100644
--- a/tests/unit/middleware/validation.test.js
+++ b/tests/unit/middleware/validation.test.js
@@ -214,7 +214,9 @@ describe('Validation Middleware', () => {
         expect(res.status).toHaveBeenCalledWith(400);
         expect(res.json).toHaveBeenCalledWith(
           expect.objectContaining({
-            details: expect.arrayContaining(['estimatedComputeUnits must be between 1 and 1,400,000']),
+            details: expect.arrayContaining([
+              'estimatedComputeUnits must be between 1 and 1,400,000',
+            ]),
           })
         );
       });
diff --git a/tests/unit/routes/quote.test.js b/tests/unit/routes/quote.test.js
index 2435389..1611465 100644
--- a/tests/unit/routes/quote.test.js
+++ b/tests/unit/routes/quote.test.js
@@ -178,10 +178,7 @@ describe('Quote Route', () => {
     };
 
     it('should return quote for valid request', async () => {
-      const response = await request(app)
-        .post('/quote')
-        .send(validRequest)
-        .expect(200);
+      const response = await request(app).post('/quote').send(validRequest).expect(200);
 
       expect(response.body).toHaveProperty('quoteId');
       expect(response.body).toHaveProperty('feePayer');
@@ -193,10 +190,7 @@ describe('Quote Route', () => {
     });
 
     it('should include payment token info with acceptance reason', async () => {
-      const response = await request(app)
-        .post('/quote')
-        .send(validRequest)
-        .expect(200);
+      const response = await request(app).post('/quote').send(validRequest).expect(200);
 
       expect(response.body.paymentToken).toMatchObject({
         mint: validRequest.paymentToken,
@@ -207,17 +201,13 @@ describe('Quote Route', () => {
     });
 
     it('should check token acceptance via token-gate', async () => {
-      await request(app)
-        .post('/quote')
-        .send(validRequest);
+      await request(app).post('/quote').send(validRequest);
 
       expect(tokenGate.isTokenAccepted).toHaveBeenCalledWith(validRequest.paymentToken);
     });
 
     it('should call jupiter for fee conversion', async () => {
-      await request(app)
-        .post('/quote')
-        .send(validRequest);
+      await request(app).post('/quote').send(validRequest);
 
       expect(jupiter.getFeeInToken).toHaveBeenCalledWith(
         validRequest.paymentToken,
@@ -226,10 +216,7 @@ describe('Quote Route', () => {
     });
 
     it('should store quote in redis', async () => {
-      await request(app)
-        .post('/quote')
-        .send(validRequest)
-        .expect(200);
+      await request(app).post('/quote').send(validRequest).expect(200);
 
       expect(redis.setQuote).toHaveBeenCalledWith(
         expect.any(String),
@@ -243,10 +230,7 @@ describe('Quote Route', () => {
     });
 
     it('should increment metrics on success', async () => {
-      await request(app)
-        .post('/quote')
-        .send(validRequest)
-        .expect(200);
+      await request(app).post('/quote').send(validRequest).expect(200);
 
       expect(metrics.quotesTotal.inc).toHaveBeenCalledWith({ status: 'success' });
       expect(metrics.quoteDuration.observe).toHaveBeenCalled();
@@ -254,10 +238,7 @@ describe('Quote Route', () => {
     });
 
     it('should log quote creation', async () => {
-      await request(app)
-        .post('/quote')
-        .send(validRequest)
-        .expect(200);
+      await request(app).post('/quote').send(validRequest).expect(200);
 
       expect(audit.logQuoteCreated).toHaveBeenCalledWith(
         expect.objectContaining({
@@ -291,10 +272,7 @@ describe('Quote Route', () => {
           reason: 'not_verified',
         });
 
-        const response = await request(app)
-          .post('/quote')
-          .send(validRequest)
-          .expect(400);
+        const response = await request(app).post('/quote').send(validRequest).expect(400);
 
         expect(response.body.code).toBe('TOKEN_NOT_ACCEPTED');
         expect(response.body.reason).toBe('not_verified');
@@ -306,10 +284,7 @@ describe('Quote Route', () => {
           reason: 'holdex_verified',
         });
 
-        const response = await request(app)
-          .post('/quote')
-          .send(validRequest)
-          .expect(200);
+        const response = await request(app).post('/quote').send(validRequest).expect(200);
 
         expect(response.body.paymentToken.accepted).toBe('holdex_verified');
       });
@@ -320,9 +295,7 @@ describe('Quote Route', () => {
           reason: 'not_verified',
         });
 
-        await request(app)
-          .post('/quote')
-          .send(validRequest);
+        await request(app).post('/quote').send(validRequest);
 
         expect(audit.logQuoteRejected).toHaveBeenCalledWith(
           expect.objectContaining({
@@ -340,10 +313,7 @@ describe('Quote Route', () => {
           closesAt: Date.now() + 30000,
         });
 
-        const response = await request(app)
-          .post('/quote')
-          .send(validRequest)
-          .expect(503);
+        const response = await request(app).post('/quote').send(validRequest).expect(503);
 
         expect(response.body.error).toContain('Service temporarily unavailable');
         expect(response.body.code).toBe('CIRCUIT_BREAKER_OPEN');
@@ -357,9 +327,7 @@ describe('Quote Route', () => {
           closesAt: Date.now() + 30000,
         });
 
-        await request(app)
-          .post('/quote')
-          .send(validRequest);
+        await request(app).post('/quote').send(validRequest);
 
         expect(audit.logQuoteRejected).toHaveBeenCalledWith(
           expect.objectContaining({
@@ -374,10 +342,7 @@ describe('Quote Route', () => {
       it('should return 503 when no fee payer available', async () => {
         feePayerPool.reserveBalance.mockResolvedValue(null);
 
-        const response = await request(app)
-          .post('/quote')
-          .send(validRequest)
-          .expect(503);
+        const response = await request(app).post('/quote').send(validRequest).expect(503);
 
         expect(response.body.error).toContain('no fee payer capacity');
         expect(response.body.code).toBe('NO_PAYER_CAPACITY');
@@ -387,9 +352,7 @@ describe('Quote Route', () => {
       it('should log quote rejection for no capacity', async () => {
         feePayerPool.reserveBalance.mockResolvedValue(null);
 
-        await request(app)
-          .post('/quote')
-          .send(validRequest);
+        await request(app).post('/quote').send(validRequest);
 
         expect(audit.logQuoteRejected).toHaveBeenCalledWith(
           expect.objectContaining({
@@ -403,10 +366,7 @@ describe('Quote Route', () => {
       it('should return 500 on jupiter error', async () => {
         jupiter.getFeeInToken.mockRejectedValue(new Error('Jupiter API error'));
 
-        const response = await request(app)
-          .post('/quote')
-          .send(validRequest)
-          .expect(500);
+        const response = await request(app).post('/quote').send(validRequest).expect(500);
 
         expect(response.body.error).toBe('Failed to generate quote');
         expect(response.body.code).toBe('QUOTE_FAILED');
@@ -415,10 +375,7 @@ describe('Quote Route', () => {
       it('should return 500 on token-gate error', async () => {
         tokenGate.isTokenAccepted.mockRejectedValue(new Error('Token gate error'));
 
-        const response = await request(app)
-          .post('/quote')
-          .send(validRequest)
-          .expect(500);
+        const response = await request(app).post('/quote').send(validRequest).expect(500);
 
         expect(response.body.code).toBe('QUOTE_FAILED');
       });
@@ -426,9 +383,7 @@ describe('Quote Route', () => {
       it('should increment error metrics on failure', async () => {
         jupiter.getFeeInToken.mockRejectedValue(new Error('Test error'));
 
-        await request(app)
-          .post('/quote')
-          .send(validRequest);
+        await request(app).post('/quote').send(validRequest);
 
         expect(metrics.quotesTotal.inc).toHaveBeenCalledWith({ status: 'error' });
       });
diff --git a/tests/unit/routes/submit.test.js b/tests/unit/routes/submit.test.js
index 973af31..b21bec3 100644
--- a/tests/unit/routes/submit.test.js
+++ b/tests/unit/routes/submit.test.js
@@ -36,7 +36,9 @@ jest.mock('../../../src/utils/rpc', () => ({
   simulateWithBalanceCheck: jest.fn().mockResolvedValue({ success: true, unitsConsumed: 200000 }),
   sendTransaction: jest.fn().mockResolvedValue('test-signature-abc123'),
   confirmTransaction: jest.fn().mockResolvedValue(true),
-  checkSignatureStatus: jest.fn().mockResolvedValue({ confirmed: true, slot: 12345, confirmationStatus: 'confirmed' }),
+  checkSignatureStatus: jest
+    .fn()
+    .mockResolvedValue({ confirmed: true, slot: 12345, confirmationStatus: 'confirmed' }),
 }));
 
 jest.mock('../../../src/services/signer', () => ({
@@ -183,10 +185,7 @@ describe('Submit Route', () => {
 
   describe('POST /submit', () => {
     it('should return signature for valid submission', async () => {
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(200);
+      const response = await request(app).post('/submit').send(validRequest).expect(200);
 
       expect(response.body).toHaveProperty('signature');
       expect(response.body).toHaveProperty('status', 'submitted');
@@ -195,57 +194,39 @@ describe('Submit Route', () => {
     });
 
     it('should include explorer link in response', async () => {
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(200);
+      const response = await request(app).post('/submit').send(validRequest).expect(200);
 
       expect(response.body.explorer).toContain('solscan.io/tx/');
     });
 
     it('should delete quote after successful submission', async () => {
-      await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(200);
+      await request(app).post('/submit').send(validRequest).expect(200);
 
       expect(redis.deleteQuote).toHaveBeenCalledWith(validRequest.quoteId);
     });
 
     it('should claim transaction slot to prevent replay', async () => {
-      await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(200);
+      await request(app).post('/submit').send(validRequest).expect(200);
 
       expect(redis.claimTransactionSlot).toHaveBeenCalled();
     });
 
     it('should track pending swap', async () => {
-      await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(200);
+      await request(app).post('/submit').send(validRequest).expect(200);
 
       expect(redis.addPendingSwap).toHaveBeenCalledWith(validQuote.feeAmountLamports);
       expect(redis.incrTxCount).toHaveBeenCalled();
     });
 
     it('should increment success metrics', async () => {
-      await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(200);
+      await request(app).post('/submit').send(validRequest).expect(200);
 
       expect(metrics.submitsTotal.inc).toHaveBeenCalledWith({ status: 'success' });
       expect(metrics.activeQuotes.dec).toHaveBeenCalled();
     });
 
     it('should log successful submission', async () => {
-      await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(200);
+      await request(app).post('/submit').send(validRequest).expect(200);
 
       expect(audit.logSubmitSuccess).toHaveBeenCalledWith(
         expect.objectContaining({
@@ -261,10 +242,7 @@ describe('Submit Route', () => {
     it('should return 400 for non-existent quote', async () => {
       redis.getQuote.mockResolvedValue(null);
 
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(400);
+      const response = await request(app).post('/submit').send(validRequest).expect(400);
 
       expect(response.body.error).toContain('Quote not found');
       expect(response.body.code).toBe('QUOTE_NOT_FOUND');
@@ -276,10 +254,7 @@ describe('Submit Route', () => {
         expiresAt: Date.now() - 1000, // Expired
       });
 
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(400);
+      const response = await request(app).post('/submit').send(validRequest).expect(400);
 
       expect(response.body.error).toBe('Quote expired');
       expect(response.body.code).toBe('QUOTE_EXPIRED');
@@ -291,9 +266,7 @@ describe('Submit Route', () => {
         expiresAt: Date.now() - 1000,
       });
 
-      await request(app)
-        .post('/submit')
-        .send(validRequest);
+      await request(app).post('/submit').send(validRequest);
 
       expect(redis.deleteQuote).toHaveBeenCalledWith(validRequest.quoteId);
     });
@@ -308,10 +281,7 @@ describe('Submit Route', () => {
         maxSize: 1232,
       });
 
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(400);
+      const response = await request(app).post('/submit').send(validRequest).expect(400);
 
       expect(response.body.code).toBe('TX_TOO_LARGE');
       expect(response.body.size).toBe(2000);
@@ -325,9 +295,7 @@ describe('Submit Route', () => {
         maxSize: 1232,
       });
 
-      await request(app)
-        .post('/submit')
-        .send(validRequest);
+      await request(app).post('/submit').send(validRequest);
 
       expect(audit.logSecurityEvent).toHaveBeenCalledWith(
         audit.AUDIT_EVENTS.VALIDATION_FAILED,
@@ -344,10 +312,7 @@ describe('Submit Route', () => {
         throw new Error('Invalid transaction');
       });
 
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(400);
+      const response = await request(app).post('/submit').send(validRequest).expect(400);
 
       expect(response.body.code).toBe('INVALID_TX_FORMAT');
     });
@@ -357,10 +322,7 @@ describe('Submit Route', () => {
     it('should return 400 for replay attack', async () => {
       redis.claimTransactionSlot.mockResolvedValue({ claimed: false });
 
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(400);
+      const response = await request(app).post('/submit').send(validRequest).expect(400);
 
       expect(response.body.error).toBe('Transaction already submitted');
       expect(response.body.code).toBe('REPLAY_DETECTED');
@@ -369,9 +331,7 @@ describe('Submit Route', () => {
     it('should log security event for replay', async () => {
       redis.claimTransactionSlot.mockResolvedValue({ claimed: false });
 
-      await request(app)
-        .post('/submit')
-        .send(validRequest);
+      await request(app).post('/submit').send(validRequest);
 
       expect(audit.logSecurityEvent).toHaveBeenCalledWith(
         audit.AUDIT_EVENTS.REPLAY_ATTACK_DETECTED,
@@ -384,9 +344,7 @@ describe('Submit Route', () => {
     it('should track failure for anomaly detection', async () => {
       redis.claimTransactionSlot.mockResolvedValue({ claimed: false });
 
-      await request(app)
-        .post('/submit')
-        .send(validRequest);
+      await request(app).post('/submit').send(validRequest);
 
       expect(anomalyDetector.trackWallet).toHaveBeenCalledWith(
         validRequest.userPubkey,
@@ -400,10 +358,7 @@ describe('Submit Route', () => {
     it('should return 400 for expired blockhash', async () => {
       rpc.isBlockhashValid.mockResolvedValue(false);
 
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(400);
+      const response = await request(app).post('/submit').send(validRequest).expect(400);
 
       expect(response.body.error).toContain('blockhash expired');
       expect(response.body.code).toBe('BLOCKHASH_EXPIRED');
@@ -412,9 +367,7 @@ describe('Submit Route', () => {
     it('should log security event for stale blockhash', async () => {
       rpc.isBlockhashValid.mockResolvedValue(false);
 
-      await request(app)
-        .post('/submit')
-        .send(validRequest);
+      await request(app).post('/submit').send(validRequest);
 
       expect(audit.logSecurityEvent).toHaveBeenCalledWith(
         audit.AUDIT_EVENTS.BLOCKHASH_EXPIRED,
@@ -430,10 +383,7 @@ describe('Submit Route', () => {
         errors: ['Invalid instruction'],
       });
 
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(400);
+      const response = await request(app).post('/submit').send(validRequest).expect(400);
 
       expect(response.body.code).toBe('VALIDATION_FAILED');
       expect(response.body.details).toContain('Invalid instruction');
@@ -450,10 +400,7 @@ describe('Submit Route', () => {
         feePayer: 'FeePayerPubkey111111111111111111111111111111',
       });
 
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(400);
+      const response = await request(app).post('/submit').send(validRequest).expect(400);
 
       expect(response.body.code).toBe('FEE_PAYER_MISMATCH');
     });
@@ -464,10 +411,7 @@ describe('Submit Route', () => {
         feePayer: 'DifferentPayer11111111111111111111111111111',
       });
 
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(400);
+      const response = await request(app).post('/submit').send(validRequest).expect(400);
 
       expect(response.body.code).toBe('FEE_PAYER_MISMATCH');
     });
@@ -481,10 +425,7 @@ describe('Submit Route', () => {
         logs: ['Error log 1', 'Error log 2'],
       });
 
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(400);
+      const response = await request(app).post('/submit').send(validRequest).expect(400);
 
       expect(response.body.code).toBe('SIMULATION_FAILED');
       expect(response.body.details).toBe('Simulation failed');
@@ -496,9 +437,7 @@ describe('Submit Route', () => {
         error: 'Simulation failed',
       });
 
-      await request(app)
-        .post('/submit')
-        .send(validRequest);
+      await request(app).post('/submit').send(validRequest);
 
       expect(feePayerPool.releaseReservation).toHaveBeenCalledWith(validRequest.quoteId);
     });
@@ -509,10 +448,7 @@ describe('Submit Route', () => {
       rpc.sendTransaction.mockRejectedValue(new Error('Network error'));
       txQueue.isRetryableError.mockReturnValue(true);
 
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(500);
+      const response = await request(app).post('/submit').send(validRequest).expect(500);
 
       expect(response.body.code).toBe('SUBMIT_FAILED');
       expect(response.body.attempts).toBeDefined();
@@ -523,10 +459,7 @@ describe('Submit Route', () => {
     it('should return 500 on unexpected error', async () => {
       redis.getQuote.mockRejectedValue(new Error('Database error'));
 
-      const response = await request(app)
-        .post('/submit')
-        .send(validRequest)
-        .expect(500);
+      const response = await request(app).post('/submit').send(validRequest).expect(500);
 
       expect(response.body.error).toBe('Failed to submit transaction');
       expect(response.body.code).toBe('SUBMIT_FAILED');
@@ -535,9 +468,7 @@ describe('Submit Route', () => {
     it('should increment error metrics on failure', async () => {
       redis.getQuote.mockRejectedValue(new Error('Database error'));
 
-      await request(app)
-        .post('/submit')
-        .send(validRequest);
+      await request(app).post('/submit').send(validRequest);
 
       expect(metrics.submitsTotal.inc).toHaveBeenCalledWith({ status: 'error' });
     });
@@ -545,9 +476,7 @@ describe('Submit Route', () => {
     it('should release reservation on error', async () => {
       redis.getQuote.mockRejectedValue(new Error('Database error'));
 
-      await request(app)
-        .post('/submit')
-        .send(validRequest);
+      await request(app).post('/submit').send(validRequest);
 
       expect(feePayerPool.releaseReservation).toHaveBeenCalled();
     });
@@ -564,9 +493,7 @@ describe('Submit Route', () => {
         completedAt: Date.now(),
       });
 
-      const response = await request(app)
-        .get('/submit/status/tx-123')
-        .expect(200);
+      const response = await request(app).get('/submit/status/tx-123').expect(200);
 
       expect(response.body.id).toBe('tx-123');
       expect(response.body.status).toBe('completed');
@@ -576,9 +503,7 @@ describe('Submit Route', () => {
     it('should return 404 for unknown transaction', async () => {
       txQueue.getEntry.mockResolvedValue(null);
 
-      const response = await request(app)
-        .get('/submit/status/unknown-tx')
-        .expect(404);
+      const response = await request(app).get('/submit/status/unknown-tx').expect(404);
 
       expect(response.body.code).toBe('TX_NOT_FOUND');
     });
@@ -586,9 +511,7 @@ describe('Submit Route', () => {
     it('should return 500 on error', async () => {
       txQueue.getEntry.mockRejectedValue(new Error('Database error'));
 
-      const response = await request(app)
-        .get('/submit/status/tx-123')
-        .expect(500);
+      const response = await request(app).get('/submit/status/tx-123').expect(500);
 
       expect(response.body.error).toBe('Failed to get transaction status');
     });
diff --git a/tests/unit/services/alerting.test.js b/tests/unit/services/alerting.test.js
index f2004d5..641852f 100644
--- a/tests/unit/services/alerting.test.js
+++ b/tests/unit/services/alerting.test.js
@@ -2,11 +2,7 @@
  * Tests for Alerting Service
  */
 
-const {
-  alertingService,
-  ALERT_TYPES,
-  SEVERITY,
-} = require('../../../src/services/alerting');
+const { alertingService, ALERT_TYPES, SEVERITY } = require('../../../src/services/alerting');
 
 // Mock fetch for webhook tests
 global.fetch = jest.fn();
diff --git a/tests/unit/services/burn.test.js b/tests/unit/services/burn.test.js
index 083d7d9..f0152c8 100644
--- a/tests/unit/services/burn.test.js
+++ b/tests/unit/services/burn.test.js
@@ -97,9 +97,9 @@ jest.mock('../../../src/services/jupiter', () => ({
   getTokenToSolQuote: jest.fn().mockResolvedValue({ outAmount: '500000000' }), // 0.5 SOL
   getTokenToAsdfQuote: jest.fn().mockResolvedValue({ outAmount: '800000' }),
   TOKEN_INFO: {
-    'So11111111111111111111111111111111111111112': { symbol: 'SOL', decimals: 9 },
-    'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': { symbol: 'USDC', decimals: 6 },
-    'AsdfMint111111111111111111111111111111111111': { symbol: '$ASDF', decimals: 6 },
+    So11111111111111111111111111111111111111112: { symbol: 'SOL', decimals: 9 },
+    EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v: { symbol: 'USDC', decimals: 6 },
+    AsdfMint111111111111111111111111111111111111: { symbol: '$ASDF', decimals: 6 },
   },
 }));
 
@@ -264,11 +264,7 @@ describe('Burn Service', () => {
 
       await burnService.checkAndExecuteBurn();
 
-      expect(redis.withLock).toHaveBeenCalledWith(
-        'burn-worker',
-        expect.any(Function),
-        120
-      );
+      expect(redis.withLock).toHaveBeenCalledWith('burn-worker', expect.any(Function), 120);
     });
 
     it('should return null when lock is already held', async () => {
@@ -500,11 +496,9 @@ describe('Burn Service', () => {
     it('should log worker start', () => {
       burnService.startBurnWorker(60000);
 
-      expect(logger.info).toHaveBeenCalledWith(
-        'BURN',
-        'Burn worker started',
-        { intervalMs: 60000 }
-      );
+      expect(logger.info).toHaveBeenCalledWith('BURN', 'Burn worker started', {
+        intervalMs: 60000,
+      });
     });
 
     it('should schedule initial check after 10 seconds', () => {
diff --git a/tests/unit/services/holder-tiers.test.js b/tests/unit/services/holder-tiers.test.js
index 7e4157f..82bc311 100644
--- a/tests/unit/services/holder-tiers.test.js
+++ b/tests/unit/services/holder-tiers.test.js
@@ -11,7 +11,7 @@ const GOLDEN_TREASURY_RATIO = 1 / PHI_CUBED; // ~23.6%
 jest.mock('../../../src/utils/config', () => ({
   ASDF_MINT: '9zB5wRarXMj86MymwLumSKA1Dx35zPqqKfcZtK1Spump',
   IS_DEV: true,
-  TREASURY_RATIO: 1 / (1.618033988749 ** 3), // Pure Golden: 1/  23.6%
+  TREASURY_RATIO: 1 / 1.618033988749 ** 3, // Pure Golden: 1/  23.6%
 }));
 
 jest.mock('../../../src/utils/rpc', () => ({
@@ -83,9 +83,9 @@ describe('Holder Tiers Service - Supply-Based Discount', () => {
     });
 
     it('should cap at 95% for shares above 1%', () => {
-      expect(calculateDiscountFromShare(0.1)).toBe(0.95);  // 10%
-      expect(calculateDiscountFromShare(0.5)).toBe(0.95);  // 50%
-      expect(calculateDiscountFromShare(1.0)).toBe(0.95);  // 100%
+      expect(calculateDiscountFromShare(0.1)).toBe(0.95); // 10%
+      expect(calculateDiscountFromShare(0.5)).toBe(0.95); // 50%
+      expect(calculateDiscountFromShare(1.0)).toBe(0.95); // 100%
     });
 
     it('should handle intermediate values correctly', () => {
@@ -164,7 +164,7 @@ describe('Holder Tiers Service - Supply-Based Discount', () => {
 
   describe('applyDiscount()', () => {
     const highBaseFee = 100000; // 100k lamports
-    const lowBaseFee = 10000;   // 10k lamports
+    const lowBaseFee = 10000; // 10k lamports
     const defaultTxCost = 5000;
 
     it('should return base fee for 0% discount (above break-even)', () => {
@@ -178,7 +178,7 @@ describe('Holder Tiers Service - Supply-Based Discount', () => {
 
     it('should apply 50% discount correctly', () => {
       // 100000 * 0.50 = 50000 > break-even (25000)
-      expect(applyDiscount(highBaseFee, 0.50, defaultTxCost)).toBe(50000);
+      expect(applyDiscount(highBaseFee, 0.5, defaultTxCost)).toBe(50000);
     });
 
     it('should floor at break-even when discount would go below', () => {
@@ -190,7 +190,7 @@ describe('Holder Tiers Service - Supply-Based Discount', () => {
     it('should floor at break-even for any base fee below break-even', () => {
       const breakEven = calculateBreakEvenFee(defaultTxCost);
       expect(applyDiscount(lowBaseFee, 0, defaultTxCost)).toBe(breakEven);
-      expect(applyDiscount(lowBaseFee, 0.50, defaultTxCost)).toBe(breakEven);
+      expect(applyDiscount(lowBaseFee, 0.5, defaultTxCost)).toBe(breakEven);
     });
 
     it('should use custom txCost for break-even calculation', () => {
@@ -288,7 +288,7 @@ describe('Holder Tiers Service - Supply-Based Discount', () => {
 
     it('should have correct tier structure', () => {
       const tiers = getAllTiers();
-      const tierNames = tiers.map(t => t.name);
+      const tierNames = tiers.map((t) => t.name);
 
       expect(tierNames).toContain('WHALE');
       expect(tierNames).toContain('OG');
@@ -319,7 +319,7 @@ describe('Holder Tiers Service - Supply-Based Discount', () => {
 
     it('should have progressively higher discounts for higher shares', () => {
       const shares = [0.00001, 0.0001, 0.001, 0.01];
-      const discounts = shares.map(s => calculateDiscountFromShare(s));
+      const discounts = shares.map((s) => calculateDiscountFromShare(s));
 
       for (let i = 1; i < discounts.length; i++) {
         expect(discounts[i]).toBeGreaterThan(discounts[i - 1]);
@@ -373,8 +373,8 @@ describe('Holder Tiers Service - Supply-Based Discount', () => {
     it('should double effective share when supply halves', () => {
       const holding = 1_000_000; // 1M tokens
 
-      const share1B = holding / 1_000_000_000;    // 0.1%
-      const share500M = holding / 500_000_000;    // 0.2%
+      const share1B = holding / 1_000_000_000; // 0.1%
+      const share500M = holding / 500_000_000; // 0.2%
 
       expect(share500M).toBeCloseTo(share1B * 2, 10);
     });
diff --git a/tests/unit/services/holdex.test.js b/tests/unit/services/holdex.test.js
index 403fb4f..212ede8 100644
--- a/tests/unit/services/holdex.test.js
+++ b/tests/unit/services/holdex.test.js
@@ -173,13 +173,14 @@ describe('HolDex Service', () => {
     it('should handle nested token response with kRank', async () => {
       global.fetch.mockResolvedValue({
         ok: true,
-        json: () => Promise.resolve({
-          token: {
-            kScore: 85,
-            kRank: { tier: 'Platinum', icon: '', level: 5 },
-            hasCommunityUpdate: true
-          }
-        }),
+        json: () =>
+          Promise.resolve({
+            token: {
+              kScore: 85,
+              kRank: { tier: 'Platinum', icon: '', level: 5 },
+              hasCommunityUpdate: true,
+            },
+          }),
       });
 
       const result = await holdex.getToken(testMint);
@@ -192,19 +193,20 @@ describe('HolDex Service', () => {
     it('should handle conviction data from API', async () => {
       global.fetch.mockResolvedValue({
         ok: true,
-        json: () => Promise.resolve({
-          token: {
-            kScore: 75,
-            conviction: {
-              score: 80,
-              accumulators: 150,
-              holders: 200,
-              reducers: 30,
-              extractors: 20,
-              analyzed: 400
-            }
-          }
-        }),
+        json: () =>
+          Promise.resolve({
+            token: {
+              kScore: 75,
+              conviction: {
+                score: 80,
+                accumulators: 150,
+                holders: 200,
+                reducers: 30,
+                extractors: 20,
+                analyzed: 400,
+              },
+            },
+          }),
       });
 
       const result = await holdex.getToken(testMint);
@@ -588,7 +590,7 @@ describe('HolDex Service', () => {
       // For 30% burned: multiplier = 1 - ^(-1) = 1 - 0.618 = 0.382
       // ecosystemBurn = 0.382  0.382  14.6%
       const result = holdex.calculateEcosystemBurnBonus(30);
-      const expectedMultiplier = 1 - Math.pow(PHI, -30/30);
+      const expectedMultiplier = 1 - Math.pow(PHI, -30 / 30);
       const expectedEco = maxEco * expectedMultiplier;
       expect(result.ecosystemBurnPct).toBeCloseTo(expectedEco, 5);
     });
@@ -596,7 +598,7 @@ describe('HolDex Service', () => {
     it('should calculate correct ecosystem burn for 20% token burned', () => {
       // Formula: (1/)  (1 - ^(-20/30))
       const result = holdex.calculateEcosystemBurnBonus(20);
-      const expectedMultiplier = 1 - Math.pow(PHI, -20/30);
+      const expectedMultiplier = 1 - Math.pow(PHI, -20 / 30);
       const expectedEco = maxEco * expectedMultiplier;
       expect(result.ecosystemBurnPct).toBeCloseTo(expectedEco, 5);
       expect(result.ecosystemBurnPct).toBeCloseTo(0.105, 2); // ~10.5%
@@ -604,7 +606,7 @@ describe('HolDex Service', () => {
 
     it('should calculate correct ecosystem burn for 50% token burned', () => {
       const result = holdex.calculateEcosystemBurnBonus(50);
-      const expectedMultiplier = 1 - Math.pow(PHI, -50/30);
+      const expectedMultiplier = 1 - Math.pow(PHI, -50 / 30);
       const expectedEco = maxEco * expectedMultiplier;
       expect(result.ecosystemBurnPct).toBeCloseTo(expectedEco, 5);
     });
@@ -628,14 +630,14 @@ describe('HolDex Service', () => {
     });
 
     it('should maintain 1/ (23.6%) treasury regardless of ecosystem burn', () => {
-      [0, 10, 20, 50, 80, 100].forEach(burnedPercent => {
+      [0, 10, 20, 50, 80, 100].forEach((burnedPercent) => {
         const result = holdex.calculateEcosystemBurnBonus(burnedPercent);
         expect(result.treasuryPct).toBeCloseTo(treasuryPct, 5);
       });
     });
 
     it('should have percentages sum to 100%', () => {
-      [0, 10, 20, 50, 80, 100].forEach(burnedPercent => {
+      [0, 10, 20, 50, 80, 100].forEach((burnedPercent) => {
         const result = holdex.calculateEcosystemBurnBonus(burnedPercent);
         const total = result.ecosystemBurnPct + result.asdfBurnPct + result.treasuryPct;
         expect(total).toBeCloseTo(1.0, 5);
@@ -677,12 +679,13 @@ describe('HolDex Service', () => {
     it('should include supply data when available from API', async () => {
       global.fetch.mockResolvedValue({
         ok: true,
-        json: () => Promise.resolve({
-          token: {
-            kScore: 75,
-            supply: '800000000000000', // 80% remaining = 20% burned
-          }
-        }),
+        json: () =>
+          Promise.resolve({
+            token: {
+              kScore: 75,
+              supply: '800000000000000', // 80% remaining = 20% burned
+            },
+          }),
       });
 
       const result = await holdex.getToken(testMint);
@@ -695,36 +698,39 @@ describe('HolDex Service', () => {
     it('should include ecosystemBurn data with golden formula', async () => {
       global.fetch.mockResolvedValue({
         ok: true,
-        json: () => Promise.resolve({
-          token: {
-            kScore: 75,
-            supply: '800000000000000', // 20% burned
-          }
-        }),
+        json: () =>
+          Promise.resolve({
+            token: {
+              kScore: 75,
+              supply: '800000000000000', // 20% burned
+            },
+          }),
       });
 
       const result = await holdex.getToken(testMint);
 
       expect(result.ecosystemBurn).toBeDefined();
       // Golden formula: (1/)  (1 - ^(-20/30))  10.5%
-      const expectedMultiplier = 1 - Math.pow(PHI, -20/30);
+      const expectedMultiplier = 1 - Math.pow(PHI, -20 / 30);
       const expectedEco = maxEco * expectedMultiplier;
       expect(result.ecosystemBurn.ecosystemBurnPct).toBeCloseTo(expectedEco, 4);
       expect(result.ecosystemBurn.treasuryPct).toBeCloseTo(treasuryPct, 5);
       // Total should be 100%
-      const total = result.ecosystemBurn.ecosystemBurnPct +
-                   result.ecosystemBurn.asdfBurnPct +
-                   result.ecosystemBurn.treasuryPct;
+      const total =
+        result.ecosystemBurn.ecosystemBurnPct +
+        result.ecosystemBurn.asdfBurnPct +
+        result.ecosystemBurn.treasuryPct;
       expect(total).toBeCloseTo(1.0, 5);
     });
 
     it('should handle missing supply data gracefully', async () => {
       global.fetch.mockResolvedValue({
         ok: true,
-        json: () => Promise.resolve({
-          kScore: 75,
-          // No supply field
-        }),
+        json: () =>
+          Promise.resolve({
+            kScore: 75,
+            // No supply field
+          }),
       });
 
       const result = await holdex.getToken(testMint);
diff --git a/tests/unit/services/jito.test.js b/tests/unit/services/jito.test.js
index badd8e6..d065df8 100644
--- a/tests/unit/services/jito.test.js
+++ b/tests/unit/services/jito.test.js
@@ -125,14 +125,17 @@ describe('Jito Bundle Service', () => {
 
     it('should reject more than 5 transactions', async () => {
       const transactions = Array(6).fill({ serialize: () => Buffer.from('tx') });
-      await expect(jito.sendBundle(transactions)).rejects.toThrow('Bundle cannot exceed 5 transactions');
+      await expect(jito.sendBundle(transactions)).rejects.toThrow(
+        'Bundle cannot exceed 5 transactions'
+      );
     });
 
     it('should send bundle to Jito endpoint', async () => {
       global.fetch.mockResolvedValueOnce({
-        json: () => Promise.resolve({
-          result: 'bundle-id-123',
-        }),
+        json: () =>
+          Promise.resolve({
+            result: 'bundle-id-123',
+          }),
       });
 
       const mockTx = {
@@ -154,9 +157,10 @@ describe('Jito Bundle Service', () => {
 
     it('should handle Jito API errors', async () => {
       global.fetch.mockResolvedValueOnce({
-        json: () => Promise.resolve({
-          error: { code: -32000, message: 'Bundle rejected' },
-        }),
+        json: () =>
+          Promise.resolve({
+            error: { code: -32000, message: 'Bundle rejected' },
+          }),
       });
 
       const mockTx = { serialize: () => Buffer.from('tx') };
@@ -180,9 +184,10 @@ describe('Jito Bundle Service', () => {
   describe('sendTransaction()', () => {
     it('should send transaction via Jito', async () => {
       global.fetch.mockResolvedValueOnce({
-        json: () => Promise.resolve({
-          result: 'signature-123',
-        }),
+        json: () =>
+          Promise.resolve({
+            result: 'signature-123',
+          }),
       });
 
       const mockTx = { serialize: () => Buffer.from('tx') };
@@ -215,18 +220,19 @@ describe('Jito Bundle Service', () => {
 
     it('should fetch bundle status from Jito', async () => {
       global.fetch.mockResolvedValueOnce({
-        json: () => Promise.resolve({
-          result: {
-            value: [
-              {
-                bundle_id: 'bundle-123',
-                confirmation_status: 'confirmed',
-                slot: 12345,
-                transactions: ['tx1', 'tx2'],
-              },
-            ],
-          },
-        }),
+        json: () =>
+          Promise.resolve({
+            result: {
+              value: [
+                {
+                  bundle_id: 'bundle-123',
+                  confirmation_status: 'confirmed',
+                  slot: 12345,
+                  transactions: ['tx1', 'tx2'],
+                },
+              ],
+            },
+          }),
       });
 
       const result = await jito.getBundleStatus('bundle-123');
@@ -238,9 +244,10 @@ describe('Jito Bundle Service', () => {
 
     it('should handle bundle not found', async () => {
       global.fetch.mockResolvedValueOnce({
-        json: () => Promise.resolve({
-          result: { value: [] },
-        }),
+        json: () =>
+          Promise.resolve({
+            result: { value: [] },
+          }),
       });
 
       const result = await jito.getBundleStatus('unknown-bundle');
@@ -251,15 +258,16 @@ describe('Jito Bundle Service', () => {
   describe('getTipFloor()', () => {
     it('should fetch tip floor from Jito API', async () => {
       global.fetch.mockResolvedValueOnce({
-        json: () => Promise.resolve([
-          {
-            time: '2024-01-01T00:00:00Z',
-            landed_tips_50th_percentile: 0.00001,
-            landed_tips_75th_percentile: 0.00002,
-            landed_tips_95th_percentile: 0.0001,
-            ema_landed_tips_50th_percentile: 0.000015,
-          },
-        ]),
+        json: () =>
+          Promise.resolve([
+            {
+              time: '2024-01-01T00:00:00Z',
+              landed_tips_50th_percentile: 0.00001,
+              landed_tips_75th_percentile: 0.00002,
+              landed_tips_95th_percentile: 0.0001,
+              ema_landed_tips_50th_percentile: 0.000015,
+            },
+          ]),
       });
 
       const result = await jito.getTipFloor();
@@ -282,13 +290,14 @@ describe('Jito Bundle Service', () => {
   describe('getRecommendedTip()', () => {
     beforeEach(() => {
       global.fetch.mockResolvedValue({
-        json: () => Promise.resolve([
-          {
-            landed_tips_50th_percentile: 0.00001,
-            landed_tips_75th_percentile: 0.00003,
-            landed_tips_95th_percentile: 0.0001,
-          },
-        ]),
+        json: () =>
+          Promise.resolve([
+            {
+              landed_tips_50th_percentile: 0.00001,
+              landed_tips_75th_percentile: 0.00003,
+              landed_tips_95th_percentile: 0.0001,
+            },
+          ]),
       });
     });
 
diff --git a/tests/unit/services/jupiter.test.js b/tests/unit/services/jupiter.test.js
index 4a715ca..89fb4ae 100644
--- a/tests/unit/services/jupiter.test.js
+++ b/tests/unit/services/jupiter.test.js
@@ -67,12 +67,7 @@ describe('Jupiter Service', () => {
         json: () => Promise.resolve(mockQuote),
       });
 
-      const result = await jupiter.getQuote(
-        'inputMint123',
-        'outputMint456',
-        1000000,
-        50
-      );
+      const result = await jupiter.getQuote('inputMint123', 'outputMint456', 1000000, 50);
 
       expect(result).toEqual(mockQuote);
       expect(fetchWithTimeout).toHaveBeenCalledWith(
@@ -155,10 +150,7 @@ describe('Jupiter Service', () => {
         json: () => Promise.resolve(mockSwap),
       });
 
-      const result = await jupiter.getSwapTransaction(
-        mockQuoteResponse,
-        'userPubkey123'
-      );
+      const result = await jupiter.getSwapTransaction(mockQuoteResponse, 'userPubkey123');
 
       expect(result).toEqual(mockSwap);
     });
@@ -194,9 +186,9 @@ describe('Jupiter Service', () => {
         statusText: 'Internal Server Error',
       });
 
-      await expect(
-        jupiter.getSwapTransaction(mockQuoteResponse, 'user')
-      ).rejects.toThrow('Jupiter swap failed: Internal Server Error');
+      await expect(jupiter.getSwapTransaction(mockQuoteResponse, 'user')).rejects.toThrow(
+        'Jupiter swap failed: Internal Server Error'
+      );
     });
 
     it('should execute through circuit breaker', async () => {
@@ -234,11 +226,12 @@ describe('Jupiter Service', () => {
       const { fetchWithTimeout } = require('../../../src/utils/fetch-timeout');
       fetchWithTimeout.mockResolvedValue({
         ok: true,
-        json: () => Promise.resolve({
-          inAmount: '2000000', // 2 USDC for 2x SOL
-          outAmount: '10000000', // 0.01 SOL (2x of 0.005 SOL)
-          priceImpactPct: '0.05',
-        }),
+        json: () =>
+          Promise.resolve({
+            inAmount: '2000000', // 2 USDC for 2x SOL
+            outAmount: '10000000', // 0.01 SOL (2x of 0.005 SOL)
+            priceImpactPct: '0.05',
+          }),
       });
 
       const result = await jupiter.getFeeInToken(
@@ -256,11 +249,12 @@ describe('Jupiter Service', () => {
       const { fetchWithTimeout } = require('../../../src/utils/fetch-timeout');
       fetchWithTimeout.mockResolvedValue({
         ok: true,
-        json: () => Promise.resolve({
-          inAmount: '1000000',
-          outAmount: '10000000',
-          priceImpactPct: '0.01',
-        }),
+        json: () =>
+          Promise.resolve({
+            inAmount: '1000000',
+            outAmount: '10000000',
+            priceImpactPct: '0.01',
+          }),
       });
 
       // Test USDC
@@ -276,11 +270,12 @@ describe('Jupiter Service', () => {
       const { fetchWithTimeout } = require('../../../src/utils/fetch-timeout');
       fetchWithTimeout.mockResolvedValue({
         ok: true,
-        json: () => Promise.resolve({
-          inAmount: '1000000',
-          outAmount: '10000000',
-          priceImpactPct: '0',
-        }),
+        json: () =>
+          Promise.resolve({
+            inAmount: '1000000',
+            outAmount: '10000000',
+            priceImpactPct: '0',
+          }),
       });
 
       const result = await jupiter.getFeeInToken('UnknownMint123', 5000000);
@@ -292,16 +287,17 @@ describe('Jupiter Service', () => {
       const { fetchWithTimeout } = require('../../../src/utils/fetch-timeout');
       fetchWithTimeout.mockResolvedValue({
         ok: true,
-        json: () => Promise.resolve({
-          inAmount: '1000000',
-          outAmount: '0',
-          priceImpactPct: '0',
-        }),
+        json: () =>
+          Promise.resolve({
+            inAmount: '1000000',
+            outAmount: '0',
+            priceImpactPct: '0',
+          }),
       });
 
-      await expect(
-        jupiter.getFeeInToken('SomeToken123', 5000000)
-      ).rejects.toThrow('Jupiter returned zero output amount');
+      await expect(jupiter.getFeeInToken('SomeToken123', 5000000)).rejects.toThrow(
+        'Jupiter returned zero output amount'
+      );
     });
 
     it('should include route in response', async () => {
@@ -415,27 +411,25 @@ describe('Jupiter Service', () => {
       const { fetchWithTimeout } = require('../../../src/utils/fetch-timeout');
       fetchWithTimeout.mockRejectedValue(new Error('Jupiter unavailable'));
 
-      await expect(
-        jupiter.getFeeInToken('SomeToken', 5000000)
-      ).rejects.toThrow('Jupiter unavailable');
+      await expect(jupiter.getFeeInToken('SomeToken', 5000000)).rejects.toThrow(
+        'Jupiter unavailable'
+      );
     });
 
     it('should throw error when calculation overflows', async () => {
       const { fetchWithTimeout } = require('../../../src/utils/fetch-timeout');
       fetchWithTimeout.mockResolvedValue({
         ok: true,
-        json: () => Promise.resolve({
-          inAmount: String(Number.MAX_SAFE_INTEGER),
-          outAmount: '1',
-          priceImpactPct: '0',
-        }),
+        json: () =>
+          Promise.resolve({
+            inAmount: String(Number.MAX_SAFE_INTEGER),
+            outAmount: '1',
+            priceImpactPct: '0',
+          }),
       });
 
-      await expect(
-        jupiter.getFeeInToken('SomeToken', Number.MAX_SAFE_INTEGER)
-      ).rejects.toThrow();
+      await expect(jupiter.getFeeInToken('SomeToken', Number.MAX_SAFE_INTEGER)).rejects.toThrow();
     });
-
   });
 
   describe('swapToAsdf()', () => {
@@ -524,11 +518,12 @@ describe('Jupiter Service', () => {
       const { fetchWithTimeout } = require('../../../src/utils/fetch-timeout');
       fetchWithTimeout.mockResolvedValue({
         ok: true,
-        json: () => Promise.resolve({
-          inAmount: '1000000',
-          outAmount: '10000000',
-          priceImpactPct: '0',
-        }),
+        json: () =>
+          Promise.resolve({
+            inAmount: '1000000',
+            outAmount: '10000000',
+            priceImpactPct: '0',
+          }),
       });
 
       const result = await jupiter.getFeeInToken(
@@ -543,11 +538,12 @@ describe('Jupiter Service', () => {
       const { fetchWithTimeout } = require('../../../src/utils/fetch-timeout');
       fetchWithTimeout.mockResolvedValue({
         ok: true,
-        json: () => Promise.resolve({
-          inAmount: '1000000000',
-          outAmount: '10000000',
-          priceImpactPct: '0',
-        }),
+        json: () =>
+          Promise.resolve({
+            inAmount: '1000000000',
+            outAmount: '10000000',
+            priceImpactPct: '0',
+          }),
       });
 
       const result = await jupiter.getFeeInToken(
@@ -562,11 +558,12 @@ describe('Jupiter Service', () => {
       const { fetchWithTimeout } = require('../../../src/utils/fetch-timeout');
       fetchWithTimeout.mockResolvedValue({
         ok: true,
-        json: () => Promise.resolve({
-          inAmount: '1000000000',
-          outAmount: '10000000',
-          priceImpactPct: '0',
-        }),
+        json: () =>
+          Promise.resolve({
+            inAmount: '1000000000',
+            outAmount: '10000000',
+            priceImpactPct: '0',
+          }),
       });
 
       const result = await jupiter.getFeeInToken(
diff --git a/tests/unit/services/oracle.test.js b/tests/unit/services/oracle.test.js
index 4aee964..3ee5890 100644
--- a/tests/unit/services/oracle.test.js
+++ b/tests/unit/services/oracle.test.js
@@ -245,10 +245,7 @@ describe('Oracle Service (Legacy)', () => {
 
       const result = await oracle.pingOracle();
 
-      expect(global.fetch).toHaveBeenCalledWith(
-        'http://localhost:3001/health',
-        expect.any(Object)
-      );
+      expect(global.fetch).toHaveBeenCalledWith('http://localhost:3001/health', expect.any(Object));
       expect(result.success).toBe(true);
       expect(result.latencyMs).toBeDefined();
     });
diff --git a/tests/unit/services/pyth.test.js b/tests/unit/services/pyth.test.js
index d48cd7b..8a169ab 100644
--- a/tests/unit/services/pyth.test.js
+++ b/tests/unit/services/pyth.test.js
@@ -63,7 +63,9 @@ describe('Pyth Oracle Service', () => {
   describe('PYTH_FEEDS', () => {
     it('should have SOL/USD feed', () => {
       expect(pyth.PYTH_FEEDS['SOL/USD']).toBeDefined();
-      expect(pyth.PYTH_FEEDS['SOL/USD'].toBase58()).toBe('7UVimffxr9ow1uXYxsr4LHAcV58mLzhmwaeKvJ1pjLiE');
+      expect(pyth.PYTH_FEEDS['SOL/USD'].toBase58()).toBe(
+        '7UVimffxr9ow1uXYxsr4LHAcV58mLzhmwaeKvJ1pjLiE'
+      );
     });
 
     it('should have BTC/USD feed', () => {
@@ -77,10 +79,7 @@ describe('Pyth Oracle Service', () => {
 
   describe('getFeeInToken()', () => {
     it('should return native source for SOL', async () => {
-      const result = await pyth.getFeeInToken(
-        'So11111111111111111111111111111111111111112',
-        50000
-      );
+      const result = await pyth.getFeeInToken('So11111111111111111111111111111111111111112', 50000);
 
       expect(result).toEqual({
         inputAmount: 50000,
diff --git a/tests/unit/services/token-gate.test.js b/tests/unit/services/token-gate.test.js
index 865b81c..5d8ad42 100644
--- a/tests/unit/services/token-gate.test.js
+++ b/tests/unit/services/token-gate.test.js
@@ -31,14 +31,63 @@ jest.mock('../../../src/services/holdex', () => ({
     return { tier: 'Rust', icon: '', level: 1 };
   }),
   getCreditRating: jest.fn((score) => {
-    if (score >= 90) return { grade: 'A1', label: 'Prime Quality', risk: 'minimal', outlook: 'stable', trajectory: ' Stable' };
-    if (score >= 80) return { grade: 'A2', label: 'Excellent', risk: 'very_low', outlook: 'stable', trajectory: ' Stable' };
-    if (score >= 70) return { grade: 'A3', label: 'Good', risk: 'low', outlook: 'stable', trajectory: ' Stable' };
-    if (score >= 60) return { grade: 'B1', label: 'Fair', risk: 'moderate', outlook: 'stable', trajectory: ' Stable' };
-    if (score >= 50) return { grade: 'B2', label: 'Speculative', risk: 'high', outlook: 'stable', trajectory: ' Stable' };
-    if (score >= 40) return { grade: 'B3', label: 'Very Speculative', risk: 'very_high', outlook: 'stable', trajectory: ' Stable' };
-    if (score >= 20) return { grade: 'C', label: 'Substantial Risk', risk: 'severe', outlook: 'stable', trajectory: ' Stable' };
-    return { grade: 'D', label: 'Default', risk: 'extreme', outlook: 'stable', trajectory: ' Stable' };
+    if (score >= 90)
+      return {
+        grade: 'A1',
+        label: 'Prime Quality',
+        risk: 'minimal',
+        outlook: 'stable',
+        trajectory: ' Stable',
+      };
+    if (score >= 80)
+      return {
+        grade: 'A2',
+        label: 'Excellent',
+        risk: 'very_low',
+        outlook: 'stable',
+        trajectory: ' Stable',
+      };
+    if (score >= 70)
+      return { grade: 'A3', label: 'Good', risk: 'low', outlook: 'stable', trajectory: ' Stable' };
+    if (score >= 60)
+      return {
+        grade: 'B1',
+        label: 'Fair',
+        risk: 'moderate',
+        outlook: 'stable',
+        trajectory: ' Stable',
+      };
+    if (score >= 50)
+      return {
+        grade: 'B2',
+        label: 'Speculative',
+        risk: 'high',
+        outlook: 'stable',
+        trajectory: ' Stable',
+      };
+    if (score >= 40)
+      return {
+        grade: 'B3',
+        label: 'Very Speculative',
+        risk: 'very_high',
+        outlook: 'stable',
+        trajectory: ' Stable',
+      };
+    if (score >= 20)
+      return {
+        grade: 'C',
+        label: 'Substantial Risk',
+        risk: 'severe',
+        outlook: 'stable',
+        trajectory: ' Stable',
+      };
+    return {
+      grade: 'D',
+      label: 'Default',
+      risk: 'extreme',
+      outlook: 'stable',
+      trajectory: ' Stable',
+    };
   }),
 }));
 
@@ -59,7 +108,9 @@ describe('Token Gate Service', () => {
   describe('isTokenAccepted()', () => {
     describe('DIAMOND_TOKENS (local, no network)', () => {
       it('should accept SOL with Diamond tier and credit rating', async () => {
-        const result = await tokenGate.isTokenAccepted('So11111111111111111111111111111111111111112');
+        const result = await tokenGate.isTokenAccepted(
+          'So11111111111111111111111111111111111111112'
+        );
 
         expect(result.accepted).toBe(true);
         expect(result.reason).toBe('diamond');
@@ -71,7 +122,9 @@ describe('Token Gate Service', () => {
       });
 
       it('should accept USDC with Diamond tier', async () => {
-        const result = await tokenGate.isTokenAccepted('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');
+        const result = await tokenGate.isTokenAccepted(
+          'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'
+        );
 
         expect(result.accepted).toBe(true);
         expect(result.reason).toBe('diamond');
@@ -79,7 +132,9 @@ describe('Token Gate Service', () => {
       });
 
       it('should accept USDT with Diamond tier', async () => {
-        const result = await tokenGate.isTokenAccepted('Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB');
+        const result = await tokenGate.isTokenAccepted(
+          'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB'
+        );
 
         expect(result.accepted).toBe(true);
         expect(result.reason).toBe('diamond');
@@ -87,7 +142,9 @@ describe('Token Gate Service', () => {
       });
 
       it('should accept mSOL with Diamond tier', async () => {
-        const result = await tokenGate.isTokenAccepted('mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So');
+        const result = await tokenGate.isTokenAccepted(
+          'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So'
+        );
 
         expect(result.accepted).toBe(true);
         expect(result.reason).toBe('diamond');
@@ -95,7 +152,9 @@ describe('Token Gate Service', () => {
       });
 
       it('should accept jitoSOL with Diamond tier', async () => {
-        const result = await tokenGate.isTokenAccepted('J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn');
+        const result = await tokenGate.isTokenAccepted(
+          'J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn'
+        );
 
         expect(result.accepted).toBe(true);
         expect(result.reason).toBe('diamond');
@@ -103,7 +162,9 @@ describe('Token Gate Service', () => {
       });
 
       it('should accept $ASDF with Diamond tier', async () => {
-        const result = await tokenGate.isTokenAccepted('9zB5wRarXMj86MymwLumSKA1Dx35zPqqKfcZtK1Spump');
+        const result = await tokenGate.isTokenAccepted(
+          '9zB5wRarXMj86MymwLumSKA1Dx35zPqqKfcZtK1Spump'
+        );
 
         expect(result.accepted).toBe(true);
         expect(result.reason).toBe('diamond');
@@ -292,7 +353,7 @@ describe('Token Gate Service', () => {
       expect(tokens.length).toBeGreaterThanOrEqual(5);
 
       // Check structure - now uses tier instead of trusted
-      const sol = tokens.find(t => t.symbol === 'SOL');
+      const sol = tokens.find((t) => t.symbol === 'SOL');
       expect(sol).toBeDefined();
       expect(sol.mint).toBe('So11111111111111111111111111111111111111112');
       expect(sol.decimals).toBe(9);
@@ -302,7 +363,7 @@ describe('Token Gate Service', () => {
     it('should include $ASDF when configured', () => {
       const tokens = tokenGate.getDiamondTokensList();
 
-      const asdf = tokens.find(t => t.symbol === 'ASDF');
+      const asdf = tokens.find((t) => t.symbol === 'ASDF');
       expect(asdf).toBeDefined();
       expect(asdf.mint).toBe('9zB5wRarXMj86MymwLumSKA1Dx35zPqqKfcZtK1Spump');
       expect(asdf.tier).toBe('Diamond');
@@ -311,15 +372,15 @@ describe('Token Gate Service', () => {
     it('should include all major stablecoins', () => {
       const tokens = tokenGate.getDiamondTokensList();
 
-      expect(tokens.find(t => t.symbol === 'USDC')).toBeDefined();
-      expect(tokens.find(t => t.symbol === 'USDT')).toBeDefined();
+      expect(tokens.find((t) => t.symbol === 'USDC')).toBeDefined();
+      expect(tokens.find((t) => t.symbol === 'USDT')).toBeDefined();
     });
 
     it('should include liquid staking tokens', () => {
       const tokens = tokenGate.getDiamondTokensList();
 
-      expect(tokens.find(t => t.symbol === 'mSOL')).toBeDefined();
-      expect(tokens.find(t => t.symbol === 'jitoSOL')).toBeDefined();
+      expect(tokens.find((t) => t.symbol === 'mSOL')).toBeDefined();
+      expect(tokens.find((t) => t.symbol === 'jitoSOL')).toBeDefined();
     });
   });
 
@@ -338,8 +399,12 @@ describe('Token Gate Service', () => {
     });
 
     it('should contain the core Diamond tokens', () => {
-      expect(tokenGate.DIAMOND_TOKENS.has('So11111111111111111111111111111111111111112')).toBe(true);
-      expect(tokenGate.DIAMOND_TOKENS.has('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v')).toBe(true);
+      expect(tokenGate.DIAMOND_TOKENS.has('So11111111111111111111111111111111111111112')).toBe(
+        true
+      );
+      expect(tokenGate.DIAMOND_TOKENS.has('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v')).toBe(
+        true
+      );
     });
   });
 
diff --git a/tests/unit/services/treasury-ata.test.js b/tests/unit/services/treasury-ata.test.js
index 37ce8a7..b9f17b2 100644
--- a/tests/unit/services/treasury-ata.test.js
+++ b/tests/unit/services/treasury-ata.test.js
@@ -56,7 +56,11 @@ jest.mock('../../../src/services/fee-payer-pool', () => ({
 }));
 
 // Get references to mocks
-const { getAssociatedTokenAddress, getAccount, createAssociatedTokenAccountInstruction } = require('@solana/spl-token');
+const {
+  getAssociatedTokenAddress,
+  getAccount,
+  createAssociatedTokenAccountInstruction,
+} = require('@solana/spl-token');
 const config = require('../../../src/utils/config');
 const logger = require('../../../src/utils/logger');
 const rpc = require('../../../src/utils/rpc');
@@ -168,10 +172,7 @@ describe('Treasury ATA Manager', () => {
       const result = await treasuryAta.checkTreasuryAta('SomeToken');
 
       expect(result).toBeNull();
-      expect(logger.error).toHaveBeenCalledWith(
-        'TREASURY_ATA',
-        'Treasury address not configured'
-      );
+      expect(logger.error).toHaveBeenCalledWith('TREASURY_ATA', 'Treasury address not configured');
     });
 
     it('should log debug when ATA exists', async () => {
@@ -179,11 +180,7 @@ describe('Treasury ATA Manager', () => {
 
       await treasuryAta.checkTreasuryAta('TokenMint123');
 
-      expect(logger.debug).toHaveBeenCalledWith(
-        'TREASURY_ATA',
-        'ATA exists',
-        expect.any(Object)
-      );
+      expect(logger.debug).toHaveBeenCalledWith('TREASURY_ATA', 'ATA exists', expect.any(Object));
     });
 
     it('should log error on exception', async () => {
@@ -230,30 +227,22 @@ describe('Treasury ATA Manager', () => {
         throw new Error('No payer');
       });
 
-      await expect(treasuryAta.createTreasuryAta('SomeToken'))
-        .rejects.toThrow('Treasury address not configured');
+      await expect(treasuryAta.createTreasuryAta('SomeToken')).rejects.toThrow(
+        'Treasury address not configured'
+      );
     });
 
     it('should log creation info', async () => {
       await treasuryAta.createTreasuryAta('LogToken');
 
-      expect(logger.info).toHaveBeenCalledWith(
-        'TREASURY_ATA',
-        'Creating ATA',
-        expect.any(Object)
-      );
-      expect(logger.info).toHaveBeenCalledWith(
-        'TREASURY_ATA',
-        'ATA created',
-        expect.any(Object)
-      );
+      expect(logger.info).toHaveBeenCalledWith('TREASURY_ATA', 'Creating ATA', expect.any(Object));
+      expect(logger.info).toHaveBeenCalledWith('TREASURY_ATA', 'ATA created', expect.any(Object));
     });
 
     it('should handle transaction failure', async () => {
       mockConnection.sendRawTransaction.mockRejectedValue(new Error('TX failed'));
 
-      await expect(treasuryAta.createTreasuryAta('FailToken'))
-        .rejects.toThrow('TX failed');
+      await expect(treasuryAta.createTreasuryAta('FailToken')).rejects.toThrow('TX failed');
 
       expect(logger.error).toHaveBeenCalledWith(
         'TREASURY_ATA',
@@ -276,7 +265,7 @@ describe('Treasury ATA Manager', () => {
     it('should prevent concurrent creation attempts', async () => {
       // Slow down the first creation
       mockConnection.sendRawTransaction.mockImplementation(async () => {
-        await new Promise(r => setTimeout(r, 100));
+        await new Promise((r) => setTimeout(r, 100));
         return 'tx-sig';
       });
 
@@ -351,7 +340,9 @@ describe('Treasury ATA Manager', () => {
     });
 
     it('should return null for native SOL address', async () => {
-      const result = await treasuryAta.ensureTreasuryAta('So11111111111111111111111111111111111111112');
+      const result = await treasuryAta.ensureTreasuryAta(
+        'So11111111111111111111111111111111111111112'
+      );
 
       expect(result).toBeNull();
     });
@@ -424,7 +415,9 @@ describe('Treasury ATA Manager', () => {
     });
 
     it('should return native info for SOL address', async () => {
-      const result = await treasuryAta.getTreasuryAtaInfo('So11111111111111111111111111111111111111112');
+      const result = await treasuryAta.getTreasuryAtaInfo(
+        'So11111111111111111111111111111111111111112'
+      );
 
       expect(result.isNative).toBe(true);
     });
diff --git a/tests/unit/services/validator.test.js b/tests/unit/services/validator.test.js
index d0bcb5f..ae88489 100644
--- a/tests/unit/services/validator.test.js
+++ b/tests/unit/services/validator.test.js
@@ -12,7 +12,14 @@ const {
   MAX_COMPUTE_UNITS,
   SIGNATURE_SIZE,
 } = require('../../../src/services/validator');
-const { Keypair, Transaction, SystemProgram, PublicKey, VersionedTransaction, TransactionMessage } = require('@solana/web3.js');
+const {
+  Keypair,
+  Transaction,
+  SystemProgram,
+  PublicKey,
+  VersionedTransaction,
+  TransactionMessage,
+} = require('@solana/web3.js');
 
 // Create mock fee payer for tests
 const mockFeePayer = Keypair.generate();
@@ -213,7 +220,9 @@ describe('Validator Service', () => {
       }).compileToV0Message();
 
       const versionedTx = new VersionedTransaction(message);
-      expect(getTransactionBlockhash(versionedTx)).toBe('DemoBlockhash123456789012345678901234567890123');
+      expect(getTransactionBlockhash(versionedTx)).toBe(
+        'DemoBlockhash123456789012345678901234567890123'
+      );
     });
   });
 
@@ -364,7 +373,7 @@ describe('Validator Service', () => {
       const result = validateTransaction(tx, 5000, user.publicKey.toBase58());
       expect(result.valid).toBe(false);
       // Should have signature-related error
-      expect(result.errors.some(e => e.includes('signature') || e.includes('signer'))).toBe(true);
+      expect(result.errors.some((e) => e.includes('signature') || e.includes('signer'))).toBe(true);
     });
 
     it('should detect unauthorized SOL transfer from fee payer', () => {
@@ -393,7 +402,9 @@ describe('Validator Service', () => {
 
       const result = validateTransaction(tx, 5000, user.publicKey.toBase58());
       expect(result.valid).toBe(false);
-      expect(result.errors.some(e => e.includes('Unauthorized') && e.includes('Transfer'))).toBe(true);
+      expect(result.errors.some((e) => e.includes('Unauthorized') && e.includes('Transfer'))).toBe(
+        true
+      );
     });
   });
 
diff --git a/tests/unit/utils/alt.test.js b/tests/unit/utils/alt.test.js
index ff2278e..f66a440 100644
--- a/tests/unit/utils/alt.test.js
+++ b/tests/unit/utils/alt.test.js
@@ -12,7 +12,9 @@ const mockPublicKey = jest.fn().mockImplementation((key) => ({
 jest.mock('@solana/web3.js', () => ({
   PublicKey: mockPublicKey,
   AddressLookupTableProgram: {
-    createLookupTable: jest.fn().mockReturnValue([{ type: 'createAlt' }, { toBase58: () => 'new-alt-address' }]),
+    createLookupTable: jest
+      .fn()
+      .mockReturnValue([{ type: 'createAlt' }, { toBase58: () => 'new-alt-address' }]),
     extendLookupTable: jest.fn().mockReturnValue({ type: 'extendAlt' }),
   },
   TransactionMessage: jest.fn().mockImplementation(() => ({
@@ -171,19 +173,27 @@ describe('ALT Utility', () => {
     });
 
     it('should contain token program', () => {
-      expect(alt.CORE_ADDRESSES.TOKEN_PROGRAM.toBase58()).toBe('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
+      expect(alt.CORE_ADDRESSES.TOKEN_PROGRAM.toBase58()).toBe(
+        'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'
+      );
     });
 
     it('should contain Jupiter program', () => {
-      expect(alt.CORE_ADDRESSES.JUPITER_PROGRAM.toBase58()).toBe('JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4');
+      expect(alt.CORE_ADDRESSES.JUPITER_PROGRAM.toBase58()).toBe(
+        'JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4'
+      );
     });
 
     it('should contain WSOL mint', () => {
-      expect(alt.CORE_ADDRESSES.WSOL_MINT.toBase58()).toBe('So11111111111111111111111111111111111111112');
+      expect(alt.CORE_ADDRESSES.WSOL_MINT.toBase58()).toBe(
+        'So11111111111111111111111111111111111111112'
+      );
     });
 
     it('should contain USDC mint', () => {
-      expect(alt.CORE_ADDRESSES.USDC_MINT.toBase58()).toBe('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');
+      expect(alt.CORE_ADDRESSES.USDC_MINT.toBase58()).toBe(
+        'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'
+      );
     });
   });
 
diff --git a/tests/unit/utils/distributed-lock.test.js b/tests/unit/utils/distributed-lock.test.js
index 172ad1d..71b7d8e 100644
--- a/tests/unit/utils/distributed-lock.test.js
+++ b/tests/unit/utils/distributed-lock.test.js
@@ -176,16 +176,20 @@ describe('Distributed Locking', () => {
       let maxConcurrent = 0;
 
       const executeWithTracking = async () => {
-        return redis.withLock(lockName, async () => {
-          concurrentCount++;
-          maxConcurrent = Math.max(maxConcurrent, concurrentCount);
-
-          // Simulate some work
-          await new Promise((resolve) => setTimeout(resolve, 50));
-
-          concurrentCount--;
-          return 'done';
-        }, 10);
+        return redis.withLock(
+          lockName,
+          async () => {
+            concurrentCount++;
+            maxConcurrent = Math.max(maxConcurrent, concurrentCount);
+
+            // Simulate some work
+            await new Promise((resolve) => setTimeout(resolve, 50));
+
+            concurrentCount--;
+            return 'done';
+          },
+          10
+        );
       };
 
       // Launch multiple concurrent executions
diff --git a/tests/unit/utils/fetch-timeout.test.js b/tests/unit/utils/fetch-timeout.test.js
index 1f1b531..40d7c4b 100644
--- a/tests/unit/utils/fetch-timeout.test.js
+++ b/tests/unit/utils/fetch-timeout.test.js
@@ -56,9 +56,9 @@ describe('Fetch Timeout Utilities', () => {
         setTimeout(() => resolve('success'), 500);
       });
 
-      await expect(
-        withTimeout(slowPromise, 100, 'Slow operation')
-      ).rejects.toThrow('Slow operation timeout after 100ms');
+      await expect(withTimeout(slowPromise, 100, 'Slow operation')).rejects.toThrow(
+        'Slow operation timeout after 100ms'
+      );
     });
 
     it('should preserve original rejection', async () => {
@@ -66,9 +66,9 @@ describe('Fetch Timeout Utilities', () => {
         setTimeout(() => reject(new Error('Original error')), 50);
       });
 
-      await expect(
-        withTimeout(failingPromise, 200, 'Failing operation')
-      ).rejects.toThrow('Original error');
+      await expect(withTimeout(failingPromise, 200, 'Failing operation')).rejects.toThrow(
+        'Original error'
+      );
     });
 
     it('should handle immediate resolution', async () => {
@@ -104,16 +104,8 @@ describe('Fetch Timeout Utilities', () => {
   describe('Concurrent timeout handling', () => {
     it('should handle multiple concurrent timeouts independently', async () => {
       const results = await Promise.allSettled([
-        withTimeout(
-          new Promise((resolve) => setTimeout(() => resolve('fast'), 50)),
-          200,
-          'Fast'
-        ),
-        withTimeout(
-          new Promise((resolve) => setTimeout(() => resolve('slow'), 300)),
-          100,
-          'Slow'
-        ),
+        withTimeout(new Promise((resolve) => setTimeout(() => resolve('fast'), 50)), 200, 'Fast'),
+        withTimeout(new Promise((resolve) => setTimeout(() => resolve('slow'), 300)), 100, 'Slow'),
       ]);
 
       expect(results[0].status).toBe('fulfilled');
@@ -128,9 +120,7 @@ describe('Fetch Timeout Utilities', () => {
       const promises = [];
 
       for (let i = 0; i < 10; i++) {
-        promises.push(
-          withTimeout(Promise.resolve(i), 1000, `Op${i}`)
-        );
+        promises.push(withTimeout(Promise.resolve(i), 1000, `Op${i}`));
       }
 
       const results = await Promise.all(promises);
@@ -141,11 +131,7 @@ describe('Fetch Timeout Utilities', () => {
   describe('Edge cases', () => {
     it('should handle zero timeout', async () => {
       await expect(
-        withTimeout(
-          new Promise((resolve) => setTimeout(resolve, 10)),
-          0,
-          'Zero'
-        )
+        withTimeout(new Promise((resolve) => setTimeout(resolve, 10)), 0, 'Zero')
       ).rejects.toThrow('Zero timeout after 0ms');
     });
 
@@ -180,11 +166,15 @@ describe('Fetch Timeout Utilities', () => {
       const mockResponse = { ok: true };
       global.fetch.mockResolvedValue(mockResponse);
 
-      await fetchWithTimeout('https://example.com', {
-        method: 'POST',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify({ test: true }),
-      }, 1000);
+      await fetchWithTimeout(
+        'https://example.com',
+        {
+          method: 'POST',
+          headers: { 'Content-Type': 'application/json' },
+          body: JSON.stringify({ test: true }),
+        },
+        1000
+      );
 
       expect(global.fetch).toHaveBeenCalledWith(
         'https://example.com',
@@ -201,9 +191,7 @@ describe('Fetch Timeout Utilities', () => {
       abortError.name = 'AbortError';
       global.fetch.mockRejectedValue(abortError);
 
-      await expect(
-        fetchWithTimeout('https://example.com', {}, 100)
-      ).rejects.toMatchObject({
+      await expect(fetchWithTimeout('https://example.com', {}, 100)).rejects.toMatchObject({
         code: 'TIMEOUT',
         url: 'https://example.com',
         timeoutMs: 100,
@@ -214,9 +202,9 @@ describe('Fetch Timeout Utilities', () => {
       const networkError = new Error('Network error');
       global.fetch.mockRejectedValue(networkError);
 
-      await expect(
-        fetchWithTimeout('https://example.com', {}, 1000)
-      ).rejects.toThrow('Network error');
+      await expect(fetchWithTimeout('https://example.com', {}, 1000)).rejects.toThrow(
+        'Network error'
+      );
     });
 
     it('should use DEFAULT_TIMEOUT when not specified', async () => {
@@ -311,7 +299,8 @@ describe('Fetch Timeout Utilities', () => {
     it('should retry on failure', async () => {
       jest.useRealTimers(); // Use real timers for this test
 
-      const fn = jest.fn()
+      const fn = jest
+        .fn()
         .mockRejectedValueOnce(new Error('fail 1'))
         .mockRejectedValueOnce(new Error('fail 2'))
         .mockResolvedValue('success');
diff --git a/tests/unit/utils/metrics.test.js b/tests/unit/utils/metrics.test.js
index f0faae7..8406a64 100644
--- a/tests/unit/utils/metrics.test.js
+++ b/tests/unit/utils/metrics.test.js
@@ -162,13 +162,13 @@ describe('Metrics Module', () => {
     it('should place values in correct buckets', () => {
       histogram.observe({ path: '/quote' }, 0.05); // <= 0.1
       histogram.observe({ path: '/quote' }, 0.25); // <= 0.5
-      histogram.observe({ path: '/quote' }, 0.8);  // <= 1
+      histogram.observe({ path: '/quote' }, 0.8); // <= 1
 
       const obs = histogram.observations.get('/quote');
       // Buckets are stored in a Map with bucket boundary as key
       expect(obs.buckets.get(0.1)).toBe(1); // 0.1 bucket: 1 value (0.05)
       expect(obs.buckets.get(0.5)).toBe(2); // 0.5 bucket: 2 values (0.05, 0.25)
-      expect(obs.buckets.get(1)).toBe(3);   // 1 bucket: 3 values (0.05, 0.25, 0.8)
+      expect(obs.buckets.get(1)).toBe(3); // 1 bucket: 3 values (0.05, 0.25, 0.8)
     });
 
     it('should collect prometheus format output', () => {
diff --git a/tests/unit/utils/redis-burn-proofs.test.js b/tests/unit/utils/redis-burn-proofs.test.js
index 6809c01..10c3b27 100644
--- a/tests/unit/utils/redis-burn-proofs.test.js
+++ b/tests/unit/utils/redis-burn-proofs.test.js
@@ -21,8 +21,10 @@ describe('Burn Proofs', () => {
   });
 
   const mockProof = {
-    burnSignature: '5XzL8mK9vN2pQ7wR4tU6yH3jF8gC1bD9aE0iO5kM2nP3qS4rT7uV6wX8yZ1aB2cD3eF4gH5iJ6kL7mN8oP9qR0sT',
-    swapSignature: '4WyK7lJ8uM1oP6vQ3sT5xG2iE7fB0aC8zD9hN4jL1mO2pR3qS6tU5wV7xY0zA1bC2dE3fG4hI5jK6lM7nO8pQ9rS',
+    burnSignature:
+      '5XzL8mK9vN2pQ7wR4tU6yH3jF8gC1bD9aE0iO5kM2nP3qS4rT7uV6wX8yZ1aB2cD3eF4gH5iJ6kL7mN8oP9qR0sT',
+    swapSignature:
+      '4WyK7lJ8uM1oP6vQ3sT5xG2iE7fB0aC8zD9hN4jL1mO2pR3qS6tU5wV7xY0zA1bC2dE3fG4hI5jK6lM7nO8pQ9rS',
     amountBurned: 1500000000,
     solAmount: 50000000,
     treasuryAmount: 12500000,
@@ -53,9 +55,7 @@ describe('Burn Proofs', () => {
     test('should generate correct explorer URL', async () => {
       const result = await redis.recordBurnProof(mockProof);
 
-      expect(result.explorerUrl).toBe(
-        `https://solscan.io/tx/${mockProof.burnSignature}`
-      );
+      expect(result.explorerUrl).toBe(`https://solscan.io/tx/${mockProof.burnSignature}`);
     });
 
     test('should include network in proof', async () => {
@@ -110,9 +110,7 @@ describe('Burn Proofs', () => {
       const result = await redis.getBurnProofs(10);
 
       for (let i = 1; i < result.proofs.length; i++) {
-        expect(result.proofs[i - 1].timestamp).toBeGreaterThanOrEqual(
-          result.proofs[i].timestamp
-        );
+        expect(result.proofs[i - 1].timestamp).toBeGreaterThanOrEqual(result.proofs[i].timestamp);
       }
     });
   });
diff --git a/tests/unit/utils/rpc.test.js b/tests/unit/utils/rpc.test.js
index 8be83f7..2113fca 100644
--- a/tests/unit/utils/rpc.test.js
+++ b/tests/unit/utils/rpc.test.js
@@ -63,7 +63,7 @@ describe('RPC Failover', () => {
     test('should always include public endpoint as fallback', () => {
       pool.initialize();
 
-      const publicEndpoint = pool.endpoints.find(e => e.name === 'public');
+      const publicEndpoint = pool.endpoints.find((e) => e.name === 'public');
       expect(publicEndpoint).toBeDefined();
       expect(publicEndpoint.priority).toBe(100);
     });
@@ -72,9 +72,7 @@ describe('RPC Failover', () => {
       pool.initialize();
 
       for (let i = 1; i < pool.endpoints.length; i++) {
-        expect(pool.endpoints[i].priority).toBeGreaterThanOrEqual(
-          pool.endpoints[i - 1].priority
-        );
+        expect(pool.endpoints[i].priority).toBeGreaterThanOrEqual(pool.endpoints[i - 1].priority);
       }
     });
 
@@ -113,7 +111,7 @@ describe('RPC Failover', () => {
       pool.initialize();
 
       // Force all circuits open
-      pool.endpoints.forEach(e => e.breaker.forceOpen());
+      pool.endpoints.forEach((e) => e.breaker.forceOpen());
 
       const status = pool.getStatus();
 
@@ -138,10 +136,7 @@ describe('RPC Failover', () => {
     test('should use primary endpoint when healthy', async () => {
       pool.initialize();
 
-      const result = await pool.executeWithFailover(
-        async (conn) => conn.getSlot(),
-        'getSlot'
-      );
+      const result = await pool.executeWithFailover(async (conn) => conn.getSlot(), 'getSlot');
 
       expect(result).toBe(12345678);
       expect(pool.endpoints[0].health.totalRequests).toBe(1);
@@ -153,10 +148,7 @@ describe('RPC Failover', () => {
       // Make primary always fail
       pool.endpoints[0].breaker.forceOpen();
 
-      const result = await pool.executeWithFailover(
-        async (conn) => conn.getSlot(),
-        'getSlot'
-      );
+      const result = await pool.executeWithFailover(async (conn) => conn.getSlot(), 'getSlot');
 
       expect(result).toBe(12345678);
       // Secondary should have been used
@@ -167,13 +159,12 @@ describe('RPC Failover', () => {
       pool.initialize();
 
       // Force all circuits open
-      pool.endpoints.forEach(e => e.breaker.forceOpen());
+      pool.endpoints.forEach((e) => e.breaker.forceOpen());
 
       await expect(
-        pool.executeWithFailover(
-          async () => { throw new Error('Connection failed'); },
-          'test'
-        )
+        pool.executeWithFailover(async () => {
+          throw new Error('Connection failed');
+        }, 'test')
       ).rejects.toThrow();
     });
   });
