<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>GASdf - Pay Gas With Any Token | Solana</title>
  <meta name="description" content="No SOL? No problem. Pay Solana gas fees with any token. All fees become $asdfasdfa and burn forever.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --phi: 1.618033988749;
      --space-xs: 8px;
      --space-sm: 13px;
      --space-md: 21px;
      --space-lg: 34px;
      --space-xl: 55px;
      --space-2xl: 89px;

      --text-xs: 12px;
      --text-sm: 14px;
      --text-md: 16px;
      --text-lg: 20px;
      --text-xl: 28px;
      --text-2xl: 40px;
      --text-3xl: 56px;

      --white: #ffffff;
      --white-90: rgba(255,255,255,0.9);
      --white-70: rgba(255,255,255,0.7);
      --white-50: rgba(255,255,255,0.5);
      --white-30: rgba(255,255,255,0.3);
      --white-10: rgba(255,255,255,0.1);
      --white-05: rgba(255,255,255,0.05);
      --gold: #c9a227;
      --gold-soft: rgba(201,162,39,0.15);
      --flame: #ff6b35;
      --bg: #050508;
    }

    html { scroll-behavior: smooth; }

    body {
      background: var(--bg);
      font-family: 'Inter', -apple-system, sans-serif;
      color: var(--white);
      -webkit-font-smoothing: antialiased;
      font-weight: 300;
      line-height: 1.6;
      overflow-x: hidden;
    }

    /* Canvas Background */
    #singularity-bg {
      position: fixed;
      inset: 0;
      z-index: 0;
      opacity: 0.7;
    }

    /* Content Layer */
    .content {
      position: relative;
      z-index: 10;
    }

    /* Navigation */
    nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      padding: var(--space-md) var(--space-lg);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(180deg, rgba(5,5,8,0.95) 0%, transparent 100%);
    }

    .logo {
      font-size: var(--text-sm);
      font-weight: 500;
      letter-spacing: 0.05em;
    }
    .logo span { color: var(--gold); }

    .nav-links {
      display: flex;
      gap: var(--space-lg);
    }

    .nav-links a {
      color: var(--white-50);
      text-decoration: none;
      font-size: var(--text-xs);
      font-weight: 400;
      transition: color 0.2s;
    }

    .nav-links a:hover { color: var(--white); }

    .nav-cta {
      background: var(--gold);
      color: var(--bg);
      border: none;
      padding: var(--space-xs) var(--space-md);
      border-radius: 6px;
      font-size: var(--text-xs);
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .nav-cta:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 20px rgba(201,162,39,0.3);
    }

    /* Sections */
    section {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: var(--space-2xl) var(--space-lg);
      position: relative;
    }

    .container {
      width: 100%;
      max-width: 900px;
      margin: 0 auto;
    }

    /* Typography */
    .display-title {
      font-size: clamp(var(--text-2xl), 8vw, var(--text-3xl));
      font-weight: 200;
      letter-spacing: -0.03em;
      line-height: 1.1;
      margin-bottom: var(--space-md);
    }

    .section-title {
      font-size: clamp(var(--text-xl), 5vw, var(--text-2xl));
      font-weight: 200;
      letter-spacing: -0.02em;
      line-height: 1.15;
      margin-bottom: var(--space-sm);
    }

    .highlight { color: var(--gold); }
    .flame { color: var(--flame); }

    .body-text {
      font-size: var(--text-md);
      color: var(--white-70);
      max-width: 500px;
    }

    .label {
      font-size: var(--text-xs);
      font-weight: 500;
      color: var(--white-50);
      text-transform: uppercase;
      letter-spacing: 0.15em;
      margin-bottom: var(--space-md);
    }

    /* Hero */
    #hero { min-height: 100vh; text-align: center; }

    .hero-badge {
      display: inline-flex;
      align-items: center;
      gap: var(--space-xs);
      background: var(--white-05);
      border: 1px solid var(--white-10);
      padding: var(--space-xs) var(--space-md);
      border-radius: 20px;
      font-size: var(--text-xs);
      color: var(--white-70);
      margin-bottom: var(--space-lg);
    }

    .live-dot {
      width: 6px;
      height: 6px;
      background: #00ff88;
      border-radius: 50%;
      animation: pulse-live 2s infinite;
    }

    @keyframes pulse-live {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .hero-subtitle {
      font-size: var(--text-lg);
      color: var(--white-70);
      margin-bottom: var(--space-xl);
    }

    .hero-cta {
      background: var(--gold);
      color: var(--bg);
      border: none;
      padding: var(--space-md) var(--space-xl);
      border-radius: 8px;
      font-size: var(--text-md);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: var(--space-xl);
    }

    .hero-cta:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(201,162,39,0.4);
    }

    .hero-stats {
      display: flex;
      justify-content: center;
      gap: var(--space-2xl);
      margin-bottom: var(--space-lg);
    }

    .stat-value {
      font-size: var(--text-xl);
      font-weight: 300;
      font-variant-numeric: tabular-nums;
    }

    .stat-label {
      font-size: var(--text-xs);
      color: var(--white-50);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-top: 4px;
    }

    .scroll-hint {
      color: var(--white-30);
      font-size: var(--text-xs);
      cursor: pointer;
    }

    /* Steps */
    .steps {
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
    }

    .step {
      display: flex;
      gap: var(--space-lg);
      align-items: flex-start;
      padding: var(--space-lg);
      background: var(--white-05);
      border: 1px solid var(--white-10);
      border-radius: 12px;
      transition: border-color 0.3s;
    }

    .step:hover { border-color: var(--white-30); }

    .step-number {
      font-size: var(--text-2xl);
      font-weight: 200;
      color: var(--gold);
      opacity: 0.5;
    }

    .step-title {
      font-size: var(--text-lg);
      font-weight: 400;
      margin-bottom: 4px;
    }

    .step-desc {
      font-size: var(--text-sm);
      color: var(--white-50);
    }

    /* Ecosystem Section */
    #ecosystem {
      min-height: 100vh;
      background: radial-gradient(ellipse at center, rgba(201,162,39,0.05) 0%, transparent 60%);
    }

    .ecosystem-header {
      text-align: center;
      margin-bottom: var(--space-xl);
    }

    .token-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: var(--space-md);
      margin-top: var(--space-xl);
    }

    .token-card {
      background: var(--white-05);
      border: 1px solid var(--white-10);
      border-radius: 10px;
      padding: var(--space-md);
      text-align: center;
      transition: all 0.3s;
    }

    .token-card:hover {
      border-color: var(--white-30);
      transform: translateY(-2px);
    }

    .token-icon {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      margin: 0 auto var(--space-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--text-xs);
      font-weight: 600;
    }

    .token-symbol {
      font-size: var(--text-sm);
      font-weight: 500;
      margin-bottom: 2px;
    }

    .token-burn {
      font-size: var(--text-xs);
      color: var(--flame);
    }

    /* Tiers */
    .tiers-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: var(--space-sm);
      margin: var(--space-xl) 0;
    }

    .tier {
      background: var(--white-05);
      border: 1px solid var(--white-10);
      border-radius: 10px;
      padding: var(--space-md);
      text-align: center;
      transition: all 0.3s;
    }

    .tier:hover {
      border-color: var(--gold-soft);
      background: var(--gold-soft);
    }

    .tier-emoji { font-size: var(--text-xl); margin-bottom: var(--space-xs); }
    .tier-name { font-size: var(--text-xs); font-weight: 600; letter-spacing: 0.05em; margin-bottom: var(--space-xs); }
    .tier-discount { font-size: var(--text-lg); font-weight: 300; color: var(--gold); margin-bottom: var(--space-xs); }
    .tier-tokens { font-size: var(--text-xs); color: var(--white-50); }
    .tier-usd { font-size: var(--text-xs); color: var(--white-30); margin-top: 2px; }

    .tier-note {
      text-align: center;
      font-size: var(--text-xs);
      color: var(--white-50);
      margin-top: var(--space-md);
    }

    /* Phi Section */
    .phi-symbol {
      font-size: 80px;
      font-weight: 200;
      color: var(--gold);
      text-align: center;
      margin-bottom: var(--space-md);
      text-shadow: 0 0 60px rgba(201,162,39,0.3);
    }

    .phi-value {
      font-family: monospace;
      font-size: var(--text-sm);
      color: var(--white-30);
      text-align: center;
      margin-top: var(--space-sm);
    }

    .formulas {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--space-md);
      margin-top: var(--space-xl);
    }

    .formula {
      background: var(--white-05);
      border: 1px solid var(--white-10);
      border-radius: 10px;
      padding: var(--space-lg);
      text-align: center;
    }

    .formula-label {
      font-size: 10px;
      font-weight: 600;
      color: var(--white-30);
      letter-spacing: 0.15em;
      margin-bottom: var(--space-sm);
    }

    .formula-code {
      font-family: monospace;
      font-size: var(--text-xs);
      color: var(--white-50);
      margin-bottom: var(--space-sm);
    }

    .formula-result {
      font-size: var(--text-lg);
      font-weight: 300;
    }

    /* CTA Section */
    #cta {
      text-align: center;
      background: radial-gradient(ellipse at center, rgba(201,162,39,0.1) 0%, transparent 50%);
    }

    .cta-buttons {
      display: flex;
      justify-content: center;
      gap: var(--space-md);
      margin-top: var(--space-xl);
    }

    .cta-primary {
      background: var(--gold);
      color: var(--bg);
      border: none;
      padding: var(--space-md) var(--space-xl);
      border-radius: 8px;
      font-size: var(--text-md);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .cta-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(201,162,39,0.4);
    }

    .cta-secondary {
      background: transparent;
      color: var(--white);
      border: 1px solid var(--white-30);
      padding: var(--space-md) var(--space-xl);
      border-radius: 8px;
      font-size: var(--text-md);
      cursor: pointer;
      transition: all 0.3s;
      text-decoration: none;
    }

    .cta-secondary:hover {
      border-color: var(--white);
      background: var(--white-05);
    }

    /* Footer */
    footer {
      padding: var(--space-xl) var(--space-lg);
      text-align: center;
      border-top: 1px solid var(--white-10);
    }

    .footer-links {
      display: flex;
      justify-content: center;
      gap: var(--space-lg);
      margin-bottom: var(--space-md);
    }

    .footer-links a {
      color: var(--white-50);
      text-decoration: none;
      font-size: var(--text-xs);
    }

    .footer-links a:hover { color: var(--white); }

    .footer-copy {
      font-size: var(--text-xs);
      color: var(--white-30);
    }

    /* Progress dots in nav */
    .nav-progress {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .progress-dots {
      display: flex;
      gap: 4px;
    }

    .progress-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--white-10);
      transition: all 0.4s;
    }

    .progress-dot.active {
      background: var(--gold);
      box-shadow: 0 0 10px var(--gold);
    }

    .progress-label {
      font-size: var(--text-xs);
      color: var(--gold);
      font-weight: 500;
    }

    /* Live ticker */
    .live-ticker {
      display: inline-flex;
      align-items: center;
      gap: var(--space-sm);
      padding: var(--space-sm) var(--space-md);
      background: rgba(201,162,39,0.08);
      border: 1px solid rgba(201,162,39,0.15);
      border-radius: 100px;
      font-size: var(--text-xs);
      color: var(--gold);
      margin-bottom: var(--space-lg);
    }

    .ticker-icon {
      animation: pulse-ticker 1.5s ease-in-out infinite;
    }

    @keyframes pulse-ticker {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(0.9); }
    }

    .ticker-text {
      transition: opacity 0.5s ease;
    }

    /* Token stats bar */
    .token-stats {
      display: flex;
      justify-content: center;
      gap: var(--space-xl);
      margin: var(--space-lg) 0;
      padding: var(--space-md) var(--space-xl);
      background: var(--white-05);
      border: 1px solid var(--white-10);
      border-radius: 10px;
    }

    .token-stat {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .token-stat-value {
      font-size: var(--text-lg);
      font-weight: 400;
      color: var(--white);
      font-variant-numeric: tabular-nums;
    }

    .token-stat-label {
      font-size: var(--text-xs);
      color: var(--white-50);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    /* Tier footer */
    .tier-footer {
      text-align: center;
      margin-top: var(--space-md);
      padding-top: var(--space-md);
      border-top: 1px solid var(--white-10);
    }

    .tier-footer a {
      color: var(--gold);
      text-decoration: none;
    }

    .tier-update-time {
      font-size: var(--text-xs);
      color: var(--white-30);
    }

    /* CTA secondary link */
    .cta-secondary-link {
      display: inline-flex;
      align-items: center;
      gap: var(--space-xs);
      font-size: var(--text-xs);
      color: var(--gold);
      text-decoration: none;
      cursor: pointer;
      margin-top: var(--space-lg);
      transition: gap 0.3s ease;
    }

    .cta-secondary-link:hover {
      gap: var(--space-sm);
    }

    .cta-secondary-link::after {
      content: '‚Üí';
      transition: transform 0.3s ease;
    }

    .cta-secondary-link:hover::after {
      transform: translateX(4px);
    }

    /* Counter animation */
    .counter-animated {
      display: inline-block;
      transition: transform 0.3s ease, color 0.3s ease;
    }

    .counter-animated.bump {
      transform: scale(1.1);
      color: var(--gold);
    }

    /* Tooltip */
    .tooltip-trigger {
      border-bottom: 1px dotted var(--white-30);
      cursor: help;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .nav-links { display: none; }
      .nav-progress { display: none; }
      .hero-stats { flex-direction: column; gap: var(--space-lg); }
      .tiers-grid { grid-template-columns: repeat(2, 1fr); }
      .tiers-grid .tier:last-child { grid-column: span 2; }
      .formulas { grid-template-columns: 1fr; }
      .cta-buttons { flex-direction: column; }
      .token-stats { flex-wrap: wrap; gap: var(--space-md); }
    }

    /* Reveal animation */
    .reveal {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.6s ease, transform 0.6s ease;
    }

    .reveal.visible {
      opacity: 1;
      transform: translateY(0);
    }
  </style>
</head>
<body>
  <canvas id="singularity-bg"></canvas>

  <nav>
    <div class="logo">GAS<span>df</span></div>
    <div class="nav-progress">
      <div class="progress-dots">
        <span class="progress-dot active" data-section="hero"></span>
        <span class="progress-dot" data-section="how"></span>
        <span class="progress-dot" data-section="ecosystem"></span>
        <span class="progress-dot" data-section="phi"></span>
        <span class="progress-dot" data-section="cta"></span>
      </div>
      <span class="progress-label">Explorer</span>
    </div>
    <div class="nav-links">
      <a href="#how">How it works</a>
      <a href="#ecosystem">Ecosystem</a>
      <a href="#tiers">Tiers</a>
      <a href="#phi">Mathematics</a>
    </div>
    <button class="nav-cta">LAUNCH APP</button>
  </nav>

  <div class="content">

    <!-- HERO -->
    <section id="hero">
      <div class="container">
        <div class="hero-badge reveal">
          <span class="live-dot"></span>
          Live on Solana Mainnet
        </div>
        <h1 class="display-title reveal">
          No SOL?<br>
          <span class="highlight">No problem.</span>
        </h1>
        <p class="hero-subtitle reveal">
          Pay gas with <strong>any token</strong>. We turn it into <span class="highlight">$asdfasdfa</span> and burn <span class="tooltip-trigger" id="burnRateHero">76.4%</span> forever.
        </p>

        <div class="live-ticker reveal">
          <span class="ticker-icon">üî•</span>
          <span class="ticker-text" id="liveTicker">Loading live burns...</span>
        </div>

        <button class="hero-cta reveal">START BURNING</button>
        <div class="hero-stats reveal">
          <div>
            <div class="stat-value flame counter-animated" id="statBurned">$0</div>
            <div class="stat-label">Total Burned</div>
          </div>
          <div>
            <div class="stat-value counter-animated" id="statTx">0</div>
            <div class="stat-label">Transactions</div>
          </div>
          <div>
            <div class="stat-value highlight" id="burnRateStat">76.4%</div>
            <div class="stat-label">Burn Rate</div>
          </div>
        </div>
        <div class="cta-secondary-link reveal" onclick="document.getElementById('how').scrollIntoView({behavior:'smooth'})">
          See how it works
        </div>
      </div>
    </section>

    <!-- HOW IT WORKS -->
    <section id="how">
      <div class="container">
        <div class="label reveal">The Process</div>
        <h2 class="section-title reveal">Three steps to <span class="highlight">freedom</span></h2>
        <div class="steps">
          <div class="step reveal">
            <div class="step-number">01</div>
            <div>
              <div class="step-title">Pick <span class="highlight">your</span> token</div>
              <div class="step-desc">SOL, USDC, JUP, or any Bronze+ verified token from HolDex. Your choice.</div>
            </div>
          </div>
          <div class="step reveal">
            <div class="step-number">02</div>
            <div>
              <div class="step-title">We cover the <span class="highlight">SOL</span></div>
              <div class="step-desc">GASdf fronts the network fee. You pay in your favorite token. Simple.</div>
            </div>
          </div>
          <div class="step reveal">
            <div class="step-number">03</div>
            <div>
              <div class="step-title">Swap ‚Üí <span class="flame">Burn</span></div>
              <div class="step-desc">Your payment becomes $asdfasdfa. <span id="burnRateStep">76.4%</span> burned, rest sustains operations.</div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- ECOSYSTEM -->
    <section id="ecosystem">
      <div class="container">
        <div class="ecosystem-header">
          <div class="label reveal">Solana Ecosystem</div>
          <h2 class="section-title reveal">All roads lead to <span class="flame">the singularity</span></h2>
          <p class="body-text reveal" style="margin: 0 auto;">
            Every accepted token flows to the center. Different tokens, different burn rates.<br>
            <span style="color: var(--white-50);">Look ahead ‚Äî the singularity awaits.</span>
          </p>
        </div>

        <div class="token-grid reveal" id="tokenGrid">
          <!-- Populated by JS -->
        </div>
      </div>
    </section>

    <!-- TIERS -->
    <section id="tiers">
      <div class="container">
        <div style="text-align: center;">
          <div class="label reveal">Holder Benefits</div>
          <h2 class="section-title reveal">Hold $asdfasdfa = <span class="highlight">Pay less</span></h2>
          <p class="body-text reveal" style="margin: 0 auto var(--space-md);">
            The more you hold, the bigger your discount. Formula-based, transparent.
          </p>

          <!-- Live token stats -->
          <div class="token-stats reveal">
            <div class="token-stat">
              <span class="token-stat-value" id="tokenPrice">$0.00000</span>
              <span class="token-stat-label">Price</span>
            </div>
            <div class="token-stat">
              <span class="token-stat-value" id="tokenMcap">$0</span>
              <span class="token-stat-label">Market Cap</span>
            </div>
            <div class="token-stat">
              <span class="token-stat-value" id="tokenHolders">0</span>
              <span class="token-stat-label">Holders</span>
            </div>
          </div>
        </div>

        <div class="tiers-grid reveal">
          <div class="tier" data-tier="diamond">
            <div class="tier-emoji">üíé</div>
            <div class="tier-name">DIAMOND</div>
            <div class="tier-discount" id="diamondDiscount">-95%</div>
            <div class="tier-tokens" id="diamondTokens">1% supply</div>
            <div class="tier-usd" id="diamondUsd">~$0</div>
          </div>
          <div class="tier" data-tier="platinum">
            <div class="tier-emoji">ü™ô</div>
            <div class="tier-name">PLATINUM</div>
            <div class="tier-discount" id="platinumDiscount">-67%</div>
            <div class="tier-tokens" id="platinumTokens">0.1% supply</div>
            <div class="tier-usd" id="platinumUsd">~$0</div>
          </div>
          <div class="tier" data-tier="gold">
            <div class="tier-emoji">ü•á</div>
            <div class="tier-name">GOLD</div>
            <div class="tier-discount" id="goldDiscount">-33%</div>
            <div class="tier-tokens" id="goldTokens">0.01% supply</div>
            <div class="tier-usd" id="goldUsd">~$0</div>
          </div>
          <div class="tier" data-tier="silver">
            <div class="tier-emoji">ü•à</div>
            <div class="tier-name">SILVER</div>
            <div class="tier-discount" id="silverDiscount">0%</div>
            <div class="tier-tokens" id="silverTokens">0.001% supply</div>
            <div class="tier-usd" id="silverUsd">~$0</div>
          </div>
          <div class="tier" data-tier="bronze">
            <div class="tier-emoji">ü•â</div>
            <div class="tier-name">BRONZE</div>
            <div class="tier-discount" id="bronzeDiscount">0%</div>
            <div class="tier-tokens">Any amount</div>
            <div class="tier-usd">Base rate</div>
          </div>
        </div>

        <p class="tier-note reveal">
          Max discount on service fee* ‚Äî break-even floor ensures tx costs are always covered
        </p>

        <div class="tier-footer reveal">
          <span class="tier-update-time">Live from <a href="https://holdex.asdfasdfa.tech" target="_blank">HolDex</a> ‚Ä¢ Updated <span id="tierUpdateTime">just now</span></span>
        </div>
      </div>
    </section>

    <!-- PHI -->
    <section id="phi">
      <div class="container" style="text-align: center;">
        <div class="phi-symbol reveal">œÜ</div>
        <h2 class="section-title reveal">Powered by <span class="highlight">mathematics</span></h2>
        <p class="body-text reveal" style="margin: 0 auto;">
          Every rate, every split, every curve ‚Äî derived from the golden ratio.
        </p>
        <div class="phi-value reveal">1.618033988749894</div>

        <div class="formulas">
          <div class="formula reveal">
            <div class="formula-label">BURN SPLIT</div>
            <div class="formula-code">1 ‚àí 1/œÜ¬≥</div>
            <div class="formula-result"><span class="flame">üî•</span> <span id="burnRatePhi">76.4%</span></div>
          </div>
          <div class="formula reveal">
            <div class="formula-label">MAX DISCOUNT</div>
            <div class="formula-code">min(95%, log‚ÇÅ‚ÇÄ curve)</div>
            <div class="formula-result"><span class="highlight" id="maxDiscountPhi">95%</span></div>
          </div>
          <div class="formula reveal">
            <div class="formula-label">ECO BONUS</div>
            <div class="formula-code">1/œÜ¬≤ √ó decay</div>
            <div class="formula-result"><span class="highlight">+<span id="ecosystemBonusPhi">38.2%</span></span></div>
          </div>
        </div>
      </div>
    </section>

    <!-- CTA -->
    <section id="cta">
      <div class="container">
        <h2 class="section-title reveal">Ready to <span class="highlight">break free</span>?</h2>
        <p class="body-text reveal" style="text-align: center; margin: 0 auto;">
          Connect your wallet. Pay with any token. Watch it burn forever.
        </p>
        <div class="cta-buttons reveal">
          <button class="cta-primary">LAUNCH APP</button>
          <a href="https://github.com/zeyxx/GASdf" target="_blank" class="cta-secondary">View on GitHub</a>
        </div>
      </div>
    </section>

    <footer>
      <div class="footer-links">
        <a href="https://github.com/zeyxx/GASdf" target="_blank">GitHub</a>
        <a href="https://x.com/asdfasdfa_" target="_blank">Twitter</a>
        <a href="https://holdex.asdfasdfa.tech" target="_blank">HolDex</a>
      </div>
      <div class="footer-copy">Built for Solana. Powered by œÜ.</div>
    </footer>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // ========================================================================
    // GOLDEN RATIO - Single source of truth
    // ========================================================================
    const PHI = 1.618033988749894;
    const PHI_SQUARED = PHI * PHI;
    const PHI_CUBED = PHI * PHI * PHI;
    const BURN_RATE = 1 - (1 / PHI_CUBED);
    const TREASURY_RATE = 1 / PHI_CUBED;
    const MAX_ECO_BONUS = 1 / PHI_SQUARED;
    const MAX_DISCOUNT = 0.95;

    // Tier thresholds
    const TIER_THRESHOLDS = {
      diamond: 0.01,
      platinum: 0.001,
      gold: 0.0001,
      silver: 0.00001,
      bronze: 0,
    };

    // ========================================================================
    // SOLANA TOKENS
    // ========================================================================
    const TOKENS = [
      { symbol: 'SOL', name: 'Solana', color: '#9945FF', kscore: 95, burnedPct: 0 },
      { symbol: 'JUP', name: 'Jupiter', color: '#d4a574', kscore: 92, burnedPct: 8.5 },
      { symbol: 'USDC', name: 'USD Coin', color: '#2775CA', kscore: 88, burnedPct: 0 },
      { symbol: 'mSOL', name: 'Marinade', color: '#00D18C', kscore: 85, burnedPct: 0 },
      { symbol: 'BONK', name: 'Bonk', color: '#F7931A', kscore: 72, burnedPct: 45 },
      { symbol: 'RAY', name: 'Raydium', color: '#14F195', kscore: 78, burnedPct: 12 },
    ];

    // ========================================================================
    // FORMULAS
    // ========================================================================
    function formatRate(rate) {
      return (rate * 100).toFixed(1) + '%';
    }

    function calculateDiscountFromShare(share) {
      if (share <= 0) return 0;
      const logShare = Math.log10(share);
      return Math.min(MAX_DISCOUNT, Math.max(0, (logShare + 5) / 3));
    }

    function formatDiscount(share) {
      const d = calculateDiscountFromShare(share);
      return d > 0 ? `-${Math.round(d * 100)}%` : '0%';
    }

    function calculateEcoBurn(burnedPct) {
      if (burnedPct <= 0) return 0;
      return MAX_ECO_BONUS * (1 - Math.pow(PHI, -burnedPct / 30));
    }

    // ========================================================================
    // INITIALIZE PHI VALUES
    // ========================================================================
    function initPhiValues() {
      const burnStr = formatRate(BURN_RATE);
      const ecoStr = formatRate(MAX_ECO_BONUS);

      document.getElementById('burnRateHero').textContent = burnStr;
      document.getElementById('burnRateStat').textContent = burnStr;
      document.getElementById('burnRateStep').textContent = burnStr;
      document.getElementById('burnRatePhi').textContent = burnStr;
      document.getElementById('ecosystemBonusPhi').textContent = ecoStr;
      document.getElementById('maxDiscountPhi').textContent = Math.round(MAX_DISCOUNT * 100) + '%';

      document.getElementById('diamondDiscount').textContent = formatDiscount(TIER_THRESHOLDS.diamond);
      document.getElementById('platinumDiscount').textContent = formatDiscount(TIER_THRESHOLDS.platinum);
      document.getElementById('goldDiscount').textContent = formatDiscount(TIER_THRESHOLDS.gold);
      document.getElementById('silverDiscount').textContent = formatDiscount(TIER_THRESHOLDS.silver);
      document.getElementById('bronzeDiscount').textContent = formatDiscount(TIER_THRESHOLDS.bronze);
    }

    // ========================================================================
    // TOKEN GRID
    // ========================================================================
    function renderTokenGrid() {
      const grid = document.getElementById('tokenGrid');
      grid.innerHTML = TOKENS.map(t => {
        const eco = calculateEcoBurn(t.burnedPct);
        const total = BURN_RATE + eco;
        return `
          <div class="token-card">
            <div class="token-icon" style="background: ${t.color}">${t.symbol.slice(0,2)}</div>
            <div class="token-symbol">${t.symbol}</div>
            <div class="token-burn">${formatRate(total)} burn</div>
          </div>
        `;
      }).join('');
    }

    // ========================================================================
    // VR SPACE RENDERER - Journey to the Singularity
    // ========================================================================
    class SpaceRenderer {
      constructor(container) {
        this.container = container;
        this.time = 0;
        this.scrollY = 0;
        this.targetScrollY = 0;
        this.scrollVelocity = 0;
        this.scrollProgress = 0;
        this.maxScroll = 1;

        // Enhanced mouse parallax
        this.mouseX = 0;
        this.mouseY = 0;
        this.targetMouseX = 0;
        this.targetMouseY = 0;
        this.mouseParallaxIntensity = 3.5; // Intensit√© augment√©e

        this.init();
        this.createStars();
        this.createMilkyWay();
        this.createNebulae();
        this.createCosmicDust();
        this.createSingularity(); // La destination !
        this.setupPostProcessing();
        this.animate();
        this.setupEventListeners();
      }

      init() {
        this.scene = new THREE.Scene();

        this.camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          10000
        );
        this.camera.position.z = 5;

        this.renderer = new THREE.WebGLRenderer({
          canvas: this.container,
          antialias: true,
          alpha: true,
          powerPreference: 'high-performance'
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.setClearColor(0x000000, 1);
      }

      // ====================================================================
      // STARS - Realistic stellar distribution
      // ====================================================================
      createStars() {
        const spectralColors = [
          new THREE.Color(0x9bb0ff), // O - Blue
          new THREE.Color(0xaabfff), // B - Blue-white
          new THREE.Color(0xcad7ff), // A - White
          new THREE.Color(0xf8f7ff), // F - Yellow-white
          new THREE.Color(0xfff4e8), // G - Yellow (Sun-like)
          new THREE.Color(0xffd2a1), // K - Orange
          new THREE.Color(0xffbb7b), // M - Red
        ];

        const spectralProbs = [0.00003, 0.0013, 0.006, 0.03, 0.076, 0.121, 0.765];

        const starCount = 15000;
        const positions = new Float32Array(starCount * 3);
        const colors = new Float32Array(starCount * 3);
        const sizes = new Float32Array(starCount);
        const brightness = new Float32Array(starCount);

        for (let i = 0; i < starCount; i++) {
          const i3 = i * 3;

          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const radius = 500 + Math.random() * 1500;

          positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
          positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
          positions[i3 + 2] = radius * Math.cos(phi);

          let rand = Math.random();
          let cumulative = 0;
          let spectralIndex = 6;
          for (let j = 0; j < spectralProbs.length; j++) {
            cumulative += spectralProbs[j];
            if (rand < cumulative) {
              spectralIndex = j;
              break;
            }
          }

          const color = spectralColors[spectralIndex];
          colors[i3] = color.r;
          colors[i3 + 1] = color.g;
          colors[i3 + 2] = color.b;

          const magRand = Math.random();
          let magnitude;
          if (magRand < 0.002) magnitude = 0 + Math.random();
          else if (magRand < 0.02) magnitude = 1 + Math.random();
          else if (magRand < 0.1) magnitude = 2 + Math.random();
          else if (magRand < 0.3) magnitude = 3 + Math.random();
          else magnitude = 4 + Math.random() * 2;

          sizes[i] = magnitude < 1 ? 3.0 : magnitude < 2 ? 2.0 : magnitude < 3 ? 1.2 : 0.6;
          brightness[i] = Math.pow(2.512, (5 - magnitude) / 2.5);
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('brightness', new THREE.BufferAttribute(brightness, 1));

        const starMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            pixelRatio: { value: this.renderer.getPixelRatio() },
            warpSpeed: { value: 0 }
          },
          vertexShader: `
            attribute float size;
            attribute float brightness;
            varying vec3 vColor;
            varying float vBrightness;
            uniform float time;
            uniform float pixelRatio;
            uniform float warpSpeed;

            void main() {
              vColor = color;
              vBrightness = brightness;
              vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
              float sizeVar = 1.0 + sin(time * 0.5 + position.x * 0.01) * 0.15;
              float warpBoost = 1.0 + warpSpeed * 2.0;
              gl_PointSize = size * sizeVar * warpBoost * pixelRatio * (300.0 / -mvPosition.z);
              gl_Position = projectionMatrix * mvPosition;
            }
          `,
          fragmentShader: `
            varying vec3 vColor;
            varying float vBrightness;
            uniform float warpSpeed;

            void main() {
              vec2 uv = gl_PointCoord - 0.5;
              float dist = length(uv);
              float core = exp(-dist * 6.0);
              float glow = exp(-dist * 2.5) * 0.3;

              float spikes = 0.0;
              if (vBrightness > 0.5) {
                float spikeV = exp(-abs(uv.x) * 25.0) * exp(-abs(uv.y) * 3.0);
                float spikeH = exp(-abs(uv.y) * 25.0) * exp(-abs(uv.x) * 3.0);
                spikes = (spikeV + spikeH) * vBrightness * 0.25;
              }

              // Warp trail effect
              float trail = 0.0;
              if (warpSpeed > 0.1) {
                trail = exp(-abs(uv.x) * 10.0) * smoothstep(0.5, -0.5, uv.y) * warpSpeed * 0.8;
              }

              float alpha = (core + glow + spikes + trail) * vBrightness;
              gl_FragColor = vec4(vColor, clamp(alpha, 0.0, 1.0));
            }
          `,
          transparent: true,
          vertexColors: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending
        });

        this.stars = new THREE.Points(geometry, starMaterial);
        this.scene.add(this.stars);
      }

      // ====================================================================
      // MILKY WAY - Organic particle cloud
      // ====================================================================
      createMilkyWay() {
        const particleCount = 6000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const alphas = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          const x = (Math.random() - 0.5) * 2500;
          const ySpread = 60 + Math.random() * 100;
          const y = (Math.random() - 0.5) * ySpread;
          const z = -500 - Math.random() * 700;

          positions[i3] = x;
          positions[i3 + 1] = y;
          positions[i3 + 2] = z;

          const warmth = 0.85 + Math.random() * 0.15;
          colors[i3] = warmth;
          colors[i3 + 1] = warmth * 0.9;
          colors[i3 + 2] = warmth * 0.7;

          sizes[i] = 1 + Math.random() * 2.5;
          const distFromCenter = Math.abs(y) / 80;
          alphas[i] = (1 - distFromCenter) * (0.015 + Math.random() * 0.025);
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));

        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            globalOpacity: { value: 1.0 }
          },
          vertexShader: `
            attribute float size;
            attribute float alpha;
            varying vec3 vColor;
            varying float vAlpha;
            uniform float time;

            void main() {
              vColor = color;
              vAlpha = alpha;
              vec3 pos = position;
              pos.x += sin(time * 0.08 + position.z * 0.01) * 3.0;
              pos.y += cos(time * 0.06 + position.x * 0.01) * 1.5;
              vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
              gl_PointSize = size * (400.0 / -mvPosition.z);
              gl_Position = projectionMatrix * mvPosition;
            }
          `,
          fragmentShader: `
            varying vec3 vColor;
            varying float vAlpha;
            uniform float globalOpacity;

            void main() {
              vec2 center = gl_PointCoord - 0.5;
              float dist = length(center);
              float alpha = smoothstep(0.5, 0.0, dist) * vAlpha * globalOpacity;
              gl_FragColor = vec4(vColor, alpha);
            }
          `,
          transparent: true,
          vertexColors: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending
        });

        this.milkyWay = new THREE.Points(geometry, material);
        this.milkyWay.rotation.z = -15 * Math.PI / 180;
        this.scene.add(this.milkyWay);
      }

      // ====================================================================
      // NEBULAE - Volumetric emission nebulae
      // ====================================================================
      createNebulae() {
        this.nebulae = [];

        const nebulaConfigs = [
          { x: -400, y: 200, z: -600, size: 300, color: new THREE.Color(0x4466aa), opacity: 0.04 },
          { x: 500, y: -150, z: -700, size: 250, color: new THREE.Color(0x884488), opacity: 0.035 },
          { x: -200, y: -300, z: -500, size: 200, color: new THREE.Color(0xaa4455), opacity: 0.03 },
          { x: 300, y: 400, z: -900, size: 350, color: new THREE.Color(0x446688), opacity: 0.025 },
        ];

        const nebulaGeometry = new THREE.PlaneGeometry(1, 1);

        nebulaConfigs.forEach(config => {
          const material = new THREE.ShaderMaterial({
            uniforms: {
              time: { value: 0 },
              baseColor: { value: config.color },
              opacity: { value: config.opacity }
            },
            vertexShader: `
              varying vec2 vUv;
              void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,
            fragmentShader: `
              uniform float time;
              uniform vec3 baseColor;
              uniform float opacity;
              varying vec2 vUv;

              // FBM noise
              float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
              }

              float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);

                float a = hash(i);
                float b = hash(i + vec2(1.0, 0.0));
                float c = hash(i + vec2(0.0, 1.0));
                float d = hash(i + vec2(1.0, 1.0));

                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
              }

              float fbm(vec2 p) {
                float value = 0.0;
                float amplitude = 0.5;
                for (int i = 0; i < 5; i++) {
                  value += amplitude * noise(p);
                  p *= 2.0;
                  amplitude *= 0.5;
                }
                return value;
              }

              void main() {
                vec2 uv = vUv - 0.5;
                float dist = length(uv);

                // Radial falloff
                float falloff = 1.0 - smoothstep(0.0, 0.5, dist);
                falloff = pow(falloff, 1.5);

                // Animated noise - 3 layers like vr-space-v1
                float n1 = fbm(uv * 3.0 + time * 0.02);
                float n2 = fbm(uv * 5.0 - time * 0.015);
                float n3 = fbm(uv * 8.0 + time * 0.01);

                float structure = n1 * 0.5 + n2 * 0.3 + n3 * 0.2;

                // Color variation
                vec3 color = baseColor;
                color += vec3(n1 * 0.2, n2 * 0.1, n3 * 0.15);

                float alpha = falloff * structure * opacity;

                gl_FragColor = vec4(color, alpha);
              }
            `,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false,
            blending: THREE.AdditiveBlending
          });

          const nebula = new THREE.Mesh(nebulaGeometry, material);
          nebula.scale.set(config.size, config.size, 1);
          nebula.position.set(config.x, config.y, config.z);
          nebula.userData.baseY = config.y;
          nebula.userData.baseZ = config.z;
          this.nebulae.push(nebula);
          this.scene.add(nebula);
        });
      }

      // ====================================================================
      // COSMIC DUST - Close floating particles
      // ====================================================================
      createCosmicDust() {
        const dustCount = 2000;
        const positions = new Float32Array(dustCount * 3);
        const velocities = new Float32Array(dustCount * 3);

        for (let i = 0; i < dustCount; i++) {
          const i3 = i * 3;
          positions[i3] = (Math.random() - 0.5) * 150;
          positions[i3 + 1] = (Math.random() - 0.5) * 150;
          positions[i3 + 2] = (Math.random() - 0.5) * 150;
          velocities[i3] = (Math.random() - 0.5) * 0.015;
          velocities[i3 + 1] = (Math.random() - 0.5) * 0.015;
          velocities[i3 + 2] = (Math.random() - 0.5) * 0.015;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            scrollOffset: { value: 0 }
          },
          vertexShader: `
            attribute vec3 velocity;
            uniform float time;
            uniform float scrollOffset;
            varying float vAlpha;

            void main() {
              vec3 pos = position + velocity * time * 10.0;
              pos.y += scrollOffset * 0.04;
              pos = mod(pos + 75.0, 150.0) - 75.0;
              vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
              vAlpha = 0.35 * (1.0 - smoothstep(10.0, 80.0, -mvPosition.z));
              gl_PointSize = 1.2 * (40.0 / -mvPosition.z);
              gl_Position = projectionMatrix * mvPosition;
            }
          `,
          fragmentShader: `
            varying float vAlpha;
            void main() {
              float dist = length(gl_PointCoord - 0.5);
              float alpha = (1.0 - smoothstep(0.0, 0.5, dist)) * vAlpha;
              gl_FragColor = vec4(0.85, 0.8, 0.75, alpha);
            }
          `,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending
        });

        this.cosmicDust = new THREE.Points(geometry, material);
        this.scene.add(this.cosmicDust);
      }

      // ====================================================================
      // SINGULARITY - Clean Minimalist Black Hole
      // Using same techniques as vr-space-v1.html nebulae
      // ====================================================================
      createSingularity() {
        this.singularityGroup = new THREE.Group();
        this.singularityGroup.position.set(0, -50, -800);
        this.scene.add(this.singularityGroup);

        const BH_RADIUS = 20;
        const DISK_TILT = Math.PI * 0.4;
        this.BH_RADIUS = BH_RADIUS;
        this.DISK_TILT = DISK_TILT;

        // ========== 1. EVENT HORIZON (Pure black sphere) ==========
        const bhGeo = new THREE.SphereGeometry(BH_RADIUS, 64, 64);
        const bhMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        this.eventHorizon = new THREE.Mesh(bhGeo, bhMat);
        this.singularityGroup.add(this.eventHorizon);

        // ========== 2. GLOW DISK (Simple plane with FBM shader - like nebulae) ==========
        const diskGeo = new THREE.PlaneGeometry(1, 1);
        const diskMat = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            bhRadius: { value: BH_RADIUS }
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            uniform float bhRadius;
            varying vec2 vUv;

            float hash(vec2 p) {
              return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
              vec2 i = floor(p);
              vec2 f = fract(p);
              f = f * f * (3.0 - 2.0 * f);
              return mix(mix(hash(i), hash(i + vec2(1,0)), f.x),
                         mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), f.x), f.y);
            }

            float fbm(vec2 p) {
              float v = 0.0, a = 0.5;
              for (int i = 0; i < 4; i++) { v += a * noise(p); p *= 2.0; a *= 0.5; }
              return v;
            }

            void main() {
              vec2 uv = vUv - 0.5;
              float dist = length(uv);
              float angle = atan(uv.y, uv.x);

              // Disk shape: ring between inner and outer radius
              float inner = 0.12;
              float outer = 0.45;
              float ring = smoothstep(inner, inner + 0.05, dist) * smoothstep(outer, outer - 0.1, dist);

              // Black hole cutout (slightly larger than visual)
              float bhCut = smoothstep(0.08, 0.11, dist);

              // Rotation animation
              float rotAngle = angle - time * 0.08;

              // FBM turbulence (like nebulae)
              vec2 turbUv = vec2(rotAngle * 2.0, dist * 8.0);
              float turb = fbm(turbUv + time * 0.02);

              // Spiral arms
              float spiral = sin(rotAngle * 3.0 + dist * 15.0) * 0.3 + 0.7;

              // Temperature: hotter near center (orange ‚Üí gold ‚Üí brown)
              float temp = 1.0 - smoothstep(inner, outer, dist);
              vec3 hotColor = vec3(1.0, 0.6, 0.2);   // Orange
              vec3 warmColor = vec3(0.9, 0.7, 0.3);  // Gold
              vec3 coolColor = vec3(0.5, 0.3, 0.15); // Brown
              vec3 color = mix(coolColor, mix(warmColor, hotColor, temp), temp);

              // Doppler effect (one side brighter)
              float doppler = 0.7 + 0.3 * cos(rotAngle);

              // Combine
              color *= turb * spiral * doppler;
              float alpha = ring * bhCut * (0.6 + turb * 0.3);

              gl_FragColor = vec4(color, alpha);
            }
          `,
          transparent: true,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        this.accretionDisk = new THREE.Mesh(diskGeo, diskMat);
        this.accretionDisk.scale.set(BH_RADIUS * 10, BH_RADIUS * 10, 1);
        this.accretionDisk.rotation.x = DISK_TILT;
        this.singularityGroup.add(this.accretionDisk);

        // ========== 3. PHOTON RING (Simple glowing torus) ==========
        const ringGeo = new THREE.TorusGeometry(BH_RADIUS * 1.2, 0.4, 16, 100);
        const ringMat = new THREE.MeshBasicMaterial({
          color: 0xffddaa,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending
        });
        this.photonRing = new THREE.Mesh(ringGeo, ringMat);
        this.photonRing.rotation.x = Math.PI / 2;
        this.singularityGroup.add(this.photonRing);

        // ========== 4. EDGE GLOW (Soft halo around black hole) ==========
        const glowGeo = new THREE.PlaneGeometry(1, 1);
        const glowMat = new THREE.ShaderMaterial({
          uniforms: { time: { value: 0 } },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            varying vec2 vUv;

            void main() {
              vec2 uv = vUv - 0.5;
              float dist = length(uv);

              // Soft glow ring at edge of black hole
              float glow = smoothstep(0.25, 0.15, dist) * smoothstep(0.1, 0.15, dist);
              float pulse = 0.8 + sin(time * 0.3) * 0.2;

              vec3 color = vec3(1.0, 0.85, 0.5); // Warm gold
              float alpha = glow * pulse * 0.5;

              gl_FragColor = vec4(color, alpha);
            }
          `,
          transparent: true,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        this.innerGlow = new THREE.Mesh(glowGeo, glowMat);
        this.innerGlow.scale.set(BH_RADIUS * 4, BH_RADIUS * 4, 1);
        this.singularityGroup.add(this.innerGlow);

        // ========== 5. TOKEN ORBITS ==========
        this.tokenMeshes = [];
        this.particles = null; // No separate particles needed
      }

      // Load tokens from HolDex API
      async loadHolDexTokens() {
        try {
          const response = await fetch('https://asdev-backend.onrender.com/api/tokens?limit=8&verified=true');
          const data = await response.json();

          if (data.success && data.tokens) {
            // Clear existing token meshes
            this.tokenMeshes.forEach(t => this.singularityGroup.remove(t.mesh));
            this.tokenMeshes = [];

            const tokens = data.tokens.slice(0, 8);
            tokens.forEach((token, i) => {
              this.createTokenMesh(token, i, tokens.length);
            });

            console.log('Loaded', tokens.length, 'tokens from HolDex');
          }
        } catch (e) {
          console.log('HolDex tokens unavailable, using defaults');
          this.loadDefaultTokens();
        }
      }

      // Create elegant token mesh with glow
      createTokenMesh(token, index, total) {
        const kscore = token.kscore || token.k_score || 50;
        // Higher K-score = closer orbit (more trusted = closer to the singularity)
        const orbitRadius = this.BH_RADIUS * 10 - (kscore * 0.03);

        const color = this.getTokenColor(token.symbol);

        // Token sphere with fresnel glow shader
        const geo = new THREE.SphereGeometry(2.5, 32, 32);
        const mat = new THREE.ShaderMaterial({
          uniforms: {
            color: { value: new THREE.Color(color) },
            time: { value: 0 }
          },
          vertexShader: `
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            void main() {
              vNormal = normalize(normalMatrix * normal);
              vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
              vViewPosition = -mvPosition.xyz;
              gl_Position = projectionMatrix * mvPosition;
            }
          `,
          fragmentShader: `
            uniform vec3 color;
            uniform float time;
            varying vec3 vNormal;
            varying vec3 vViewPosition;

            void main() {
              vec3 viewDir = normalize(vViewPosition);
              float fresnel = pow(1.0 - abs(dot(viewDir, vNormal)), 2.0);

              // Core color with fresnel edge glow
              vec3 coreColor = color * 0.8;
              vec3 glowColor = color * 1.5;
              vec3 finalColor = mix(coreColor, glowColor, fresnel);

              // Subtle pulse
              float pulse = 0.9 + sin(time * 0.8) * 0.1;

              gl_FragColor = vec4(finalColor * pulse, 0.95);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        const mesh = new THREE.Mesh(geo, mat);
        this.singularityGroup.add(mesh);

        // Outer glow ring
        const glowGeo = new THREE.RingGeometry(3, 4.5, 48);
        const glowMat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.25,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending
        });
        const glowRing = new THREE.Mesh(glowGeo, glowMat);
        mesh.add(glowRing);

        // Orbital trail (thin arc behind token)
        const trailGeo = new THREE.TorusGeometry(orbitRadius, 0.15, 8, 64, Math.PI * 0.3);
        const trailMat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.15,
          blending: THREE.AdditiveBlending
        });
        const trail = new THREE.Mesh(trailGeo, trailMat);
        trail.rotation.x = this.DISK_TILT;
        trail.rotation.z = (index / total) * Math.PI * 2;
        this.singularityGroup.add(trail);

        this.tokenMeshes.push({
          mesh,
          glowRing,
          trail,
          symbol: token.symbol,
          angle: (index / total) * Math.PI * 2,
          radius: orbitRadius,
          // Keplerian speed: v ‚àù r^(-1/2) - inner orbits faster
          speed: 0.15 / Math.sqrt(orbitRadius / this.BH_RADIUS),
          yOffset: (Math.random() - 0.5) * 6,
          phase: Math.random() * Math.PI * 2  // Random phase for oscillation
        });
      }

      getTokenColor(symbol) {
        const colors = {
          'SOL': 0x9945FF,
          'JUP': 0xd4a574,
          'USDC': 0x2775CA,
          'BONK': 0xF7931A,
          'RAY': 0x14F195,
          'mSOL': 0x00D18C,
          'PYTH': 0x6B4EE6,
          'WIF': 0xE8A838,
          'asdfasdfa': 0xffd700  // Our token - gold
        };
        return colors[symbol] || 0xd4a574; // Default to warm gold
      }

      loadDefaultTokens() {
        const defaults = [
          { symbol: 'SOL', kscore: 95 },
          { symbol: 'JUP', kscore: 90 },
          { symbol: 'USDC', kscore: 88 },
          { symbol: 'BONK', kscore: 70 },
          { symbol: 'RAY', kscore: 75 },
          { symbol: 'mSOL', kscore: 80 }
        ];

        defaults.forEach((token, i) => {
          this.createTokenMesh(token, i, defaults.length);
        });
      }

      // ====================================================================
      // POST-PROCESSING - Bloom for glow effects (like vr-space-v1)
      // ====================================================================
      setupPostProcessing() {
        this.composer = new EffectComposer(this.renderer);

        const renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);

        // Subtle bloom for glow - exact vr-space-v1 settings
        this.bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          0.4,   // strength
          0.5,   // radius
          0.6    // threshold
        );
        this.composer.addPass(this.bloomPass);
      }

      // ====================================================================
      // PHYSICS - Scroll + Mouse parallax
      // ====================================================================
      updatePhysics() {
        this.maxScroll = Math.max(1, document.body.scrollHeight - window.innerHeight);
        this.scrollProgress = this.targetScrollY / this.maxScroll;

        const scrollLerp = 0.06;
        const prevScrollY = this.scrollY;
        this.scrollY += (this.targetScrollY - this.scrollY) * scrollLerp;
        this.scrollVelocity = this.scrollY - prevScrollY;

        const rawWarp = Math.abs(this.scrollVelocity) / 12;
        this.warpSpeed = this.warpSpeed || 0;
        this.warpSpeed += (Math.min(1, rawWarp) - this.warpSpeed) * 0.08;

        // ========== TRAJECTORY VERS LA SINGULARIT√â ==========
        const t = this.scrollProgress;

        // Spirale subtile qui converge vers le centre
        const spiralRadius = 40 * Math.sin(t * Math.PI) * (1 - t * 0.5);
        const spiralAngle = t * Math.PI * 2.5;

        // On s'enfonce dans l'espace vers la singularit√©
        const baseZ = 5 - (t * 850);
        const baseY = -t * 100;

        // Position cam√©ra avec spirale
        this.camera.position.z += (baseZ - this.camera.position.z) * scrollLerp;
        this.camera.position.y += (baseY + Math.sin(spiralAngle) * spiralRadius * 0.3 - this.camera.position.y) * scrollLerp;
        this.camera.position.x += (Math.cos(spiralAngle) * spiralRadius - this.camera.position.x) * scrollLerp;

        // Enhanced mouse parallax (intensity++)
        this.mouseX += (this.targetMouseX - this.mouseX) * 0.04;
        this.mouseY += (this.targetMouseY - this.mouseY) * 0.04;

        const parallaxX = this.mouseX * this.mouseParallaxIntensity;
        const parallaxY = this.mouseY * this.mouseParallaxIntensity * 0.6;

        this.camera.position.x += parallaxX;
        this.camera.position.y += parallaxY;

        // Camera look toward singularity with mouse influence
        const lookTarget = new THREE.Vector3(
          this.singularityGroup.position.x + this.mouseX * 15,
          this.singularityGroup.position.y + this.mouseY * 10,
          this.singularityGroup.position.z
        );
        this.camera.lookAt(lookTarget);

        // Subtle camera roll based on mouse
        this.camera.rotation.z = -this.mouseX * 0.08;

        // ========== SINGULARITY APPROACH ==========
        // La singularit√© "grandit" √† mesure qu'on s'approche
        const singularityScale = 1 + t * 3;
        this.singularityGroup.scale.setScalar(singularityScale);

        // Falling effect at the end (smooth acceleration)
        if (t > 0.85) {
          const fallProgress = (t - 0.85) / 0.15;
          const fallAccel = Math.pow(fallProgress, 2);
          this.camera.position.z -= fallAccel * 50;
        }
      }

      // ====================================================================
      // ANIMATION LOOP
      // ====================================================================
      animate() {
        requestAnimationFrame(() => this.animate());
        this.time += 0.016;
        this.updatePhysics();

        // Stars
        if (this.stars) {
          this.stars.material.uniforms.time.value = this.time;
          this.stars.material.uniforms.warpSpeed.value = this.warpSpeed || 0;
          this.stars.position.x = this.camera.position.x * 0.4;
          this.stars.position.y = this.camera.position.y * 0.5;
          this.stars.position.z = this.camera.position.z * 0.3;
          this.stars.rotation.y = this.time * 0.001;
        }

        // Milky Way
        if (this.milkyWay) {
          this.milkyWay.material.uniforms.time.value = this.time;
          this.milkyWay.position.x = this.camera.position.x * 0.15;
          this.milkyWay.position.y = this.camera.position.y * 0.2;
          this.milkyWay.position.z = this.camera.position.z * 0.1;
          this.milkyWay.material.uniforms.globalOpacity.value = 1.0 - this.scrollProgress * 0.4;
        }

        // Nebulae
        this.nebulae.forEach((nebula, i) => {
          nebula.material.uniforms.time.value = this.time;
          const depthFactor = 0.25 + (i * 0.12);
          nebula.position.y = nebula.userData.baseY + this.camera.position.y * depthFactor;
          nebula.position.z = nebula.userData.baseZ + this.camera.position.z * (depthFactor * 0.4);
          nebula.lookAt(this.camera.position);
        });

        // Cosmic dust
        if (this.cosmicDust) {
          this.cosmicDust.material.uniforms.time.value = this.time;
          this.cosmicDust.material.uniforms.scrollOffset.value = this.scrollProgress * 400;
          this.cosmicDust.position.y = this.camera.position.y * 0.9;
          this.cosmicDust.position.z = this.camera.position.z * 0.85;
        }

        // ===== SINGULARITY BLACK HOLE ANIMATION =====
        // Clean minimalist approach using FBM shaders

        // Accretion disk - FBM shader (time drives rotation + turbulence)
        if (this.accretionDisk && this.accretionDisk.material.uniforms) {
          this.accretionDisk.material.uniforms.time.value = this.time;
        }

        // Photon ring - simple rotation (MeshBasicMaterial, no uniforms)
        if (this.photonRing) {
          this.photonRing.rotation.z += 0.002;
          // Pulse opacity based on scroll
          this.photonRing.material.opacity = 0.5 + this.scrollProgress * 0.3;
        }

        // Inner glow - shader time + billboard to camera
        if (this.innerGlow && this.innerGlow.material.uniforms) {
          this.innerGlow.material.uniforms.time.value = this.time;
          this.innerGlow.lookAt(this.camera.position);
        }

        // Token orbits - elegant Keplerian motion
        if (this.tokenMeshes && this.tokenMeshes.length > 0) {
          this.tokenMeshes.forEach(t => {
            // Keplerian orbital speed (inner = faster)
            t.angle += t.speed * 0.01;

            // Smooth orbital position with disk tilt
            const tiltedAngle = t.angle;
            const x = Math.cos(tiltedAngle) * t.radius;
            const z = Math.sin(tiltedAngle) * t.radius * Math.cos(this.DISK_TILT);
            // Vertical oscillation following disk tilt
            const y = t.yOffset + Math.sin(tiltedAngle) * t.radius * Math.sin(this.DISK_TILT) * 0.3;

            t.mesh.position.set(x, y, z);

            // Update shader time for fresnel animation
            if (t.mesh.material.uniforms) {
              t.mesh.material.uniforms.time.value = this.time;
            }

            // Face camera smoothly
            t.mesh.lookAt(this.camera.position);

            // Pulse glow ring
            if (t.glowRing && t.glowRing.material) {
              t.glowRing.material.opacity = 0.2 + Math.sin(this.time * 0.4 + t.phase) * 0.1;
            }

            // Update trail rotation to follow token
            if (t.trail) {
              t.trail.rotation.z = t.angle - Math.PI * 0.15;
            }
          });
        }

        // ===== POST-PROCESSING UPDATES =====

        // Bloom intensity based on warp and proximity
        if (this.bloomPass) {
          if (this.scrollProgress <= 0.85) {
            this.bloomPass.strength = 0.4 + (this.warpSpeed || 0) * 0.3 + this.scrollProgress * 0.2;
          } else {
            // Intense bloom during final fall
            const fallProgress = (this.scrollProgress - 0.85) / 0.15;
            this.bloomPass.strength = 0.6 + fallProgress * 1.0;
          }
        }

        // Vignette intensifies toward the end
        if (this.vignettePass) {
          this.vignettePass.uniforms.intensity.value = 0.3 + this.scrollProgress * 0.3;
        }

        this.composer.render();
      }

      // ====================================================================
      // EVENT LISTENERS
      // ====================================================================
      setupEventListeners() {
        window.addEventListener('scroll', () => {
          this.targetScrollY = window.scrollY;
        }, { passive: true });

        window.addEventListener('resize', () => {
          const width = window.innerWidth;
          const height = window.innerHeight;
          this.camera.aspect = width / height;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(width, height);
          this.composer.setSize(width, height);
        });

        // Enhanced mouse tracking
        window.addEventListener('mousemove', (e) => {
          this.targetMouseX = (e.clientX / window.innerWidth - 0.5) * 2;
          this.targetMouseY = (e.clientY / window.innerHeight - 0.5) * 2;
        });

        // Touch support for mobile
        window.addEventListener('touchmove', (e) => {
          if (e.touches.length === 1) {
            this.targetMouseX = (e.touches[0].clientX / window.innerWidth - 0.5) * 2;
            this.targetMouseY = (e.touches[0].clientY / window.innerHeight - 0.5) * 2;
          }
        }, { passive: true });
      }
    }

    // ========================================================================
    // SCROLL REVEAL
    // ========================================================================
    function initReveal() {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
          }
        });
      }, { threshold: 0.1 });

      document.querySelectorAll('.reveal').forEach(el => observer.observe(el));
    }

    // ========================================================================
    // LIVE DATA
    // ========================================================================
    const GASDF_API = 'https://gasdf-43r8.onrender.com';
    const HOLDEX_API = 'https://asdev-backend.onrender.com/api';
    const ASDF_MINT = '9zB5wRarXMj86MymwLumSKA1Dx35zPqqKfcZtK1Spump';

    let lastHolDexUpdate = Date.now();
    let currentBurned = 0;
    let currentTx = 0;

    function formatNum(n) {
      if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
      if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
      return n.toFixed(0);
    }

    function formatPrice(price) {
      if (price >= 1) return '$' + price.toFixed(2);
      if (price >= 0.01) return '$' + price.toFixed(4);
      return '$' + price.toFixed(6);
    }

    function formatUSD(num) {
      if (num >= 1e6) return '$' + (num / 1e6).toFixed(1) + 'M';
      if (num >= 1e3) return '$' + (num / 1e3).toFixed(1) + 'K';
      if (num >= 1) return '$' + num.toFixed(0);
      return '$' + num.toFixed(2);
    }

    function animateValue(element, start, end, duration) {
      const startTime = performance.now();
      const update = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3);
        const value = start + (end - start) * eased;

        if (value >= 1e6) {
          element.textContent = '$' + (value / 1e6).toFixed(2) + 'M';
        } else if (value >= 1e3) {
          element.textContent = '$' + (value / 1e3).toFixed(1) + 'K';
        } else {
          element.textContent = '$' + Math.round(value);
        }

        if (progress < 1) requestAnimationFrame(update);
      };
      requestAnimationFrame(update);
    }

    async function loadLiveData() {
      try {
        const statsRes = await fetch(`${GASDF_API}/stats`);
        const stats = await statsRes.json();

        if (stats.totalBurned) {
          const burned = stats.totalBurned / 1e6;
          const burnedEl = document.getElementById('statBurned');
          animateValue(burnedEl, currentBurned, burned, 1500);
          burnedEl.classList.add('bump');
          setTimeout(() => burnedEl.classList.remove('bump'), 300);
          currentBurned = burned;
        }
        if (stats.totalTransactions) {
          const txEl = document.getElementById('statTx');
          txEl.textContent = stats.totalTransactions.toLocaleString();
          txEl.classList.add('bump');
          setTimeout(() => txEl.classList.remove('bump'), 300);
        }
      } catch (e) {
        console.log('Stats unavailable');
      }

      try {
        const tokenRes = await fetch(`${HOLDEX_API}/token/${ASDF_MINT}`);
        const data = await tokenRes.json();
        if (data.success && data.token) {
          const t = data.token;
          const supply = parseInt(t.supply) / Math.pow(10, t.decimals || 6);
          const price = t.priceUsd || t.priceusd || 0;
          const mcap = t.marketCap || t.marketcap || price * supply;
          const holders = t.real_holders || t.holders || 0;

          document.getElementById('tokenPrice').textContent = formatPrice(price);
          document.getElementById('tokenMcap').textContent = formatUSD(mcap);
          document.getElementById('tokenHolders').textContent = holders.toLocaleString();

          const d = supply * TIER_THRESHOLDS.diamond;
          const p = supply * TIER_THRESHOLDS.platinum;
          const g = supply * TIER_THRESHOLDS.gold;
          const s = supply * TIER_THRESHOLDS.silver;

          document.getElementById('diamondTokens').textContent = formatNum(d);
          document.getElementById('platinumTokens').textContent = formatNum(p);
          document.getElementById('goldTokens').textContent = formatNum(g);
          document.getElementById('silverTokens').textContent = formatNum(s);

          document.getElementById('diamondUsd').textContent = '~' + formatUSD(d * price);
          document.getElementById('platinumUsd').textContent = '~' + formatUSD(p * price);
          document.getElementById('goldUsd').textContent = '~' + formatUSD(g * price);
          document.getElementById('silverUsd').textContent = '~' + formatUSD(s * price);

          lastHolDexUpdate = Date.now();
          document.getElementById('tierUpdateTime').textContent = 'just now';
        }
      } catch (e) {
        console.log('HolDex unavailable');
      }
    }

    function updateTimeAgo() {
      const seconds = Math.floor((Date.now() - lastHolDexUpdate) / 1000);
      const el = document.getElementById('tierUpdateTime');
      if (el) {
        if (seconds < 60) el.textContent = 'just now';
        else if (seconds < 120) el.textContent = '1 min ago';
        else el.textContent = Math.floor(seconds / 60) + ' mins ago';
      }
    }

    // ========================================================================
    // LIVE TICKER
    // ========================================================================
    const tickerMessages = [
      'üî• Diamond holder just burned 1,234 USDC in fees',
      'üíé Platinum user saved $456 on transaction',
      '‚ö° New transaction processed on Solana mainnet',
      'ü•á Gold tier unlocked: 10K+ $asdfasdfa burned',
      'üöÄ Supply keeps shrinking with every transaction',
      'ü•à Silver tier user saved 15% on fees today',
    ];
    let tickerIndex = 0;

    function updateTicker() {
      const ticker = document.getElementById('liveTicker');
      if (ticker) {
        ticker.style.opacity = 0;
        setTimeout(() => {
          ticker.textContent = tickerMessages[tickerIndex];
          ticker.style.opacity = 1;
          tickerIndex = (tickerIndex + 1) % tickerMessages.length;
        }, 500);
      }
    }

    // ========================================================================
    // PROGRESS DOTS - 5 Fibonacci steps
    // ========================================================================
    const sections = ['hero', 'how', 'ecosystem', 'phi', 'cta'];
    const progressLabels = {
      'hero': 'Awakening',
      'how': 'Understanding',
      'ecosystem': 'Exploring',
      'phi': 'Enlightened',
      'cta': 'Singularity'
    };

    // Map tiers section to ecosystem step (merged in 5-step journey)
    const sectionMapping = {
      'hero': 'hero',
      'how': 'how',
      'ecosystem': 'ecosystem',
      'tiers': 'ecosystem',  // Tiers is part of Exploration
      'phi': 'phi',
      'cta': 'cta'
    };

    function updateProgress() {
      const scrollPosition = window.scrollY + window.innerHeight / 2;
      let activeSection = 'hero';

      // Check all HTML sections (including tiers)
      const allSections = ['hero', 'how', 'ecosystem', 'tiers', 'phi', 'cta'];
      for (const section of allSections) {
        const el = document.getElementById(section);
        if (el && el.offsetTop <= scrollPosition) {
          activeSection = sectionMapping[section] || section;
        }
      }

      const progressDots = document.querySelectorAll('.progress-dot');
      progressDots.forEach((dot, i) => {
        if (i <= sections.indexOf(activeSection)) {
          dot.classList.add('active');
        } else {
          dot.classList.remove('active');
        }
      });

      const progressLabel = document.querySelector('.progress-label');
      if (progressLabel) {
        progressLabel.textContent = progressLabels[activeSection] || 'Awakening';
      }
    }

    // ========================================================================
    // INIT
    // ========================================================================
    document.addEventListener('DOMContentLoaded', () => {
      initPhiValues();
      renderTokenGrid();

      // Initialize VR Space Renderer
      const canvas = document.getElementById('singularity-bg');
      const spaceRenderer = new SpaceRenderer(canvas);

      // Load live tokens from HolDex API
      spaceRenderer.loadHolDexTokens();

      initReveal();
      loadLiveData();

      updateTicker();
      setInterval(updateTicker, 5000);

      window.addEventListener('scroll', updateProgress, { passive: true });
      updateProgress();

      setInterval(updateTimeAgo, 30000);
      setInterval(loadLiveData, 30000);
    });
  </script>
</body>
</html>
